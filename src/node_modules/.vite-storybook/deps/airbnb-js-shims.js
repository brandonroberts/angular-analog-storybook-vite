import {
  require_is_regex,
  require_is_symbol,
  require_shams as require_shams2
} from "./chunk-KG7BQZDK.js";
import {
  require_object_inspect,
  require_side_channel
} from "./chunk-7WVRA4VD.js";
import {
  require_callBound,
  require_call_bind,
  require_get_intrinsic,
  require_has_symbols,
  require_shams,
  require_src
} from "./chunk-2FEBKAZL.js";
import {
  __commonJS,
  init_define_ngDevMode
} from "./chunk-XN7ES5DP.js";

// node_modules/es5-shim/es5-shim.js
var require_es5_shim = __commonJS({
  "node_modules/es5-shim/es5-shim.js"(exports, module) {
    init_define_ngDevMode();
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.returnExports = factory();
      }
    })(exports, function() {
      var $Array = Array;
      var ArrayPrototype = $Array.prototype;
      var $Object = Object;
      var ObjectPrototype = $Object.prototype;
      var $Function = Function;
      var FunctionPrototype = $Function.prototype;
      var $String = String;
      var StringPrototype = $String.prototype;
      var $Number = Number;
      var NumberPrototype = $Number.prototype;
      var array_slice = ArrayPrototype.slice;
      var array_splice = ArrayPrototype.splice;
      var array_push = ArrayPrototype.push;
      var array_unshift = ArrayPrototype.unshift;
      var array_concat = ArrayPrototype.concat;
      var array_join = ArrayPrototype.join;
      var call = FunctionPrototype.call;
      var apply = FunctionPrototype.apply;
      var max = Math.max;
      var min = Math.min;
      var floor = Math.floor;
      var abs = Math.abs;
      var pow = Math.pow;
      var round = Math.round;
      var log = Math.log;
      var LOG10E = Math.LOG10E;
      var log10 = Math.log10 || function log102(value) {
        return log(value) * LOG10E;
      };
      var to_string = ObjectPrototype.toString;
      var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
      var isCallable;
      var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class /, isES6ClassFn = function isES6ClassFn2(value) {
        try {
          var fnStr = fnToStr.call(value);
          var singleStripped = fnStr.replace(/\/\/.*\n/g, "");
          var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, "");
          var spaceStripped = multiStripped.replace(/\n/mg, " ").replace(/ {2}/g, " ");
          return constructorRegex.test(spaceStripped);
        } catch (e) {
          return false;
        }
      }, tryFunctionObject = function tryFunctionObject2(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e) {
          return false;
        }
      }, fnClass = "[object Function]", genClass = "[object GeneratorFunction]", isCallable = function isCallable2(value) {
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = to_string.call(value);
        return strClass === fnClass || strClass === genClass;
      };
      var isRegex;
      var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec2(value) {
        try {
          regexExec.call(value);
          return true;
        } catch (e) {
          return false;
        }
      }, regexClass = "[object RegExp]";
      isRegex = function isRegex2(value) {
        if (typeof value !== "object") {
          return false;
        }
        return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass;
      };
      var isString;
      var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject2(value) {
        try {
          strValue.call(value);
          return true;
        } catch (e) {
          return false;
        }
      }, stringClass = "[object String]";
      isString = function isString2(value) {
        if (typeof value === "string") {
          return true;
        }
        if (typeof value !== "object") {
          return false;
        }
        return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass;
      };
      var supportsDescriptors = $Object.defineProperty && function() {
        try {
          var obj = {};
          $Object.defineProperty(obj, "x", {
            enumerable: false,
            value: obj
          });
          for (var _ in obj) {
            return false;
          }
          return obj.x === obj;
        } catch (e) {
          return false;
        }
      }();
      var defineProperties = function(has) {
        var defineProperty;
        if (supportsDescriptors) {
          defineProperty = function(object, name, method, forceAssign) {
            if (!forceAssign && name in object) {
              return;
            }
            $Object.defineProperty(object, name, {
              configurable: true,
              enumerable: false,
              writable: true,
              value: method
            });
          };
        } else {
          defineProperty = function(object, name, method, forceAssign) {
            if (!forceAssign && name in object) {
              return;
            }
            object[name] = method;
          };
        }
        return function defineProperties2(object, map, forceAssign) {
          for (var name in map) {
            if (has.call(map, name)) {
              defineProperty(object, name, map[name], forceAssign);
            }
          }
        };
      }(ObjectPrototype.hasOwnProperty);
      if ($Object.defineProperty && supportsDescriptors) {
        var F = function() {
        };
        var toStringSentinel = {};
        var sentinel = {
          toString: toStringSentinel
        };
        $Object.defineProperty(F, "prototype", {
          value: sentinel,
          writable: false
        });
        if (new F().toString !== toStringSentinel) {
          var $dP = $Object.defineProperty;
          var $gOPD = $Object.getOwnPropertyDescriptor;
          defineProperties($Object, {
            defineProperty: function defineProperty(o, k, d) {
              var key = $String(k);
              if (typeof o === "function" && key === "prototype") {
                var desc = $gOPD(o, key);
                if (desc.writable && !d.writable && "value" in d) {
                  try {
                    o[key] = d.value;
                  } catch (e) {
                  }
                }
                return $dP(o, key, {
                  configurable: "configurable" in d ? d.configurable : desc.configurable,
                  enumerable: "enumerable" in d ? d.enumerable : desc.enumerable,
                  writable: d.writable
                });
              }
              return $dP(o, key, d);
            }
          }, true);
        }
      }
      var isPrimitive = function isPrimitive2(input) {
        var type = typeof input;
        return input === null || type !== "object" && type !== "function";
      };
      var isActualNaN = $Number.isNaN || function isActualNaN2(x) {
        return x !== x;
      };
      var ES = {
        ToInteger: function ToInteger(num) {
          var n = +num;
          if (isActualNaN(n)) {
            n = 0;
          } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
            n = (n > 0 || -1) * floor(abs(n));
          }
          return n;
        },
        ToPrimitive: function ToPrimitive(input) {
          var val, valueOf, toStr2;
          if (isPrimitive(input)) {
            return input;
          }
          valueOf = input.valueOf;
          if (isCallable(valueOf)) {
            val = valueOf.call(input);
            if (isPrimitive(val)) {
              return val;
            }
          }
          toStr2 = input.toString;
          if (isCallable(toStr2)) {
            val = toStr2.call(input);
            if (isPrimitive(val)) {
              return val;
            }
          }
          throw new TypeError();
        },
        ToObject: function(o) {
          if (o == null) {
            throw new TypeError("can't convert " + o + " to object");
          }
          return $Object(o);
        },
        ToUint32: function ToUint32(x) {
          return x >>> 0;
        }
      };
      var Empty = function Empty2() {
      };
      defineProperties(FunctionPrototype, {
        bind: function bind(that) {
          var target = this;
          if (!isCallable(target)) {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
          }
          var args = array_slice.call(arguments, 1);
          var bound;
          var binder = function() {
            if (this instanceof bound) {
              var result = apply.call(target, this, array_concat.call(args, array_slice.call(arguments)));
              if ($Object(result) === result) {
                return result;
              }
              return this;
            }
            return apply.call(target, that, array_concat.call(args, array_slice.call(arguments)));
          };
          var boundLength = max(0, target.length - args.length);
          var boundArgs = [];
          for (var i = 0; i < boundLength; i++) {
            array_push.call(boundArgs, "$" + i);
          }
          bound = $Function("binder", "return function (" + array_join.call(boundArgs, ",") + "){ return binder.apply(this, arguments); }")(binder);
          if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
          }
          return bound;
        }
      });
      var owns = call.bind(ObjectPrototype.hasOwnProperty);
      var toStr = call.bind(ObjectPrototype.toString);
      var arraySlice = call.bind(array_slice);
      var arraySliceApply = apply.bind(array_slice);
      if (typeof document === "object" && document && document.documentElement) {
        try {
          arraySlice(document.documentElement.childNodes);
        } catch (e) {
          var origArraySlice = arraySlice;
          var origArraySliceApply = arraySliceApply;
          arraySlice = function arraySliceIE(arr) {
            var r = [];
            var i = arr.length;
            while (i-- > 0) {
              r[i] = arr[i];
            }
            return origArraySliceApply(r, origArraySlice(arguments, 1));
          };
          arraySliceApply = function arraySliceApplyIE(arr, args) {
            return origArraySliceApply(arraySlice(arr), args);
          };
        }
      }
      var strSlice = call.bind(StringPrototype.slice);
      var strSplit = call.bind(StringPrototype.split);
      var strIndexOf = call.bind(StringPrototype.indexOf);
      var pushCall = call.bind(array_push);
      var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
      var arraySort = call.bind(ArrayPrototype.sort);
      var isArray = $Array.isArray || function isArray2(obj) {
        return toStr(obj) === "[object Array]";
      };
      var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
      defineProperties(ArrayPrototype, {
        unshift: function() {
          array_unshift.apply(this, arguments);
          return this.length;
        }
      }, hasUnshiftReturnValueBug);
      defineProperties($Array, {
        isArray
      });
      var boxedString = $Object("a");
      var splitString = boxedString[0] !== "a" || !(0 in boxedString);
      var properlyBoxesContext = function properlyBoxed(method) {
        var properlyBoxesNonStrict = true;
        var properlyBoxesStrict = true;
        var threwException = false;
        if (method) {
          try {
            method.call("foo", function(_, __, context) {
              if (typeof context !== "object") {
                properlyBoxesNonStrict = false;
              }
            });
            method.call([1], function() {
              "use strict";
              properlyBoxesStrict = typeof this === "string";
            }, "x");
          } catch (e) {
            threwException = true;
          }
        }
        return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
      };
      defineProperties(ArrayPrototype, {
        forEach: function forEach(callbackfn) {
          var object = ES.ToObject(this);
          var self2 = splitString && isString(this) ? strSplit(this, "") : object;
          var i = -1;
          var length = ES.ToUint32(self2.length);
          var T;
          if (arguments.length > 1) {
            T = arguments[1];
          }
          if (!isCallable(callbackfn)) {
            throw new TypeError("Array.prototype.forEach callback must be a function");
          }
          while (++i < length) {
            if (i in self2) {
              if (typeof T === "undefined") {
                callbackfn(self2[i], i, object);
              } else {
                callbackfn.call(T, self2[i], i, object);
              }
            }
          }
        }
      }, !properlyBoxesContext(ArrayPrototype.forEach));
      defineProperties(ArrayPrototype, {
        map: function map(callbackfn) {
          var object = ES.ToObject(this);
          var self2 = splitString && isString(this) ? strSplit(this, "") : object;
          var length = ES.ToUint32(self2.length);
          var result = $Array(length);
          var T;
          if (arguments.length > 1) {
            T = arguments[1];
          }
          if (!isCallable(callbackfn)) {
            throw new TypeError("Array.prototype.map callback must be a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self2) {
              if (typeof T === "undefined") {
                result[i] = callbackfn(self2[i], i, object);
              } else {
                result[i] = callbackfn.call(T, self2[i], i, object);
              }
            }
          }
          return result;
        }
      }, !properlyBoxesContext(ArrayPrototype.map));
      defineProperties(ArrayPrototype, {
        filter: function filter(callbackfn) {
          var object = ES.ToObject(this);
          var self2 = splitString && isString(this) ? strSplit(this, "") : object;
          var length = ES.ToUint32(self2.length);
          var result = [];
          var value;
          var T;
          if (arguments.length > 1) {
            T = arguments[1];
          }
          if (!isCallable(callbackfn)) {
            throw new TypeError("Array.prototype.filter callback must be a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self2) {
              value = self2[i];
              if (typeof T === "undefined" ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
                pushCall(result, value);
              }
            }
          }
          return result;
        }
      }, !properlyBoxesContext(ArrayPrototype.filter));
      defineProperties(ArrayPrototype, {
        every: function every(callbackfn) {
          var object = ES.ToObject(this);
          var self2 = splitString && isString(this) ? strSplit(this, "") : object;
          var length = ES.ToUint32(self2.length);
          var T;
          if (arguments.length > 1) {
            T = arguments[1];
          }
          if (!isCallable(callbackfn)) {
            throw new TypeError("Array.prototype.every callback must be a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self2 && !(typeof T === "undefined" ? callbackfn(self2[i], i, object) : callbackfn.call(T, self2[i], i, object))) {
              return false;
            }
          }
          return true;
        }
      }, !properlyBoxesContext(ArrayPrototype.every));
      defineProperties(ArrayPrototype, {
        some: function some(callbackfn) {
          var object = ES.ToObject(this);
          var self2 = splitString && isString(this) ? strSplit(this, "") : object;
          var length = ES.ToUint32(self2.length);
          var T;
          if (arguments.length > 1) {
            T = arguments[1];
          }
          if (!isCallable(callbackfn)) {
            throw new TypeError("Array.prototype.some callback must be a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self2 && (typeof T === "undefined" ? callbackfn(self2[i], i, object) : callbackfn.call(T, self2[i], i, object))) {
              return true;
            }
          }
          return false;
        }
      }, !properlyBoxesContext(ArrayPrototype.some));
      var reduceCoercesToObject = false;
      if (ArrayPrototype.reduce) {
        reduceCoercesToObject = typeof ArrayPrototype.reduce.call("es5", function(_, __, ___, list) {
          return list;
        }) === "object";
      }
      defineProperties(ArrayPrototype, {
        reduce: function reduce(callbackfn) {
          var object = ES.ToObject(this);
          var self2 = splitString && isString(this) ? strSplit(this, "") : object;
          var length = ES.ToUint32(self2.length);
          if (!isCallable(callbackfn)) {
            throw new TypeError("Array.prototype.reduce callback must be a function");
          }
          if (length === 0 && arguments.length === 1) {
            throw new TypeError("reduce of empty array with no initial value");
          }
          var i = 0;
          var result;
          if (arguments.length >= 2) {
            result = arguments[1];
          } else {
            do {
              if (i in self2) {
                result = self2[i++];
                break;
              }
              if (++i >= length) {
                throw new TypeError("reduce of empty array with no initial value");
              }
            } while (true);
          }
          for (; i < length; i++) {
            if (i in self2) {
              result = callbackfn(result, self2[i], i, object);
            }
          }
          return result;
        }
      }, !reduceCoercesToObject);
      var reduceRightCoercesToObject = false;
      if (ArrayPrototype.reduceRight) {
        reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call("es5", function(_, __, ___, list) {
          return list;
        }) === "object";
      }
      defineProperties(ArrayPrototype, {
        reduceRight: function reduceRight(callbackfn) {
          var object = ES.ToObject(this);
          var self2 = splitString && isString(this) ? strSplit(this, "") : object;
          var length = ES.ToUint32(self2.length);
          if (!isCallable(callbackfn)) {
            throw new TypeError("Array.prototype.reduceRight callback must be a function");
          }
          if (length === 0 && arguments.length === 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
          }
          var result;
          var i = length - 1;
          if (arguments.length >= 2) {
            result = arguments[1];
          } else {
            do {
              if (i in self2) {
                result = self2[i--];
                break;
              }
              if (--i < 0) {
                throw new TypeError("reduceRight of empty array with no initial value");
              }
            } while (true);
          }
          if (i < 0) {
            return result;
          }
          do {
            if (i in self2) {
              result = callbackfn(result, self2[i], i, object);
            }
          } while (i--);
          return result;
        }
      }, !reduceRightCoercesToObject);
      var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
      defineProperties(ArrayPrototype, {
        indexOf: function indexOf(searchElement) {
          var self2 = splitString && isString(this) ? strSplit(this, "") : ES.ToObject(this);
          var length = ES.ToUint32(self2.length);
          if (length === 0) {
            return -1;
          }
          var i = 0;
          if (arguments.length > 1) {
            i = ES.ToInteger(arguments[1]);
          }
          i = i >= 0 ? i : max(0, length + i);
          for (; i < length; i++) {
            if (i in self2 && self2[i] === searchElement) {
              return i;
            }
          }
          return -1;
        }
      }, hasFirefox2IndexOfBug);
      var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
      defineProperties(ArrayPrototype, {
        lastIndexOf: function lastIndexOf(searchElement) {
          var self2 = splitString && isString(this) ? strSplit(this, "") : ES.ToObject(this);
          var length = ES.ToUint32(self2.length);
          if (length === 0) {
            return -1;
          }
          var i = length - 1;
          if (arguments.length > 1) {
            i = min(i, ES.ToInteger(arguments[1]));
          }
          i = i >= 0 ? i : length - abs(i);
          for (; i >= 0; i--) {
            if (i in self2 && searchElement === self2[i]) {
              return i;
            }
          }
          return -1;
        }
      }, hasFirefox2LastIndexOfBug);
      var spliceNoopReturnsEmptyArray = function() {
        var a = [1, 2];
        var result = a.splice();
        return a.length === 2 && isArray(result) && result.length === 0;
      }();
      defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
          if (arguments.length === 0) {
            return [];
          }
          return array_splice.apply(this, arguments);
        }
      }, !spliceNoopReturnsEmptyArray);
      var spliceWorksWithEmptyObject = function() {
        var obj = {};
        ArrayPrototype.splice.call(obj, 0, 0, 1);
        return obj.length === 1;
      }();
      var hasES6Defaults = [0, 1, 2].splice(0).length === 3;
      defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
          if (arguments.length === 0) {
            return [];
          }
          var args = arguments;
          this.length = max(ES.ToInteger(this.length), 0);
          if (arguments.length > 0 && typeof deleteCount !== "number") {
            args = arraySlice(arguments);
            if (args.length < 2) {
              pushCall(args, this.length - start);
            } else {
              args[1] = ES.ToInteger(deleteCount);
            }
          }
          return array_splice.apply(this, args);
        }
      }, !spliceWorksWithEmptyObject || !hasES6Defaults);
      var spliceWorksWithLargeSparseArrays = function() {
        var arr = new $Array(1e5);
        arr[8] = "x";
        arr.splice(1, 1);
        return arr.indexOf("x") === 7;
      }();
      var spliceWorksWithSmallSparseArrays = function() {
        var n = 256;
        var arr = [];
        arr[n] = "a";
        arr.splice(n + 1, 0, "b");
        return arr[n] === "a";
      }();
      defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
          var O = ES.ToObject(this);
          var A = [];
          var len = ES.ToUint32(O.length);
          var relativeStart = ES.ToInteger(start);
          var actualStart = relativeStart < 0 ? max(len + relativeStart, 0) : min(relativeStart, len);
          var actualDeleteCount = arguments.length === 0 ? 0 : arguments.length === 1 ? len - actualStart : min(max(ES.ToInteger(deleteCount), 0), len - actualStart);
          var k = 0;
          var from;
          while (k < actualDeleteCount) {
            from = $String(actualStart + k);
            if (owns(O, from)) {
              A[k] = O[from];
            }
            k += 1;
          }
          var items = arraySlice(arguments, 2);
          var itemCount = items.length;
          var to;
          if (itemCount < actualDeleteCount) {
            k = actualStart;
            var maxK = len - actualDeleteCount;
            while (k < maxK) {
              from = $String(k + actualDeleteCount);
              to = $String(k + itemCount);
              if (owns(O, from)) {
                O[to] = O[from];
              } else {
                delete O[to];
              }
              k += 1;
            }
            k = len;
            var minK = len - actualDeleteCount + itemCount;
            while (k > minK) {
              delete O[k - 1];
              k -= 1;
            }
          } else if (itemCount > actualDeleteCount) {
            k = len - actualDeleteCount;
            while (k > actualStart) {
              from = $String(k + actualDeleteCount - 1);
              to = $String(k + itemCount - 1);
              if (owns(O, from)) {
                O[to] = O[from];
              } else {
                delete O[to];
              }
              k -= 1;
            }
          }
          k = actualStart;
          for (var i = 0; i < items.length; ++i) {
            O[k] = items[i];
            k += 1;
          }
          O.length = len - actualDeleteCount + itemCount;
          return A;
        }
      }, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);
      var originalJoin = ArrayPrototype.join;
      var hasStringJoinBug;
      try {
        hasStringJoinBug = Array.prototype.join.call("123", ",") !== "1,2,3";
      } catch (e) {
        hasStringJoinBug = true;
      }
      if (hasStringJoinBug) {
        defineProperties(ArrayPrototype, {
          join: function join(separator) {
            var sep = typeof separator === "undefined" ? "," : separator;
            return originalJoin.call(isString(this) ? strSplit(this, "") : this, sep);
          }
        }, hasStringJoinBug);
      }
      var hasJoinUndefinedBug = [1, 2].join(void 0) !== "1,2";
      if (hasJoinUndefinedBug) {
        defineProperties(ArrayPrototype, {
          join: function join(separator) {
            var sep = typeof separator === "undefined" ? "," : separator;
            return originalJoin.call(this, sep);
          }
        }, hasJoinUndefinedBug);
      }
      var pushShim = function push(item) {
        var O = ES.ToObject(this);
        var n = ES.ToUint32(O.length);
        var i = 0;
        while (i < arguments.length) {
          O[n + i] = arguments[i];
          i += 1;
        }
        O.length = n + i;
        return n + i;
      };
      var pushIsNotGeneric = function() {
        var obj = {};
        var result = Array.prototype.push.call(obj, void 0);
        return result !== 1 || obj.length !== 1 || typeof obj[0] !== "undefined" || !owns(obj, 0);
      }();
      defineProperties(ArrayPrototype, {
        push: function push(item) {
          if (isArray(this)) {
            return array_push.apply(this, arguments);
          }
          return pushShim.apply(this, arguments);
        }
      }, pushIsNotGeneric);
      var pushUndefinedIsWeird = function() {
        var arr = [];
        var result = arr.push(void 0);
        return result !== 1 || arr.length !== 1 || typeof arr[0] !== "undefined" || !owns(arr, 0);
      }();
      defineProperties(ArrayPrototype, {
        push: pushShim
      }, pushUndefinedIsWeird);
      defineProperties(ArrayPrototype, {
        slice: function(start, end) {
          var arr = isString(this) ? strSplit(this, "") : this;
          return arraySliceApply(arr, arguments);
        }
      }, splitString);
      var sortIgnoresNonFunctions = function() {
        try {
          [1, 2].sort(null);
        } catch (e) {
          try {
            [1, 2].sort({});
          } catch (e2) {
            return false;
          }
        }
        return true;
      }();
      var sortThrowsOnRegex = function() {
        try {
          [1, 2].sort(/a/);
          return false;
        } catch (e) {
        }
        return true;
      }();
      var sortIgnoresUndefined = function() {
        try {
          [1, 2].sort(void 0);
          return true;
        } catch (e) {
        }
        return false;
      }();
      defineProperties(ArrayPrototype, {
        sort: function sort(compareFn) {
          if (typeof compareFn === "undefined") {
            return arraySort(this);
          }
          if (!isCallable(compareFn)) {
            throw new TypeError("Array.prototype.sort callback must be a function");
          }
          return arraySort(this, compareFn);
        }
      }, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);
      var hasDontEnumBug = !isEnum({
        "toString": null
      }, "toString");
      var hasProtoEnumBug = isEnum(function() {
      }, "prototype");
      var hasStringEnumBug = !owns("x", "0");
      var equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true,
        $width: true,
        $height: true,
        $top: true,
        $localStorage: true
      };
      var hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && owns(window, k) && window[k] !== null && typeof window[k] === "object") {
              equalsConstructorPrototype(window[k]);
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      var equalsConstructorPrototypeIfNotBuggy = function(object) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(object);
        }
        try {
          return equalsConstructorPrototype(object);
        } catch (e) {
          return false;
        }
      };
      var dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"];
      var dontEnumsLength = dontEnums.length;
      var isStandardArguments = function isArguments2(value) {
        return toStr(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments2(value) {
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && !isArray(value) && isCallable(value.callee);
      };
      var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;
      defineProperties($Object, {
        keys: function keys(object) {
          var isFn = isCallable(object);
          var isArgs = isArguments(object);
          var isObject = object !== null && typeof object === "object";
          var isStr = isObject && isString(object);
          if (!isObject && !isFn && !isArgs) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var theKeys = [];
          var skipProto = hasProtoEnumBug && isFn;
          if (isStr && hasStringEnumBug || isArgs) {
            for (var i = 0; i < object.length; ++i) {
              pushCall(theKeys, $String(i));
            }
          }
          if (!isArgs) {
            for (var name in object) {
              if (!(skipProto && name === "prototype") && owns(object, name)) {
                pushCall(theKeys, $String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for (var j = 0; j < dontEnumsLength; j++) {
              var dontEnum = dontEnums[j];
              if (!(skipConstructor && dontEnum === "constructor") && owns(object, dontEnum)) {
                pushCall(theKeys, dontEnum);
              }
            }
          }
          return theKeys;
        }
      });
      var keysWorksWithArguments = $Object.keys && function() {
        return $Object.keys(arguments).length === 2;
      }(1, 2);
      var keysHasArgumentsLengthBug = $Object.keys && function() {
        var argKeys = $Object.keys(arguments);
        return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
      }(1);
      var originalKeys = $Object.keys;
      defineProperties($Object, {
        keys: function keys(object) {
          if (isArguments(object)) {
            return originalKeys(arraySlice(object));
          }
          return originalKeys(object);
        }
      }, !keysWorksWithArguments || keysHasArgumentsLengthBug);
      var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
      var aNegativeTestDate = new Date(-1509842289600292);
      var aPositiveTestDate = new Date(14496624e5);
      var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== "Mon, 01 Jan -45875 11:59:59 GMT";
      var hasToDateStringFormatBug;
      var hasToStringFormatBug;
      var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
      if (timeZoneOffset < -720) {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== "Tue Jan 02 -45875";
        hasToStringFormatBug = !/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/.test(String(aPositiveTestDate));
      } else {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== "Mon Jan 01 -45875";
        hasToStringFormatBug = !/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/.test(String(aPositiveTestDate));
      }
      var originalGetFullYear = call.bind(Date.prototype.getFullYear);
      var originalGetMonth = call.bind(Date.prototype.getMonth);
      var originalGetDate = call.bind(Date.prototype.getDate);
      var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
      var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
      var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
      var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
      var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
      var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
      var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
      var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
      var dayName = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      var monthName = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      var daysInMonth = function daysInMonth2(month, year) {
        return originalGetDate(new Date(year, month, 0));
      };
      defineProperties(Date.prototype, {
        getFullYear: function getFullYear() {
          if (!this || !(this instanceof Date)) {
            throw new TypeError("this is not a Date object.");
          }
          var year = originalGetFullYear(this);
          if (year < 0 && originalGetMonth(this) > 11) {
            return year + 1;
          }
          return year;
        },
        getMonth: function getMonth() {
          if (!this || !(this instanceof Date)) {
            throw new TypeError("this is not a Date object.");
          }
          var year = originalGetFullYear(this);
          var month = originalGetMonth(this);
          if (year < 0 && month > 11) {
            return 0;
          }
          return month;
        },
        getDate: function getDate() {
          if (!this || !(this instanceof Date)) {
            throw new TypeError("this is not a Date object.");
          }
          var year = originalGetFullYear(this);
          var month = originalGetMonth(this);
          var date = originalGetDate(this);
          if (year < 0 && month > 11) {
            if (month === 12) {
              return date;
            }
            var days = daysInMonth(0, year + 1);
            return days - date + 1;
          }
          return date;
        },
        getUTCFullYear: function getUTCFullYear() {
          if (!this || !(this instanceof Date)) {
            throw new TypeError("this is not a Date object.");
          }
          var year = originalGetUTCFullYear(this);
          if (year < 0 && originalGetUTCMonth(this) > 11) {
            return year + 1;
          }
          return year;
        },
        getUTCMonth: function getUTCMonth() {
          if (!this || !(this instanceof Date)) {
            throw new TypeError("this is not a Date object.");
          }
          var year = originalGetUTCFullYear(this);
          var month = originalGetUTCMonth(this);
          if (year < 0 && month > 11) {
            return 0;
          }
          return month;
        },
        getUTCDate: function getUTCDate() {
          if (!this || !(this instanceof Date)) {
            throw new TypeError("this is not a Date object.");
          }
          var year = originalGetUTCFullYear(this);
          var month = originalGetUTCMonth(this);
          var date = originalGetUTCDate(this);
          if (year < 0 && month > 11) {
            if (month === 12) {
              return date;
            }
            var days = daysInMonth(0, year + 1);
            return days - date + 1;
          }
          return date;
        }
      }, hasNegativeMonthYearBug);
      defineProperties(Date.prototype, {
        toUTCString: function toUTCString() {
          if (!this || !(this instanceof Date)) {
            throw new TypeError("this is not a Date object.");
          }
          var day = originalGetUTCDay(this);
          var date = originalGetUTCDate(this);
          var month = originalGetUTCMonth(this);
          var year = originalGetUTCFullYear(this);
          var hour = originalGetUTCHours(this);
          var minute = originalGetUTCMinutes(this);
          var second = originalGetUTCSeconds(this);
          return dayName[day] + ", " + (date < 10 ? "0" + date : date) + " " + monthName[month] + " " + year + " " + (hour < 10 ? "0" + hour : hour) + ":" + (minute < 10 ? "0" + minute : minute) + ":" + (second < 10 ? "0" + second : second) + " GMT";
        }
      }, hasNegativeMonthYearBug || hasToUTCStringFormatBug);
      defineProperties(Date.prototype, {
        toDateString: function toDateString() {
          if (!this || !(this instanceof Date)) {
            throw new TypeError("this is not a Date object.");
          }
          var day = this.getDay();
          var date = this.getDate();
          var month = this.getMonth();
          var year = this.getFullYear();
          return dayName[day] + " " + monthName[month] + " " + (date < 10 ? "0" + date : date) + " " + year;
        }
      }, hasNegativeMonthYearBug || hasToDateStringFormatBug);
      if (hasNegativeMonthYearBug || hasToStringFormatBug) {
        Date.prototype.toString = function toString() {
          if (!this || !(this instanceof Date)) {
            throw new TypeError("this is not a Date object.");
          }
          var day = this.getDay();
          var date = this.getDate();
          var month = this.getMonth();
          var year = this.getFullYear();
          var hour = this.getHours();
          var minute = this.getMinutes();
          var second = this.getSeconds();
          var timezoneOffset = this.getTimezoneOffset();
          var hoursOffset = floor(abs(timezoneOffset) / 60);
          var minutesOffset = floor(abs(timezoneOffset) % 60);
          return dayName[day] + " " + monthName[month] + " " + (date < 10 ? "0" + date : date) + " " + year + " " + (hour < 10 ? "0" + hour : hour) + ":" + (minute < 10 ? "0" + minute : minute) + ":" + (second < 10 ? "0" + second : second) + " GMT" + (timezoneOffset > 0 ? "-" : "+") + (hoursOffset < 10 ? "0" + hoursOffset : hoursOffset) + (minutesOffset < 10 ? "0" + minutesOffset : minutesOffset);
        };
        if (supportsDescriptors) {
          $Object.defineProperty(Date.prototype, "toString", {
            configurable: true,
            enumerable: false,
            writable: true
          });
        }
      }
      var negativeDate = -621987552e5;
      var negativeYearString = "-000001";
      var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
      var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== "1969-12-31T23:59:59.999Z";
      var getTime = call.bind(Date.prototype.getTime);
      defineProperties(Date.prototype, {
        toISOString: function toISOString() {
          if (!isFinite(this) || !isFinite(getTime(this))) {
            throw new RangeError("Date.prototype.toISOString called on non-finite value.");
          }
          var year = originalGetUTCFullYear(this);
          var month = originalGetUTCMonth(this);
          year += floor(month / 12);
          month = (month % 12 + 12) % 12;
          var result = [month + 1, originalGetUTCDate(this), originalGetUTCHours(this), originalGetUTCMinutes(this), originalGetUTCSeconds(this)];
          year = (year < 0 ? "-" : year > 9999 ? "+" : "") + strSlice("00000" + abs(year), 0 <= year && year <= 9999 ? -4 : -6);
          for (var i = 0; i < result.length; ++i) {
            result[i] = strSlice("00" + result[i], -2);
          }
          return year + "-" + arraySlice(result, 0, 2).join("-") + "T" + arraySlice(result, 2).join(":") + "." + strSlice("000" + originalGetUTCMilliseconds(this), -3) + "Z";
        }
      }, hasNegativeDateBug || hasSafari51DateBug);
      var dateToJSONIsSupported = function() {
        try {
          return Date.prototype.toJSON && new Date(NaN).toJSON() === null && new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 && Date.prototype.toJSON.call({
            toISOString: function() {
              return true;
            }
          });
        } catch (e) {
          return false;
        }
      }();
      if (!dateToJSONIsSupported) {
        Date.prototype.toJSON = function toJSON(key) {
          var O = $Object(this);
          var tv = ES.ToPrimitive(O);
          if (typeof tv === "number" && !isFinite(tv)) {
            return null;
          }
          var toISO = O.toISOString;
          if (!isCallable(toISO)) {
            throw new TypeError("toISOString property is not callable");
          }
          return toISO.call(O);
        };
      }
      var supportsExtendedYears = Date.parse("+033658-09-27T01:46:40.000Z") === 1e15;
      var acceptsInvalidDates = !isNaN(Date.parse("2012-04-04T24:00:00.500Z")) || !isNaN(Date.parse("2012-11-31T23:59:59.000Z")) || !isNaN(Date.parse("2012-12-31T23:59:60.000Z"));
      var doesNotParseY2KNewYear = isNaN(Date.parse("2000-01-01T00:00:00.000Z"));
      if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
        var maxSafeUnsigned32Bit = pow(2, 31) - 1;
        var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
        Date = function(NativeDate) {
          var DateShim = function Date2(Y, M, D, h, m, s, ms) {
            var length = arguments.length;
            var date;
            if (this instanceof NativeDate) {
              var seconds = s;
              var millis = ms;
              if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
                var msToShift = floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                var sToShift = floor(msToShift / 1e3);
                seconds += sToShift;
                millis -= sToShift * 1e3;
              }
              var parsed = DateShim.parse(Y);
              var hasNegTimestampParseBug = isNaN(parsed);
              date = length === 1 && $String(Y) === Y && !hasNegTimestampParseBug ? new NativeDate(parsed) : length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis) : length >= 6 ? new NativeDate(Y, M, D, h, m, seconds) : length >= 5 ? new NativeDate(Y, M, D, h, m) : length >= 4 ? new NativeDate(Y, M, D, h) : length >= 3 ? new NativeDate(Y, M, D) : length >= 2 ? new NativeDate(Y, M) : length >= 1 ? new NativeDate(Y instanceof NativeDate ? +Y : Y) : new NativeDate();
            } else {
              date = NativeDate.apply(this, arguments);
            }
            if (!isPrimitive(date)) {
              defineProperties(date, {
                constructor: DateShim
              }, true);
            }
            return date;
          };
          var isoDateExpression = new RegExp("^(\\d{4}|[+-]\\d{6})(?:-(\\d{2})(?:-(\\d{2})(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:(\\.\\d{1,}))?)?(Z|(?:([-+])(\\d{2}):(\\d{2})))?)?)?)?$");
          var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
          var dayFromMonth = function dayFromMonth2(year, month) {
            var t = month > 1 ? 1 : 0;
            return months[month] + floor((year - 1969 + t) / 4) - floor((year - 1901 + t) / 100) + floor((year - 1601 + t) / 400) + 365 * (year - 1970);
          };
          var toUTC = function toUTC2(t) {
            var s = 0;
            var ms = t;
            if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
              var msToShift = floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
              var sToShift = floor(msToShift / 1e3);
              s += sToShift;
              ms -= sToShift * 1e3;
            }
            return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
          };
          for (var key in NativeDate) {
            if (owns(NativeDate, key)) {
              DateShim[key] = NativeDate[key];
            }
          }
          defineProperties(DateShim, {
            now: NativeDate.now,
            UTC: NativeDate.UTC
          }, true);
          DateShim.prototype = NativeDate.prototype;
          defineProperties(DateShim.prototype, {
            constructor: DateShim
          }, true);
          var parseShim = function parse(string) {
            var match = isoDateExpression.exec(string);
            if (match) {
              var year = $Number(match[1]), month = $Number(match[2] || 1) - 1, day = $Number(match[3] || 1) - 1, hour = $Number(match[4] || 0), minute = $Number(match[5] || 0), second = $Number(match[6] || 0), millisecond = floor($Number(match[7] || 0) * 1e3), isLocalTime = Boolean(match[4] && !match[8]), signOffset = match[9] === "-" ? 1 : -1, hourOffset = $Number(match[10] || 0), minuteOffset = $Number(match[11] || 0), result;
              var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
              if (hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) && minute < 60 && second < 60 && millisecond < 1e3 && month > -1 && month < 12 && hourOffset < 24 && minuteOffset < 60 && day > -1 && day < dayFromMonth(year, month + 1) - dayFromMonth(year, month)) {
                result = ((dayFromMonth(year, month) + day) * 24 + hour + hourOffset * signOffset) * 60;
                result = ((result + minute + minuteOffset * signOffset) * 60 + second) * 1e3 + millisecond;
                if (isLocalTime) {
                  result = toUTC(result);
                }
                if (-864e13 <= result && result <= 864e13) {
                  return result;
                }
              }
              return NaN;
            }
            return NativeDate.parse.apply(this, arguments);
          };
          defineProperties(DateShim, {
            parse: parseShim
          });
          return DateShim;
        }(Date);
      }
      if (!Date.now) {
        Date.now = function now() {
          return new Date().getTime();
        };
      }
      var hasToFixedBugs = NumberPrototype.toFixed && (8e-5 .toFixed(3) !== "0.000" || 0.9 .toFixed(0) !== "1" || 1.255 .toFixed(2) !== "1.25" || 1000000000000000100 .toFixed(0) !== "1000000000000000128");
      var toFixedHelpers = {
        base: 1e7,
        size: 6,
        data: [0, 0, 0, 0, 0, 0],
        multiply: function multiply(n, c) {
          var i = -1;
          var c2 = c;
          while (++i < toFixedHelpers.size) {
            c2 += n * toFixedHelpers.data[i];
            toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
            c2 = floor(c2 / toFixedHelpers.base);
          }
        },
        divide: function divide(n) {
          var i = toFixedHelpers.size;
          var c = 0;
          while (--i >= 0) {
            c += toFixedHelpers.data[i];
            toFixedHelpers.data[i] = floor(c / n);
            c = c % n * toFixedHelpers.base;
          }
        },
        numToString: function numToString() {
          var i = toFixedHelpers.size;
          var s = "";
          while (--i >= 0) {
            if (s !== "" || i === 0 || toFixedHelpers.data[i] !== 0) {
              var t = $String(toFixedHelpers.data[i]);
              if (s === "") {
                s = t;
              } else {
                s += strSlice("0000000", 0, 7 - t.length) + t;
              }
            }
          }
          return s;
        },
        pow: function pow2(x, n, acc) {
          return n === 0 ? acc : n % 2 === 1 ? pow2(x, n - 1, acc * x) : pow2(x * x, n / 2, acc);
        },
        log: function log2(x) {
          var n = 0;
          var x2 = x;
          while (x2 >= 4096) {
            n += 12;
            x2 /= 4096;
          }
          while (x2 >= 2) {
            n += 1;
            x2 /= 2;
          }
          return n;
        }
      };
      var toFixedShim = function toFixed(fractionDigits) {
        var f, x, s, m, e, z, j, k;
        f = $Number(fractionDigits);
        f = isActualNaN(f) ? 0 : floor(f);
        if (f < 0 || f > 20) {
          throw new RangeError("Number.toFixed called with invalid number of decimals");
        }
        x = $Number(this);
        if (isActualNaN(x)) {
          return "NaN";
        }
        if (x <= -1e21 || x >= 1e21) {
          return $String(x);
        }
        s = "";
        if (x < 0) {
          s = "-";
          x = -x;
        }
        m = "0";
        if (x > 1e-21) {
          e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
          z = e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1);
          z *= 4503599627370496;
          e = 52 - e;
          if (e > 0) {
            toFixedHelpers.multiply(0, z);
            j = f;
            while (j >= 7) {
              toFixedHelpers.multiply(1e7, 0);
              j -= 7;
            }
            toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
            j = e - 1;
            while (j >= 23) {
              toFixedHelpers.divide(1 << 23);
              j -= 23;
            }
            toFixedHelpers.divide(1 << j);
            toFixedHelpers.multiply(1, 1);
            toFixedHelpers.divide(2);
            m = toFixedHelpers.numToString();
          } else {
            toFixedHelpers.multiply(0, z);
            toFixedHelpers.multiply(1 << -e, 0);
            m = toFixedHelpers.numToString() + strSlice("0.00000000000000000000", 2, 2 + f);
          }
        }
        if (f > 0) {
          k = m.length;
          if (k <= f) {
            m = s + strSlice("0.0000000000000000000", 0, f - k + 2) + m;
          } else {
            m = s + strSlice(m, 0, k - f) + "." + strSlice(m, k - f);
          }
        } else {
          m = s + m;
        }
        return m;
      };
      defineProperties(NumberPrototype, {
        toFixed: toFixedShim
      }, hasToFixedBugs);
      var hasToExponentialRoundingBug = function() {
        try {
          return (-69e-12).toExponential(4) !== "-6.9000e-11";
        } catch (e) {
          return false;
        }
      }();
      var toExponentialAllowsInfiniteDigits = function() {
        try {
          1 .toExponential(Infinity);
          1 .toExponential(-Infinity);
          return true;
        } catch (e) {
          return false;
        }
      }();
      var originalToExponential = call.bind(NumberPrototype.toExponential);
      var numberToString = call.bind(NumberPrototype.toString);
      var numberValueOf = call.bind(NumberPrototype.valueOf);
      defineProperties(NumberPrototype, {
        toExponential: function toExponential(fractionDigits) {
          var x = numberValueOf(this);
          if (typeof fractionDigits === "undefined") {
            return originalToExponential(x);
          }
          var f = ES.ToInteger(fractionDigits);
          if (isActualNaN(x)) {
            return "NaN";
          }
          if (f < 0 || f > 20) {
            if (!isFinite(f)) {
              throw new RangeError("toExponential() argument must be between 0 and 20");
            }
            return originalToExponential(x, f);
          }
          var s = "";
          if (x < 0) {
            s = "-";
            x = -x;
          }
          if (x === Infinity) {
            return s + "Infinity";
          }
          if (typeof fractionDigits !== "undefined" && (f < 0 || f > 20)) {
            throw new RangeError("Fraction digits " + fractionDigits + " out of range");
          }
          var m = "";
          var e = 0;
          var c = "";
          var d = "";
          if (x === 0) {
            e = 0;
            f = 0;
            m = "0";
          } else {
            var L = log10(x);
            e = floor(L);
            var n = 0;
            if (typeof fractionDigits !== "undefined") {
              var w = pow(10, e - f);
              n = round(x / w);
              if (2 * x >= (2 * n + 1) * w) {
                n += 1;
              }
              if (n >= pow(10, f + 1)) {
                n /= 10;
                e += 1;
              }
            } else {
              f = 16;
              var guess_n = round(pow(10, L - e + f));
              var target_f = f;
              while (f-- > 0) {
                guess_n = round(pow(10, L - e + f));
                if (abs(guess_n * pow(10, e - f) - x) <= abs(n * pow(10, e - target_f) - x)) {
                  target_f = f;
                  n = guess_n;
                }
              }
            }
            m = numberToString(n, 10);
            if (typeof fractionDigits === "undefined") {
              while (strSlice(m, -1) === "0") {
                m = strSlice(m, 0, -1);
                d += 1;
              }
            }
          }
          if (f !== 0) {
            m = strSlice(m, 0, 1) + "." + strSlice(m, 1);
          }
          if (e === 0) {
            c = "+";
            d = "0";
          } else {
            c = e > 0 ? "+" : "-";
            d = numberToString(abs(e), 10);
          }
          m += "e" + c + d;
          return s + m;
        }
      }, hasToExponentialRoundingBug || toExponentialAllowsInfiniteDigits);
      var hasToPrecisionUndefinedBug = function() {
        try {
          return 1 .toPrecision(void 0) === "1";
        } catch (e) {
          return true;
        }
      }();
      var originalToPrecision = call.bind(NumberPrototype.toPrecision);
      defineProperties(NumberPrototype, {
        toPrecision: function toPrecision(precision) {
          return typeof precision === "undefined" ? originalToPrecision(this) : originalToPrecision(this, precision);
        }
      }, hasToPrecisionUndefinedBug);
      if ("ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || "tesst".split(/(s)*/)[1] === "t" || "test".split(/(?:)/, -1).length !== 4 || "".split(/.?/).length || ".".split(/()()/).length > 1) {
        (function() {
          var compliantExecNpcg = typeof /()??/.exec("")[1] === "undefined";
          var maxSafe32BitInt = pow(2, 32) - 1;
          StringPrototype.split = function split(separator, limit) {
            var string = String(this);
            if (typeof separator === "undefined" && limit === 0) {
              return [];
            }
            if (!isRegex(separator)) {
              return strSplit(this, separator, limit);
            }
            var output = [];
            var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : ""), lastLastIndex = 0, separator2, match, lastIndex, lastLength;
            var separatorCopy = new RegExp(separator.source, flags + "g");
            if (!compliantExecNpcg) {
              separator2 = new RegExp("^" + separatorCopy.source + "$(?!\\s)", flags);
            }
            var splitLimit = typeof limit === "undefined" ? maxSafe32BitInt : ES.ToUint32(limit);
            match = separatorCopy.exec(string);
            while (match) {
              lastIndex = match.index + match[0].length;
              if (lastIndex > lastLastIndex) {
                pushCall(output, strSlice(string, lastLastIndex, match.index));
                if (!compliantExecNpcg && match.length > 1) {
                  match[0].replace(separator2, function() {
                    for (var i = 1; i < arguments.length - 2; i++) {
                      if (typeof arguments[i] === "undefined") {
                        match[i] = void 0;
                      }
                    }
                  });
                }
                if (match.length > 1 && match.index < string.length) {
                  array_push.apply(output, arraySlice(match, 1));
                }
                lastLength = match[0].length;
                lastLastIndex = lastIndex;
                if (output.length >= splitLimit) {
                  break;
                }
              }
              if (separatorCopy.lastIndex === match.index) {
                separatorCopy.lastIndex++;
              }
              match = separatorCopy.exec(string);
            }
            if (lastLastIndex === string.length) {
              if (lastLength || !separatorCopy.test("")) {
                pushCall(output, "");
              }
            } else {
              pushCall(output, strSlice(string, lastLastIndex));
            }
            return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
          };
        })();
      } else if ("0".split(void 0, 0).length) {
        StringPrototype.split = function split(separator, limit) {
          if (typeof separator === "undefined" && limit === 0) {
            return [];
          }
          return strSplit(this, separator, limit);
        };
      }
      var str_replace = StringPrototype.replace;
      var replaceReportsGroupsCorrectly = function() {
        var groups = [];
        "x".replace(/x(.)?/g, function(match, group) {
          pushCall(groups, group);
        });
        return groups.length === 1 && typeof groups[0] === "undefined";
      }();
      if (!replaceReportsGroupsCorrectly) {
        StringPrototype.replace = function replace(searchValue, replaceValue) {
          var isFn = isCallable(replaceValue);
          var hasCapturingGroups = isRegex(searchValue) && /\)[*?]/.test(searchValue.source);
          if (!isFn || !hasCapturingGroups) {
            return str_replace.call(this, searchValue, replaceValue);
          }
          var wrappedReplaceValue = function(match) {
            var length = arguments.length;
            var originalLastIndex = searchValue.lastIndex;
            searchValue.lastIndex = 0;
            var args = searchValue.exec(match) || [];
            searchValue.lastIndex = originalLastIndex;
            pushCall(args, arguments[length - 2], arguments[length - 1]);
            return replaceValue.apply(this, args);
          };
          return str_replace.call(this, searchValue, wrappedReplaceValue);
        };
      }
      var hasNegativeSubstrBug = "".substr && "0b".substr(-1) !== "b";
      var string_substr = hasNegativeSubstrBug && call.bind(StringPrototype.substr);
      defineProperties(StringPrototype, {
        substr: function substr(start, length) {
          var normalizedStart = start;
          if (start < 0) {
            normalizedStart = max(this.length + start, 0);
          }
          return string_substr(this, normalizedStart, length);
        }
      }, hasNegativeSubstrBug);
      var mvs = "\u180E";
      var mvsIsWS = /\s/.test(mvs);
      var ws = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF".replace(/\S/g, "");
      var zeroWidth = "\u200B";
      var wsRegexChars = "[" + ws + "]";
      var trimBeginRegexp = new RegExp("^" + wsRegexChars + wsRegexChars + "*");
      var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + "*$");
      var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() !== "" || zeroWidth.trim() === "" || mvs.trim() !== (mvsIsWS ? "" : mvs));
      defineProperties(StringPrototype, {
        trim: function trim2() {
          "use strict";
          if (typeof this === "undefined" || this === null) {
            throw new TypeError("can't convert " + this + " to object");
          }
          return $String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
        }
      }, hasTrimWhitespaceBug);
      var trim = call.bind(String.prototype.trim);
      var hasLastIndexBug = StringPrototype.lastIndexOf && "abc\u3042\u3044".lastIndexOf("\u3042\u3044", 2) !== -1;
      defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
          if (typeof this === "undefined" || this === null) {
            throw new TypeError("can't convert " + this + " to object");
          }
          var S = $String(this);
          var searchStr = $String(searchString);
          var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
          var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
          var start = min(max(pos, 0), S.length);
          var searchLen = searchStr.length;
          var k = start + searchLen;
          while (k > 0) {
            k = max(0, k - searchLen);
            var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
            if (index !== -1) {
              return k + index;
            }
          }
          return -1;
        }
      }, hasLastIndexBug);
      var originalLastIndexOf = StringPrototype.lastIndexOf;
      defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
          return originalLastIndexOf.apply(this, arguments);
        }
      }, StringPrototype.lastIndexOf.length !== 1);
      var hexRegex = /^[-+]?0[xX]/;
      if (parseInt(ws + "08") !== 8 || parseInt(ws + "0x16") !== 22 || (mvsIsWS ? parseInt(mvs + 1) !== 1 : !isNaN(parseInt(mvs + 1)))) {
        parseInt = function(origParseInt) {
          return function parseInt2(str, radix) {
            if (this instanceof parseInt2) {
              new origParseInt();
            }
            var string = trim(String(str));
            var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
            return origParseInt(string, defaultedRadix);
          };
        }(parseInt);
      }
      var parseIntFailsToThrowOnBoxedSymbols = function() {
        if (typeof Symbol !== "function") {
          return false;
        }
        try {
          parseInt(Object(Symbol.iterator));
          return true;
        } catch (e) {
        }
        try {
          parseInt(Symbol.iterator);
          return true;
        } catch (e) {
        }
        return false;
      }();
      if (parseIntFailsToThrowOnBoxedSymbols) {
        var symbolValueOf = Symbol.prototype.valueOf;
        parseInt = function(origParseInt) {
          return function parseInt2(str, radix) {
            if (this instanceof parseInt2) {
              new origParseInt();
            }
            var isSym = typeof str === "symbol";
            if (!isSym && str && typeof str === "object") {
              try {
                symbolValueOf.call(str);
                isSym = true;
              } catch (e) {
              }
            }
            if (isSym) {
              "" + str;
            }
            var string = trim(String(str));
            var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
            return origParseInt(string, defaultedRadix);
          };
        }(parseInt);
      }
      if (1 / parseFloat("-0") !== -Infinity) {
        parseFloat = function(origParseFloat) {
          return function parseFloat2(string) {
            var inputString = trim(String(string));
            var result = origParseFloat(inputString);
            return result === 0 && strSlice(inputString, 0, 1) === "-" ? -0 : result;
          };
        }(parseFloat);
      }
      if (String(new RangeError("test")) !== "RangeError: test") {
        var errorToStringShim = function toString() {
          if (typeof this === "undefined" || this === null) {
            throw new TypeError("can't convert " + this + " to object");
          }
          var name = this.name;
          if (typeof name === "undefined") {
            name = "Error";
          } else if (typeof name !== "string") {
            name = $String(name);
          }
          var msg = this.message;
          if (typeof msg === "undefined") {
            msg = "";
          } else if (typeof msg !== "string") {
            msg = $String(msg);
          }
          if (!name) {
            return msg;
          }
          if (!msg) {
            return name;
          }
          return name + ": " + msg;
        };
        Error.prototype.toString = errorToStringShim;
      }
      if (supportsDescriptors) {
        var ensureNonEnumerable = function(obj, prop) {
          if (isEnum(obj, prop)) {
            var desc = Object.getOwnPropertyDescriptor(obj, prop);
            if (desc.configurable) {
              desc.enumerable = false;
              Object.defineProperty(obj, prop, desc);
            }
          }
        };
        ensureNonEnumerable(Error.prototype, "message");
        if (Error.prototype.message !== "") {
          Error.prototype.message = "";
        }
        ensureNonEnumerable(Error.prototype, "name");
      }
      if (String(/a/mig) !== "/a/gim") {
        var regexToString = function toString() {
          var str = "/" + this.source + "/";
          if (this.global) {
            str += "g";
          }
          if (this.ignoreCase) {
            str += "i";
          }
          if (this.multiline) {
            str += "m";
          }
          return str;
        };
        RegExp.prototype.toString = regexToString;
      }
    });
  }
});

// node_modules/es5-shim/es5-sham.js
var require_es5_sham = __commonJS({
  "node_modules/es5-shim/es5-sham.js"(exports, module) {
    init_define_ngDevMode();
    (function(root, factory) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.returnExports = factory();
      }
    })(exports, function() {
      var call = Function.call;
      var prototypeOfObject = Object.prototype;
      var owns = call.bind(prototypeOfObject.hasOwnProperty);
      var isEnumerable = call.bind(prototypeOfObject.propertyIsEnumerable);
      var toStr = call.bind(prototypeOfObject.toString);
      var defineGetter;
      var defineSetter;
      var lookupGetter;
      var lookupSetter;
      var supportsAccessors = owns(prototypeOfObject, "__defineGetter__");
      if (supportsAccessors) {
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
      }
      var isPrimitive = function isPrimitive2(o) {
        return o == null || typeof o !== "object" && typeof o !== "function";
      };
      if (!Object.getPrototypeOf) {
        Object.getPrototypeOf = function getPrototypeOf(object) {
          var proto = object.__proto__;
          if (proto || proto == null) {
            return proto;
          } else if (toStr(object.constructor) === "[object Function]") {
            return object.constructor.prototype;
          } else if (object instanceof Object) {
            return prototypeOfObject;
          }
          return null;
        };
      }
      if (Object.defineProperty) {
        var doesGetOwnPropertyDescriptorWork = function doesGetOwnPropertyDescriptorWork2(object) {
          try {
            object.sentinel = 0;
            return Object.getOwnPropertyDescriptor(object, "sentinel").value === 0;
          } catch (exception) {
            return false;
          }
        };
        var getOwnPropertyDescriptorWorksOnObject = doesGetOwnPropertyDescriptorWork({});
        var getOwnPropertyDescriptorWorksOnDom = typeof document === "undefined" || doesGetOwnPropertyDescriptorWork(document.createElement("div"));
        if (!getOwnPropertyDescriptorWorksOnDom || !getOwnPropertyDescriptorWorksOnObject) {
          var getOwnPropertyDescriptorFallback = Object.getOwnPropertyDescriptor;
        }
      }
      if (!Object.getOwnPropertyDescriptor || getOwnPropertyDescriptorFallback) {
        var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a non-object: ";
        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
          if (isPrimitive(object)) {
            throw new TypeError(ERR_NON_OBJECT + object);
          }
          if (getOwnPropertyDescriptorFallback) {
            try {
              return getOwnPropertyDescriptorFallback.call(Object, object, property);
            } catch (exception) {
            }
          }
          var descriptor;
          if (!owns(object, property)) {
            return descriptor;
          }
          descriptor = {
            enumerable: isEnumerable(object, property),
            configurable: true
          };
          if (supportsAccessors) {
            var prototype = object.__proto__;
            var notPrototypeOfObject = object !== prototypeOfObject;
            if (notPrototypeOfObject) {
              object.__proto__ = prototypeOfObject;
            }
            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            if (notPrototypeOfObject) {
              object.__proto__ = prototype;
            }
            if (getter || setter) {
              if (getter) {
                descriptor.get = getter;
              }
              if (setter) {
                descriptor.set = setter;
              }
              return descriptor;
            }
          }
          descriptor.value = object[property];
          descriptor.writable = true;
          return descriptor;
        };
      }
      if (!Object.getOwnPropertyNames) {
        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
          return Object.keys(object);
        };
      }
      if (!Object.create) {
        var createEmpty;
        var supportsProto = !({
          __proto__: null
        } instanceof Object);
        var shouldUseActiveX = function shouldUseActiveX2() {
          if (!document.domain) {
            return false;
          }
          try {
            return !!new ActiveXObject("htmlfile");
          } catch (exception) {
            return false;
          }
        };
        var getEmptyViaActiveX = function getEmptyViaActiveX2() {
          var empty;
          var xDoc;
          xDoc = new ActiveXObject("htmlfile");
          var script = "script";
          xDoc.write("<" + script + "></" + script + ">");
          xDoc.close();
          empty = xDoc.parentWindow.Object.prototype;
          xDoc = null;
          return empty;
        };
        var getEmptyViaIFrame = function getEmptyViaIFrame2() {
          var iframe = document.createElement("iframe");
          var parent = document.body || document.documentElement;
          var empty;
          iframe.style.display = "none";
          parent.appendChild(iframe);
          iframe.src = "javascript:";
          empty = iframe.contentWindow.Object.prototype;
          parent.removeChild(iframe);
          iframe = null;
          return empty;
        };
        if (supportsProto || typeof document === "undefined") {
          createEmpty = function() {
            return {
              __proto__: null
            };
          };
        } else {
          createEmpty = function() {
            var empty = shouldUseActiveX() ? getEmptyViaActiveX() : getEmptyViaIFrame();
            delete empty.constructor;
            delete empty.hasOwnProperty;
            delete empty.propertyIsEnumerable;
            delete empty.isPrototypeOf;
            delete empty.toLocaleString;
            delete empty.toString;
            delete empty.valueOf;
            var Empty = function Empty2() {
            };
            Empty.prototype = empty;
            createEmpty = function() {
              return new Empty();
            };
            return new Empty();
          };
        }
        Object.create = function create(prototype, properties) {
          var object;
          var Type = function Type2() {
          };
          if (prototype === null) {
            object = createEmpty();
          } else if (isPrimitive(prototype)) {
            throw new TypeError("Object prototype may only be an Object or null");
          } else {
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
          }
          if (properties !== void 0) {
            Object.defineProperties(object, properties);
          }
          return object;
        };
      }
      var doesDefinePropertyWork = function doesDefinePropertyWork2(object) {
        try {
          Object.defineProperty(object, "sentinel", {});
          return "sentinel" in object;
        } catch (exception) {
          return false;
        }
      };
      if (Object.defineProperty) {
        var definePropertyWorksOnObject = doesDefinePropertyWork({});
        var definePropertyWorksOnDom = typeof document === "undefined" || doesDefinePropertyWork(document.createElement("div"));
        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
          var definePropertyFallback = Object.defineProperty, definePropertiesFallback = Object.defineProperties;
        }
      }
      if (!Object.defineProperty || definePropertyFallback) {
        var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
        var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
        var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined on this javascript engine";
        Object.defineProperty = function defineProperty(object, property, descriptor) {
          if (isPrimitive(object)) {
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
          }
          if (isPrimitive(descriptor)) {
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
          }
          if (definePropertyFallback) {
            try {
              return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {
            }
          }
          if ("value" in descriptor) {
            if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
              var prototype = object.__proto__;
              object.__proto__ = prototypeOfObject;
              delete object[property];
              object[property] = descriptor.value;
              object.__proto__ = prototype;
            } else {
              object[property] = descriptor.value;
            }
          } else {
            var hasGetter = "get" in descriptor;
            var hasSetter = "set" in descriptor;
            if (!supportsAccessors && (hasGetter || hasSetter)) {
              throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            }
            if (hasGetter) {
              defineGetter(object, property, descriptor.get);
            }
            if (hasSetter) {
              defineSetter(object, property, descriptor.set);
            }
          }
          return object;
        };
      }
      if (!Object.defineProperties || definePropertiesFallback) {
        Object.defineProperties = function defineProperties(object, properties) {
          if (definePropertiesFallback) {
            try {
              return definePropertiesFallback.call(Object, object, properties);
            } catch (exception) {
            }
          }
          Object.keys(properties).forEach(function(property) {
            if (property !== "__proto__") {
              Object.defineProperty(object, property, properties[property]);
            }
          });
          return object;
        };
      }
      if (!Object.seal) {
        Object.seal = function seal(object) {
          if (Object(object) !== object) {
            throw new TypeError("Object.seal can only be called on Objects.");
          }
          return object;
        };
      }
      if (!Object.freeze) {
        Object.freeze = function freeze(object) {
          if (Object(object) !== object) {
            throw new TypeError("Object.freeze can only be called on Objects.");
          }
          return object;
        };
      }
      try {
        Object.freeze(function() {
        });
      } catch (exception) {
        Object.freeze = function(freezeObject) {
          return function freeze(object) {
            if (typeof object === "function") {
              return object;
            }
            return freezeObject(object);
          };
        }(Object.freeze);
      }
      if (!Object.preventExtensions) {
        Object.preventExtensions = function preventExtensions(object) {
          if (Object(object) !== object) {
            throw new TypeError("Object.preventExtensions can only be called on Objects.");
          }
          return object;
        };
      }
      if (!Object.isSealed) {
        Object.isSealed = function isSealed(object) {
          if (Object(object) !== object) {
            throw new TypeError("Object.isSealed can only be called on Objects.");
          }
          return false;
        };
      }
      if (!Object.isFrozen) {
        Object.isFrozen = function isFrozen(object) {
          if (Object(object) !== object) {
            throw new TypeError("Object.isFrozen can only be called on Objects.");
          }
          return false;
        };
      }
      if (!Object.isExtensible) {
        Object.isExtensible = function isExtensible(object) {
          if (Object(object) !== object) {
            throw new TypeError("Object.isExtensible can only be called on Objects.");
          }
          var name = "";
          while (owns(object, name)) {
            name += "?";
          }
          object[name] = true;
          var returnValue = owns(object, name);
          delete object[name];
          return returnValue;
        };
      }
    });
  }
});

// node_modules/es6-shim/es6-shim.js
var require_es6_shim = __commonJS({
  "node_modules/es6-shim/es6-shim.js"(exports, module) {
    init_define_ngDevMode();
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.returnExports = factory();
      }
    })(exports, function() {
      "use strict";
      var _apply = Function.call.bind(Function.apply);
      var _call = Function.call.bind(Function.call);
      var isArray = Array.isArray;
      var keys = Object.keys;
      var not = function notThunker(func) {
        return function notThunk() {
          return !_apply(func, this, arguments);
        };
      };
      var throwsError = function(func) {
        try {
          func();
          return false;
        } catch (e) {
          return true;
        }
      };
      var valueOrFalseIfThrows = function valueOrFalseIfThrows2(func) {
        try {
          return func();
        } catch (e) {
          return false;
        }
      };
      var isCallableWithoutNew = not(throwsError);
      var arePropertyDescriptorsSupported = function() {
        return !throwsError(function() {
          return Object.defineProperty({}, "x", {
            get: function() {
            }
          });
        });
      };
      var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();
      var functionsHaveNames = function foo() {
      }.name === "foo";
      var _forEach = Function.call.bind(Array.prototype.forEach);
      var _reduce = Function.call.bind(Array.prototype.reduce);
      var _filter = Function.call.bind(Array.prototype.filter);
      var _some = Function.call.bind(Array.prototype.some);
      var defineProperty = function(object, name, value, force) {
        if (!force && name in object) {
          return;
        }
        if (supportsDescriptors) {
          Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value
          });
        } else {
          object[name] = value;
        }
      };
      var defineProperties = function(object, map, forceOverride) {
        _forEach(keys(map), function(name) {
          var method = map[name];
          defineProperty(object, name, method, !!forceOverride);
        });
      };
      var _toString = Function.call.bind(Object.prototype.toString);
      var isCallable = typeof /abc/ === "function" ? function IsCallableSlow(x) {
        return typeof x === "function" && _toString(x) === "[object Function]";
      } : function IsCallableFast(x) {
        return typeof x === "function";
      };
      var Value = {
        getter: function(object, name, getter) {
          if (!supportsDescriptors) {
            throw new TypeError("getters require true ES5 support");
          }
          Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            get: getter
          });
        },
        proxy: function(originalObject, key, targetObject) {
          if (!supportsDescriptors) {
            throw new TypeError("getters require true ES5 support");
          }
          var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);
          Object.defineProperty(targetObject, key, {
            configurable: originalDescriptor.configurable,
            enumerable: originalDescriptor.enumerable,
            get: function getKey() {
              return originalObject[key];
            },
            set: function setKey(value) {
              originalObject[key] = value;
            }
          });
        },
        redefine: function(object, property, newValue) {
          if (supportsDescriptors) {
            var descriptor = Object.getOwnPropertyDescriptor(object, property);
            descriptor.value = newValue;
            Object.defineProperty(object, property, descriptor);
          } else {
            object[property] = newValue;
          }
        },
        defineByDescriptor: function(object, property, descriptor) {
          if (supportsDescriptors) {
            Object.defineProperty(object, property, descriptor);
          } else if ("value" in descriptor) {
            object[property] = descriptor.value;
          }
        },
        preserveToString: function(target, source) {
          if (source && isCallable(source.toString)) {
            defineProperty(target, "toString", source.toString.bind(source), true);
          }
        }
      };
      var create = Object.create || function(prototype, properties) {
        var Prototype = function Prototype2() {
        };
        Prototype.prototype = prototype;
        var object = new Prototype();
        if (typeof properties !== "undefined") {
          keys(properties).forEach(function(key) {
            Value.defineByDescriptor(object, key, properties[key]);
          });
        }
        return object;
      };
      var supportsSubclassing = function(C, f) {
        if (!Object.setPrototypeOf) {
          return false;
        }
        return valueOrFalseIfThrows(function() {
          var Sub = function Subclass(arg) {
            var o = new C(arg);
            Object.setPrototypeOf(o, Subclass.prototype);
            return o;
          };
          Object.setPrototypeOf(Sub, C);
          Sub.prototype = create(C.prototype, {
            constructor: {
              value: Sub
            }
          });
          return f(Sub);
        });
      };
      var getGlobal = function() {
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw new Error("unable to locate global object");
      };
      var globals = getGlobal();
      var globalIsFinite = globals.isFinite;
      var _indexOf = Function.call.bind(String.prototype.indexOf);
      var _arrayIndexOfApply = Function.apply.bind(Array.prototype.indexOf);
      var _concat = Function.call.bind(Array.prototype.concat);
      var _strSlice = Function.call.bind(String.prototype.slice);
      var _push = Function.call.bind(Array.prototype.push);
      var _pushApply = Function.apply.bind(Array.prototype.push);
      var _join = Function.call.bind(Array.prototype.join);
      var _shift = Function.call.bind(Array.prototype.shift);
      var _max = Math.max;
      var _min = Math.min;
      var _floor = Math.floor;
      var _abs = Math.abs;
      var _exp = Math.exp;
      var _log = Math.log;
      var _sqrt = Math.sqrt;
      var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      var ArrayIterator;
      var noop = function() {
      };
      var OrigMap = globals.Map;
      var origMapDelete = OrigMap && OrigMap.prototype["delete"];
      var origMapGet = OrigMap && OrigMap.prototype.get;
      var origMapHas = OrigMap && OrigMap.prototype.has;
      var origMapSet = OrigMap && OrigMap.prototype.set;
      var Symbol2 = globals.Symbol || {};
      var symbolSpecies = Symbol2.species || "@@species";
      var numberIsNaN = Number.isNaN || function isNaN2(value) {
        return value !== value;
      };
      var numberIsFinite = Number.isFinite || function isFinite2(value) {
        return typeof value === "number" && globalIsFinite(value);
      };
      var _sign = isCallable(Math.sign) ? Math.sign : function sign(value) {
        var number = Number(value);
        if (number === 0) {
          return number;
        }
        if (numberIsNaN(number)) {
          return number;
        }
        return number < 0 ? -1 : 1;
      };
      var _log1p = function log1p(value) {
        var x = Number(value);
        if (x < -1 || numberIsNaN(x)) {
          return NaN;
        }
        if (x === 0 || x === Infinity) {
          return x;
        }
        if (x === -1) {
          return -Infinity;
        }
        return 1 + x - 1 === 0 ? x : x * (_log(1 + x) / (1 + x - 1));
      };
      var isStandardArguments = function isArguments2(value) {
        return _toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments2(value) {
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && _toString(value) !== "[object Array]" && _toString(value.callee) === "[object Function]";
      };
      var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;
      var Type = {
        primitive: function(x) {
          return x === null || typeof x !== "function" && typeof x !== "object";
        },
        string: function(x) {
          return _toString(x) === "[object String]";
        },
        regex: function(x) {
          return _toString(x) === "[object RegExp]";
        },
        symbol: function(x) {
          return typeof globals.Symbol === "function" && typeof x === "symbol";
        }
      };
      var overrideNative = function overrideNative2(object, property, replacement) {
        var original = object[property];
        defineProperty(object, property, replacement, true);
        Value.preserveToString(object[property], original);
      };
      var hasSymbols = typeof Symbol2 === "function" && typeof Symbol2["for"] === "function" && Type.symbol(Symbol2());
      var $iterator$ = Type.symbol(Symbol2.iterator) ? Symbol2.iterator : "_es6-shim iterator_";
      if (globals.Set && typeof new globals.Set()["@@iterator"] === "function") {
        $iterator$ = "@@iterator";
      }
      if (!globals.Reflect) {
        defineProperty(globals, "Reflect", {}, true);
      }
      var Reflect2 = globals.Reflect;
      var $String = String;
      var domAll = typeof document === "undefined" || !document ? null : document.all;
      var isNullOrUndefined = domAll == null ? function isNullOrUndefined2(x) {
        return x == null;
      } : function isNullOrUndefinedAndNotDocumentAll(x) {
        return x == null && x !== domAll;
      };
      var ES = {
        Call: function Call(F, V) {
          var args = arguments.length > 2 ? arguments[2] : [];
          if (!ES.IsCallable(F)) {
            throw new TypeError(F + " is not a function");
          }
          return _apply(F, V, args);
        },
        RequireObjectCoercible: function(x, optMessage) {
          if (isNullOrUndefined(x)) {
            throw new TypeError(optMessage || "Cannot call method on " + x);
          }
          return x;
        },
        TypeIsObject: function(x) {
          if (x === void 0 || x === null || x === true || x === false) {
            return false;
          }
          return typeof x === "function" || typeof x === "object" || x === domAll;
        },
        ToObject: function(o, optMessage) {
          return Object(ES.RequireObjectCoercible(o, optMessage));
        },
        IsCallable: isCallable,
        IsConstructor: function(x) {
          return ES.IsCallable(x);
        },
        ToInt32: function(x) {
          return ES.ToNumber(x) >> 0;
        },
        ToUint32: function(x) {
          return ES.ToNumber(x) >>> 0;
        },
        ToNumber: function(value) {
          if (hasSymbols && _toString(value) === "[object Symbol]") {
            throw new TypeError("Cannot convert a Symbol value to a number");
          }
          return +value;
        },
        ToInteger: function(value) {
          var number = ES.ToNumber(value);
          if (numberIsNaN(number)) {
            return 0;
          }
          if (number === 0 || !numberIsFinite(number)) {
            return number;
          }
          return (number > 0 ? 1 : -1) * _floor(_abs(number));
        },
        ToLength: function(value) {
          var len = ES.ToInteger(value);
          if (len <= 0) {
            return 0;
          }
          if (len > Number.MAX_SAFE_INTEGER) {
            return Number.MAX_SAFE_INTEGER;
          }
          return len;
        },
        SameValue: function(a, b) {
          if (a === b) {
            if (a === 0) {
              return 1 / a === 1 / b;
            }
            return true;
          }
          return numberIsNaN(a) && numberIsNaN(b);
        },
        SameValueZero: function(a, b) {
          return a === b || numberIsNaN(a) && numberIsNaN(b);
        },
        IsIterable: function(o) {
          return ES.TypeIsObject(o) && (typeof o[$iterator$] !== "undefined" || isArguments(o));
        },
        GetIterator: function(o) {
          if (isArguments(o)) {
            return new ArrayIterator(o, "value");
          }
          var itFn = ES.GetMethod(o, $iterator$);
          if (!ES.IsCallable(itFn)) {
            throw new TypeError("value is not an iterable");
          }
          var it = ES.Call(itFn, o);
          if (!ES.TypeIsObject(it)) {
            throw new TypeError("bad iterator");
          }
          return it;
        },
        GetMethod: function(o, p) {
          var func = ES.ToObject(o)[p];
          if (isNullOrUndefined(func)) {
            return void 0;
          }
          if (!ES.IsCallable(func)) {
            throw new TypeError("Method not callable: " + p);
          }
          return func;
        },
        IteratorComplete: function(iterResult) {
          return !!iterResult.done;
        },
        IteratorClose: function(iterator, completionIsThrow) {
          var returnMethod = ES.GetMethod(iterator, "return");
          if (returnMethod === void 0) {
            return;
          }
          var innerResult, innerException;
          try {
            innerResult = ES.Call(returnMethod, iterator);
          } catch (e) {
            innerException = e;
          }
          if (completionIsThrow) {
            return;
          }
          if (innerException) {
            throw innerException;
          }
          if (!ES.TypeIsObject(innerResult)) {
            throw new TypeError("Iterator's return method returned a non-object.");
          }
        },
        IteratorNext: function(it) {
          var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();
          if (!ES.TypeIsObject(result)) {
            throw new TypeError("bad iterator");
          }
          return result;
        },
        IteratorStep: function(it) {
          var result = ES.IteratorNext(it);
          var done = ES.IteratorComplete(result);
          return done ? false : result;
        },
        Construct: function(C, args, newTarget, isES6internal) {
          var target = typeof newTarget === "undefined" ? C : newTarget;
          if (!isES6internal && Reflect2.construct) {
            return Reflect2.construct(C, args, target);
          }
          var proto = target.prototype;
          if (!ES.TypeIsObject(proto)) {
            proto = Object.prototype;
          }
          var obj = create(proto);
          var result = ES.Call(C, obj, args);
          return ES.TypeIsObject(result) ? result : obj;
        },
        SpeciesConstructor: function(O, defaultConstructor) {
          var C = O.constructor;
          if (C === void 0) {
            return defaultConstructor;
          }
          if (!ES.TypeIsObject(C)) {
            throw new TypeError("Bad constructor");
          }
          var S = C[symbolSpecies];
          if (isNullOrUndefined(S)) {
            return defaultConstructor;
          }
          if (!ES.IsConstructor(S)) {
            throw new TypeError("Bad @@species");
          }
          return S;
        },
        CreateHTML: function(string, tag, attribute, value) {
          var S = ES.ToString(string);
          var p1 = "<" + tag;
          if (attribute !== "") {
            var V = ES.ToString(value);
            var escapedV = V.replace(/"/g, "&quot;");
            p1 += " " + attribute + '="' + escapedV + '"';
          }
          var p2 = p1 + ">";
          var p3 = p2 + S;
          return p3 + "</" + tag + ">";
        },
        IsRegExp: function IsRegExp(argument) {
          if (!ES.TypeIsObject(argument)) {
            return false;
          }
          var isRegExp = argument[Symbol2.match];
          if (typeof isRegExp !== "undefined") {
            return !!isRegExp;
          }
          return Type.regex(argument);
        },
        ToString: function ToString(string) {
          if (hasSymbols && _toString(string) === "[object Symbol]") {
            throw new TypeError("Cannot convert a Symbol value to a number");
          }
          return $String(string);
        }
      };
      if (supportsDescriptors && hasSymbols) {
        var defineWellKnownSymbol = function defineWellKnownSymbol2(name) {
          if (Type.symbol(Symbol2[name])) {
            return Symbol2[name];
          }
          var sym = Symbol2["for"]("Symbol." + name);
          Object.defineProperty(Symbol2, name, {
            configurable: false,
            enumerable: false,
            writable: false,
            value: sym
          });
          return sym;
        };
        if (!Type.symbol(Symbol2.search)) {
          var symbolSearch = defineWellKnownSymbol("search");
          var originalSearch = String.prototype.search;
          defineProperty(RegExp.prototype, symbolSearch, function search(string) {
            return ES.Call(originalSearch, string, [this]);
          });
          var searchShim = function search(regexp) {
            var O = ES.RequireObjectCoercible(this);
            if (!isNullOrUndefined(regexp)) {
              var searcher = ES.GetMethod(regexp, symbolSearch);
              if (typeof searcher !== "undefined") {
                return ES.Call(searcher, regexp, [O]);
              }
            }
            return ES.Call(originalSearch, O, [ES.ToString(regexp)]);
          };
          overrideNative(String.prototype, "search", searchShim);
        }
        if (!Type.symbol(Symbol2.replace)) {
          var symbolReplace = defineWellKnownSymbol("replace");
          var originalReplace = String.prototype.replace;
          defineProperty(RegExp.prototype, symbolReplace, function replace(string, replaceValue) {
            return ES.Call(originalReplace, string, [this, replaceValue]);
          });
          var replaceShim = function replace(searchValue, replaceValue) {
            var O = ES.RequireObjectCoercible(this);
            if (!isNullOrUndefined(searchValue)) {
              var replacer = ES.GetMethod(searchValue, symbolReplace);
              if (typeof replacer !== "undefined") {
                return ES.Call(replacer, searchValue, [O, replaceValue]);
              }
            }
            return ES.Call(originalReplace, O, [ES.ToString(searchValue), replaceValue]);
          };
          overrideNative(String.prototype, "replace", replaceShim);
        }
        if (!Type.symbol(Symbol2.split)) {
          var symbolSplit = defineWellKnownSymbol("split");
          var originalSplit = String.prototype.split;
          defineProperty(RegExp.prototype, symbolSplit, function split(string, limit) {
            return ES.Call(originalSplit, string, [this, limit]);
          });
          var splitShim = function split(separator, limit) {
            var O = ES.RequireObjectCoercible(this);
            if (!isNullOrUndefined(separator)) {
              var splitter = ES.GetMethod(separator, symbolSplit);
              if (typeof splitter !== "undefined") {
                return ES.Call(splitter, separator, [O, limit]);
              }
            }
            return ES.Call(originalSplit, O, [ES.ToString(separator), limit]);
          };
          overrideNative(String.prototype, "split", splitShim);
        }
        var symbolMatchExists = Type.symbol(Symbol2.match);
        var stringMatchIgnoresSymbolMatch = symbolMatchExists && function() {
          var o = {};
          o[Symbol2.match] = function() {
            return 42;
          };
          return "a".match(o) !== 42;
        }();
        if (!symbolMatchExists || stringMatchIgnoresSymbolMatch) {
          var symbolMatch = defineWellKnownSymbol("match");
          var originalMatch = String.prototype.match;
          defineProperty(RegExp.prototype, symbolMatch, function match(string) {
            return ES.Call(originalMatch, string, [this]);
          });
          var matchShim = function match(regexp) {
            var O = ES.RequireObjectCoercible(this);
            if (!isNullOrUndefined(regexp)) {
              var matcher = ES.GetMethod(regexp, symbolMatch);
              if (typeof matcher !== "undefined") {
                return ES.Call(matcher, regexp, [O]);
              }
            }
            return ES.Call(originalMatch, O, [ES.ToString(regexp)]);
          };
          overrideNative(String.prototype, "match", matchShim);
        }
      }
      var wrapConstructor = function wrapConstructor2(original, replacement, keysToSkip) {
        Value.preserveToString(replacement, original);
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(original, replacement);
        }
        if (supportsDescriptors) {
          _forEach(Object.getOwnPropertyNames(original), function(key) {
            if (key in noop || keysToSkip[key]) {
              return;
            }
            Value.proxy(original, key, replacement);
          });
        } else {
          _forEach(Object.keys(original), function(key) {
            if (key in noop || keysToSkip[key]) {
              return;
            }
            replacement[key] = original[key];
          });
        }
        replacement.prototype = original.prototype;
        Value.redefine(original.prototype, "constructor", replacement);
      };
      var defaultSpeciesGetter = function() {
        return this;
      };
      var addDefaultSpecies = function(C) {
        if (supportsDescriptors && !_hasOwnProperty(C, symbolSpecies)) {
          Value.getter(C, symbolSpecies, defaultSpeciesGetter);
        }
      };
      var addIterator = function(prototype, impl) {
        var implementation = impl || function iterator() {
          return this;
        };
        defineProperty(prototype, $iterator$, implementation);
        if (!prototype[$iterator$] && Type.symbol($iterator$)) {
          prototype[$iterator$] = implementation;
        }
      };
      var createDataProperty = function createDataProperty2(object, name, value) {
        if (supportsDescriptors) {
          Object.defineProperty(object, name, {
            configurable: true,
            enumerable: true,
            writable: true,
            value
          });
        } else {
          object[name] = value;
        }
      };
      var createDataPropertyOrThrow = function createDataPropertyOrThrow2(object, name, value) {
        createDataProperty(object, name, value);
        if (!ES.SameValue(object[name], value)) {
          throw new TypeError("property is nonconfigurable");
        }
      };
      var emulateES6construct = function(o, defaultNewTarget, defaultProto, slots) {
        if (!ES.TypeIsObject(o)) {
          throw new TypeError("Constructor requires `new`: " + defaultNewTarget.name);
        }
        var proto = defaultNewTarget.prototype;
        if (!ES.TypeIsObject(proto)) {
          proto = defaultProto;
        }
        var obj = create(proto);
        for (var name in slots) {
          if (_hasOwnProperty(slots, name)) {
            var value = slots[name];
            defineProperty(obj, name, value, true);
          }
        }
        return obj;
      };
      if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
        var originalFromCodePoint = String.fromCodePoint;
        overrideNative(String, "fromCodePoint", function fromCodePoint(codePoints) {
          return ES.Call(originalFromCodePoint, this, arguments);
        });
      }
      var StringShims = {
        fromCodePoint: function fromCodePoint(codePoints) {
          var result = [];
          var next;
          for (var i = 0, length = arguments.length; i < length; i++) {
            next = Number(arguments[i]);
            if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 1114111) {
              throw new RangeError("Invalid code point " + next);
            }
            if (next < 65536) {
              _push(result, String.fromCharCode(next));
            } else {
              next -= 65536;
              _push(result, String.fromCharCode((next >> 10) + 55296));
              _push(result, String.fromCharCode(next % 1024 + 56320));
            }
          }
          return _join(result, "");
        },
        raw: function raw(template) {
          var numberOfSubstitutions = arguments.length - 1;
          var cooked = ES.ToObject(template, "bad template");
          var raw2 = ES.ToObject(cooked.raw, "bad raw value");
          var len = raw2.length;
          var literalSegments = ES.ToLength(len);
          if (literalSegments <= 0) {
            return "";
          }
          var stringElements = [];
          var nextIndex = 0;
          var nextKey, next, nextSeg, nextSub;
          while (nextIndex < literalSegments) {
            nextKey = ES.ToString(nextIndex);
            nextSeg = ES.ToString(raw2[nextKey]);
            _push(stringElements, nextSeg);
            if (nextIndex + 1 >= literalSegments) {
              break;
            }
            next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : "";
            nextSub = ES.ToString(next);
            _push(stringElements, nextSub);
            nextIndex += 1;
          }
          return _join(stringElements, "");
        }
      };
      if (String.raw && String.raw({
        raw: {
          0: "x",
          1: "y",
          length: 2
        }
      }) !== "xy") {
        overrideNative(String, "raw", StringShims.raw);
      }
      defineProperties(String, StringShims);
      var stringRepeat = function repeat(s, times) {
        if (times < 1) {
          return "";
        }
        if (times % 2) {
          return repeat(s, times - 1) + s;
        }
        var half = repeat(s, times / 2);
        return half + half;
      };
      var stringMaxLength = Infinity;
      var StringPrototypeShims = {
        repeat: function repeat(times) {
          var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
          var numTimes = ES.ToInteger(times);
          if (numTimes < 0 || numTimes >= stringMaxLength) {
            throw new RangeError("repeat count must be less than infinity and not overflow maximum string size");
          }
          return stringRepeat(thisStr, numTimes);
        },
        startsWith: function startsWith(searchString) {
          var S = ES.ToString(ES.RequireObjectCoercible(this));
          if (ES.IsRegExp(searchString)) {
            throw new TypeError('Cannot call method "startsWith" with a regex');
          }
          var searchStr = ES.ToString(searchString);
          var position;
          if (arguments.length > 1) {
            position = arguments[1];
          }
          var start = _max(ES.ToInteger(position), 0);
          return _strSlice(S, start, start + searchStr.length) === searchStr;
        },
        endsWith: function endsWith(searchString) {
          var S = ES.ToString(ES.RequireObjectCoercible(this));
          if (ES.IsRegExp(searchString)) {
            throw new TypeError('Cannot call method "endsWith" with a regex');
          }
          var searchStr = ES.ToString(searchString);
          var len = S.length;
          var endPosition;
          if (arguments.length > 1) {
            endPosition = arguments[1];
          }
          var pos = typeof endPosition === "undefined" ? len : ES.ToInteger(endPosition);
          var end = _min(_max(pos, 0), len);
          return _strSlice(S, end - searchStr.length, end) === searchStr;
        },
        includes: function includes(searchString) {
          if (ES.IsRegExp(searchString)) {
            throw new TypeError('"includes" does not accept a RegExp');
          }
          var searchStr = ES.ToString(searchString);
          var position;
          if (arguments.length > 1) {
            position = arguments[1];
          }
          return _indexOf(this, searchStr, position) !== -1;
        },
        codePointAt: function codePointAt(pos) {
          var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
          var position = ES.ToInteger(pos);
          var length = thisStr.length;
          if (position >= 0 && position < length) {
            var first = thisStr.charCodeAt(position);
            var isEnd = position + 1 === length;
            if (first < 55296 || first > 56319 || isEnd) {
              return first;
            }
            var second = thisStr.charCodeAt(position + 1);
            if (second < 56320 || second > 57343) {
              return first;
            }
            return (first - 55296) * 1024 + (second - 56320) + 65536;
          }
        }
      };
      if (String.prototype.includes && "a".includes("a", Infinity) !== false) {
        overrideNative(String.prototype, "includes", StringPrototypeShims.includes);
      }
      if (String.prototype.startsWith && String.prototype.endsWith) {
        var startsWithRejectsRegex = throwsError(function() {
          return "/a/".startsWith(/a/);
        });
        var startsWithHandlesInfinity = valueOrFalseIfThrows(function() {
          return "abc".startsWith("a", Infinity) === false;
        });
        if (!startsWithRejectsRegex || !startsWithHandlesInfinity) {
          overrideNative(String.prototype, "startsWith", StringPrototypeShims.startsWith);
          overrideNative(String.prototype, "endsWith", StringPrototypeShims.endsWith);
        }
      }
      if (hasSymbols) {
        var startsWithSupportsSymbolMatch = valueOrFalseIfThrows(function() {
          var re = /a/;
          re[Symbol2.match] = false;
          return "/a/".startsWith(re);
        });
        if (!startsWithSupportsSymbolMatch) {
          overrideNative(String.prototype, "startsWith", StringPrototypeShims.startsWith);
        }
        var endsWithSupportsSymbolMatch = valueOrFalseIfThrows(function() {
          var re = /a/;
          re[Symbol2.match] = false;
          return "/a/".endsWith(re);
        });
        if (!endsWithSupportsSymbolMatch) {
          overrideNative(String.prototype, "endsWith", StringPrototypeShims.endsWith);
        }
        var includesSupportsSymbolMatch = valueOrFalseIfThrows(function() {
          var re = /a/;
          re[Symbol2.match] = false;
          return "/a/".includes(re);
        });
        if (!includesSupportsSymbolMatch) {
          overrideNative(String.prototype, "includes", StringPrototypeShims.includes);
        }
      }
      defineProperties(String.prototype, StringPrototypeShims);
      var ws = ["	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003", "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028", "\u2029\uFEFF"].join("");
      var trimRegexp = new RegExp("(^[" + ws + "]+)|([" + ws + "]+$)", "g");
      var trimShim = function trim() {
        return ES.ToString(ES.RequireObjectCoercible(this)).replace(trimRegexp, "");
      };
      var nonWS = ["\x85", "\u200B", "\uFFFE"].join("");
      var nonWSregex = new RegExp("[" + nonWS + "]", "g");
      var isBadHexRegex = /^[-+]0x[0-9a-f]+$/i;
      var hasStringTrimBug = nonWS.trim().length !== nonWS.length;
      defineProperty(String.prototype, "trim", trimShim, hasStringTrimBug);
      var iteratorResult = function(x) {
        return {
          value: x,
          done: arguments.length === 0
        };
      };
      var StringIterator = function(s) {
        ES.RequireObjectCoercible(s);
        this._s = ES.ToString(s);
        this._i = 0;
      };
      StringIterator.prototype.next = function() {
        var s = this._s;
        var i = this._i;
        if (typeof s === "undefined" || i >= s.length) {
          this._s = void 0;
          return iteratorResult();
        }
        var first = s.charCodeAt(i);
        var second, len;
        if (first < 55296 || first > 56319 || i + 1 === s.length) {
          len = 1;
        } else {
          second = s.charCodeAt(i + 1);
          len = second < 56320 || second > 57343 ? 1 : 2;
        }
        this._i = i + len;
        return iteratorResult(s.substr(i, len));
      };
      addIterator(StringIterator.prototype);
      addIterator(String.prototype, function() {
        return new StringIterator(this);
      });
      var ArrayShims = {
        from: function from(items) {
          var C = this;
          var mapFn;
          if (arguments.length > 1) {
            mapFn = arguments[1];
          }
          var mapping, T;
          if (typeof mapFn === "undefined") {
            mapping = false;
          } else {
            if (!ES.IsCallable(mapFn)) {
              throw new TypeError("Array.from: when provided, the second argument must be a function");
            }
            if (arguments.length > 2) {
              T = arguments[2];
            }
            mapping = true;
          }
          var usingIterator = typeof (isArguments(items) || ES.GetMethod(items, $iterator$)) !== "undefined";
          var length, result, i;
          if (usingIterator) {
            result = ES.IsConstructor(C) ? Object(new C()) : [];
            var iterator = ES.GetIterator(items);
            var next, nextValue;
            i = 0;
            while (true) {
              next = ES.IteratorStep(iterator);
              if (next === false) {
                break;
              }
              nextValue = next.value;
              try {
                if (mapping) {
                  nextValue = typeof T === "undefined" ? mapFn(nextValue, i) : _call(mapFn, T, nextValue, i);
                }
                result[i] = nextValue;
              } catch (e) {
                ES.IteratorClose(iterator, true);
                throw e;
              }
              i += 1;
            }
            length = i;
          } else {
            var arrayLike = ES.ToObject(items);
            length = ES.ToLength(arrayLike.length);
            result = ES.IsConstructor(C) ? Object(new C(length)) : new Array(length);
            var value;
            for (i = 0; i < length; ++i) {
              value = arrayLike[i];
              if (mapping) {
                value = typeof T === "undefined" ? mapFn(value, i) : _call(mapFn, T, value, i);
              }
              createDataPropertyOrThrow(result, i, value);
            }
          }
          result.length = length;
          return result;
        },
        of: function of() {
          var len = arguments.length;
          var C = this;
          var A = isArray(C) || !ES.IsCallable(C) ? new Array(len) : ES.Construct(C, [len]);
          for (var k = 0; k < len; ++k) {
            createDataPropertyOrThrow(A, k, arguments[k]);
          }
          A.length = len;
          return A;
        }
      };
      defineProperties(Array, ArrayShims);
      addDefaultSpecies(Array);
      ArrayIterator = function(array, kind) {
        this.i = 0;
        this.array = array;
        this.kind = kind;
      };
      defineProperties(ArrayIterator.prototype, {
        next: function() {
          var i = this.i;
          var array = this.array;
          if (!(this instanceof ArrayIterator)) {
            throw new TypeError("Not an ArrayIterator");
          }
          if (typeof array !== "undefined") {
            var len = ES.ToLength(array.length);
            if (i < len) {
              var kind = this.kind;
              var retval;
              if (kind === "key") {
                retval = i;
              } else if (kind === "value") {
                retval = array[i];
              } else if (kind === "entry") {
                retval = [i, array[i]];
              }
              this.i = i + 1;
              return iteratorResult(retval);
            }
          }
          this.array = void 0;
          return iteratorResult();
        }
      });
      addIterator(ArrayIterator.prototype);
      var arrayOfSupportsSubclassing = Array.of === ArrayShims.of || function() {
        var Foo = function Foo2(len) {
          this.length = len;
        };
        Foo.prototype = [];
        var fooArr = Array.of.apply(Foo, [1, 2]);
        return fooArr instanceof Foo && fooArr.length === 2;
      }();
      if (!arrayOfSupportsSubclassing) {
        overrideNative(Array, "of", ArrayShims.of);
      }
      var ArrayPrototypeShims = {
        copyWithin: function copyWithin(target, start) {
          var o = ES.ToObject(this);
          var len = ES.ToLength(o.length);
          var relativeTarget = ES.ToInteger(target);
          var relativeStart = ES.ToInteger(start);
          var to = relativeTarget < 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);
          var from = relativeStart < 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);
          var end;
          if (arguments.length > 2) {
            end = arguments[2];
          }
          var relativeEnd = typeof end === "undefined" ? len : ES.ToInteger(end);
          var finalItem = relativeEnd < 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);
          var count = _min(finalItem - from, len - to);
          var direction = 1;
          if (from < to && to < from + count) {
            direction = -1;
            from += count - 1;
            to += count - 1;
          }
          while (count > 0) {
            if (from in o) {
              o[to] = o[from];
            } else {
              delete o[to];
            }
            from += direction;
            to += direction;
            count -= 1;
          }
          return o;
        },
        fill: function fill(value) {
          var start;
          if (arguments.length > 1) {
            start = arguments[1];
          }
          var end;
          if (arguments.length > 2) {
            end = arguments[2];
          }
          var O = ES.ToObject(this);
          var len = ES.ToLength(O.length);
          start = ES.ToInteger(typeof start === "undefined" ? 0 : start);
          end = ES.ToInteger(typeof end === "undefined" ? len : end);
          var relativeStart = start < 0 ? _max(len + start, 0) : _min(start, len);
          var relativeEnd = end < 0 ? len + end : end;
          for (var i = relativeStart; i < len && i < relativeEnd; ++i) {
            O[i] = value;
          }
          return O;
        },
        find: function find(predicate) {
          var list = ES.ToObject(this);
          var length = ES.ToLength(list.length);
          if (!ES.IsCallable(predicate)) {
            throw new TypeError("Array#find: predicate must be a function");
          }
          var thisArg = arguments.length > 1 ? arguments[1] : null;
          for (var i = 0, value; i < length; i++) {
            value = list[i];
            if (thisArg) {
              if (_call(predicate, thisArg, value, i, list)) {
                return value;
              }
            } else if (predicate(value, i, list)) {
              return value;
            }
          }
        },
        findIndex: function findIndex(predicate) {
          var list = ES.ToObject(this);
          var length = ES.ToLength(list.length);
          if (!ES.IsCallable(predicate)) {
            throw new TypeError("Array#findIndex: predicate must be a function");
          }
          var thisArg = arguments.length > 1 ? arguments[1] : null;
          for (var i = 0; i < length; i++) {
            if (thisArg) {
              if (_call(predicate, thisArg, list[i], i, list)) {
                return i;
              }
            } else if (predicate(list[i], i, list)) {
              return i;
            }
          }
          return -1;
        },
        keys: function keys2() {
          return new ArrayIterator(this, "key");
        },
        values: function values() {
          return new ArrayIterator(this, "value");
        },
        entries: function entries() {
          return new ArrayIterator(this, "entry");
        }
      };
      if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {
        delete Array.prototype.keys;
      }
      if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {
        delete Array.prototype.entries;
      }
      if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {
        defineProperties(Array.prototype, {
          values: Array.prototype[$iterator$]
        });
        if (Type.symbol(Symbol2.unscopables)) {
          Array.prototype[Symbol2.unscopables].values = true;
        }
      }
      if (functionsHaveNames && Array.prototype.values && Array.prototype.values.name !== "values") {
        var originalArrayPrototypeValues = Array.prototype.values;
        overrideNative(Array.prototype, "values", function values() {
          return ES.Call(originalArrayPrototypeValues, this, arguments);
        });
        defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);
      }
      defineProperties(Array.prototype, ArrayPrototypeShims);
      if (1 / [true].indexOf(true, -0) < 0) {
        defineProperty(Array.prototype, "indexOf", function indexOf(searchElement) {
          var value = _arrayIndexOfApply(this, arguments);
          if (value === 0 && 1 / value < 0) {
            return 0;
          }
          return value;
        }, true);
      }
      addIterator(Array.prototype, function() {
        return this.values();
      });
      if (Object.getPrototypeOf) {
        addIterator(Object.getPrototypeOf([].values()));
      }
      var arrayFromSwallowsNegativeLengths = function() {
        return valueOrFalseIfThrows(function() {
          return Array.from({
            length: -1
          }).length === 0;
        });
      }();
      var arrayFromHandlesIterables = function() {
        var arr = Array.from([0].entries());
        return arr.length === 1 && isArray(arr[0]) && arr[0][0] === 0 && arr[0][1] === 0;
      }();
      if (!arrayFromSwallowsNegativeLengths || !arrayFromHandlesIterables) {
        overrideNative(Array, "from", ArrayShims.from);
      }
      var arrayFromHandlesUndefinedMapFunction = function() {
        return valueOrFalseIfThrows(function() {
          return Array.from([0], void 0);
        });
      }();
      if (!arrayFromHandlesUndefinedMapFunction) {
        var origArrayFrom = Array.from;
        overrideNative(Array, "from", function from(items) {
          if (arguments.length > 1 && typeof arguments[1] !== "undefined") {
            return ES.Call(origArrayFrom, this, arguments);
          } else {
            return _call(origArrayFrom, this, items);
          }
        });
      }
      var int32sAsOne = -(Math.pow(2, 32) - 1);
      var toLengthsCorrectly = function(method, reversed) {
        var obj = {
          length: int32sAsOne
        };
        obj[reversed ? (obj.length >>> 0) - 1 : 0] = true;
        return valueOrFalseIfThrows(function() {
          _call(method, obj, function() {
            throw new RangeError("should not reach here");
          }, []);
          return true;
        });
      };
      if (!toLengthsCorrectly(Array.prototype.forEach)) {
        var originalForEach = Array.prototype.forEach;
        overrideNative(Array.prototype, "forEach", function forEach(callbackFn) {
          return ES.Call(originalForEach, this.length >= 0 ? this : [], arguments);
        });
      }
      if (!toLengthsCorrectly(Array.prototype.map)) {
        var originalMap = Array.prototype.map;
        overrideNative(Array.prototype, "map", function map(callbackFn) {
          return ES.Call(originalMap, this.length >= 0 ? this : [], arguments);
        });
      }
      if (!toLengthsCorrectly(Array.prototype.filter)) {
        var originalFilter = Array.prototype.filter;
        overrideNative(Array.prototype, "filter", function filter(callbackFn) {
          return ES.Call(originalFilter, this.length >= 0 ? this : [], arguments);
        });
      }
      if (!toLengthsCorrectly(Array.prototype.some)) {
        var originalSome = Array.prototype.some;
        overrideNative(Array.prototype, "some", function some(callbackFn) {
          return ES.Call(originalSome, this.length >= 0 ? this : [], arguments);
        });
      }
      if (!toLengthsCorrectly(Array.prototype.every)) {
        var originalEvery = Array.prototype.every;
        overrideNative(Array.prototype, "every", function every(callbackFn) {
          return ES.Call(originalEvery, this.length >= 0 ? this : [], arguments);
        });
      }
      if (!toLengthsCorrectly(Array.prototype.reduce)) {
        var originalReduce = Array.prototype.reduce;
        overrideNative(Array.prototype, "reduce", function reduce(callbackFn) {
          return ES.Call(originalReduce, this.length >= 0 ? this : [], arguments);
        });
      }
      if (!toLengthsCorrectly(Array.prototype.reduceRight, true)) {
        var originalReduceRight = Array.prototype.reduceRight;
        overrideNative(Array.prototype, "reduceRight", function reduceRight(callbackFn) {
          return ES.Call(originalReduceRight, this.length >= 0 ? this : [], arguments);
        });
      }
      var lacksOctalSupport = Number("0o10") !== 8;
      var lacksBinarySupport = Number("0b10") !== 2;
      var trimsNonWhitespace = _some(nonWS, function(c) {
        return Number(c + 0 + c) === 0;
      });
      if (lacksOctalSupport || lacksBinarySupport || trimsNonWhitespace) {
        var OrigNumber = Number;
        var binaryRegex = /^0b[01]+$/i;
        var octalRegex = /^0o[0-7]+$/i;
        var isBinary = binaryRegex.test.bind(binaryRegex);
        var isOctal = octalRegex.test.bind(octalRegex);
        var toPrimitive = function(O, hint) {
          var result;
          if (typeof O.valueOf === "function") {
            result = O.valueOf();
            if (Type.primitive(result)) {
              return result;
            }
          }
          if (typeof O.toString === "function") {
            result = O.toString();
            if (Type.primitive(result)) {
              return result;
            }
          }
          throw new TypeError("No default value");
        };
        var hasNonWS = nonWSregex.test.bind(nonWSregex);
        var isBadHex = isBadHexRegex.test.bind(isBadHexRegex);
        var NumberShim = function() {
          var NumberShim2 = function Number2(value) {
            var primValue;
            if (arguments.length > 0) {
              primValue = Type.primitive(value) ? value : toPrimitive(value, "number");
            } else {
              primValue = 0;
            }
            if (typeof primValue === "string") {
              primValue = ES.Call(trimShim, primValue);
              if (isBinary(primValue)) {
                primValue = parseInt(_strSlice(primValue, 2), 2);
              } else if (isOctal(primValue)) {
                primValue = parseInt(_strSlice(primValue, 2), 8);
              } else if (hasNonWS(primValue) || isBadHex(primValue)) {
                primValue = NaN;
              }
            }
            var receiver = this;
            var valueOfSucceeds = valueOrFalseIfThrows(function() {
              OrigNumber.prototype.valueOf.call(receiver);
              return true;
            });
            if (receiver instanceof NumberShim2 && !valueOfSucceeds) {
              return new OrigNumber(primValue);
            }
            return OrigNumber(primValue);
          };
          return NumberShim2;
        }();
        wrapConstructor(OrigNumber, NumberShim, {});
        defineProperties(NumberShim, {
          NaN: OrigNumber.NaN,
          MAX_VALUE: OrigNumber.MAX_VALUE,
          MIN_VALUE: OrigNumber.MIN_VALUE,
          NEGATIVE_INFINITY: OrigNumber.NEGATIVE_INFINITY,
          POSITIVE_INFINITY: OrigNumber.POSITIVE_INFINITY
        });
        Number = NumberShim;
        Value.redefine(globals, "Number", NumberShim);
      }
      var maxSafeInteger = Math.pow(2, 53) - 1;
      defineProperties(Number, {
        MAX_SAFE_INTEGER: maxSafeInteger,
        MIN_SAFE_INTEGER: -maxSafeInteger,
        EPSILON: 2220446049250313e-31,
        parseInt: globals.parseInt,
        parseFloat: globals.parseFloat,
        isFinite: numberIsFinite,
        isInteger: function isInteger(value) {
          return numberIsFinite(value) && ES.ToInteger(value) === value;
        },
        isSafeInteger: function isSafeInteger(value) {
          return Number.isInteger(value) && _abs(value) <= Number.MAX_SAFE_INTEGER;
        },
        isNaN: numberIsNaN
      });
      defineProperty(Number, "parseInt", globals.parseInt, Number.parseInt !== globals.parseInt);
      if ([, 1].find(function() {
        return true;
      }) === 1) {
        overrideNative(Array.prototype, "find", ArrayPrototypeShims.find);
      }
      if ([, 1].findIndex(function() {
        return true;
      }) !== 0) {
        overrideNative(Array.prototype, "findIndex", ArrayPrototypeShims.findIndex);
      }
      var isEnumerableOn = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
      var ensureEnumerable = function ensureEnumerable2(obj, prop) {
        if (supportsDescriptors && isEnumerableOn(obj, prop)) {
          Object.defineProperty(obj, prop, {
            enumerable: false
          });
        }
      };
      var sliceArgs = function sliceArgs2() {
        var initial = Number(this);
        var len = arguments.length;
        var desiredArgCount = len - initial;
        var args = new Array(desiredArgCount < 0 ? 0 : desiredArgCount);
        for (var i = initial; i < len; ++i) {
          args[i - initial] = arguments[i];
        }
        return args;
      };
      var assignTo = function assignTo2(source) {
        return function assignToSource(target, key) {
          target[key] = source[key];
          return target;
        };
      };
      var assignReducer = function(target, source) {
        var sourceKeys = keys(Object(source));
        var symbols;
        if (ES.IsCallable(Object.getOwnPropertySymbols)) {
          symbols = _filter(Object.getOwnPropertySymbols(Object(source)), isEnumerableOn(source));
        }
        return _reduce(_concat(sourceKeys, symbols || []), assignTo(source), target);
      };
      var ObjectShims = {
        assign: function(target, source) {
          var to = ES.ToObject(target, "Cannot convert undefined or null to object");
          return _reduce(ES.Call(sliceArgs, 1, arguments), assignReducer, to);
        },
        is: function is(a, b) {
          return ES.SameValue(a, b);
        }
      };
      var assignHasPendingExceptions = Object.assign && Object.preventExtensions && function() {
        var thrower = Object.preventExtensions({
          1: 2
        });
        try {
          Object.assign(thrower, "xy");
        } catch (e) {
          return thrower[1] === "y";
        }
      }();
      if (assignHasPendingExceptions) {
        overrideNative(Object, "assign", ObjectShims.assign);
      }
      defineProperties(Object, ObjectShims);
      if (supportsDescriptors) {
        var ES5ObjectShims = {
          setPrototypeOf: function(Object2, magic) {
            var set;
            var checkArgs = function(O, proto) {
              if (!ES.TypeIsObject(O)) {
                throw new TypeError("cannot set prototype on a non-object");
              }
              if (!(proto === null || ES.TypeIsObject(proto))) {
                throw new TypeError("can only set prototype to an object or null" + proto);
              }
            };
            var setPrototypeOf = function(O, proto) {
              checkArgs(O, proto);
              _call(set, O, proto);
              return O;
            };
            try {
              set = Object2.getOwnPropertyDescriptor(Object2.prototype, magic).set;
              _call(set, {}, null);
            } catch (e) {
              if (Object2.prototype !== {}[magic]) {
                return;
              }
              set = function(proto) {
                this[magic] = proto;
              };
              setPrototypeOf.polyfill = setPrototypeOf(setPrototypeOf({}, null), Object2.prototype) instanceof Object2;
            }
            return setPrototypeOf;
          }(Object, "__proto__")
        };
        defineProperties(Object, ES5ObjectShims);
      }
      if (Object.setPrototypeOf && Object.getPrototypeOf && Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null && Object.getPrototypeOf(/* @__PURE__ */ Object.create(null)) === null) {
        (function() {
          var FAKENULL = /* @__PURE__ */ Object.create(null);
          var gpo = Object.getPrototypeOf;
          var spo = Object.setPrototypeOf;
          Object.getPrototypeOf = function(o) {
            var result = gpo(o);
            return result === FAKENULL ? null : result;
          };
          Object.setPrototypeOf = function(o, p) {
            var proto = p === null ? FAKENULL : p;
            return spo(o, proto);
          };
          Object.setPrototypeOf.polyfill = false;
        })();
      }
      var objectKeysAcceptsPrimitives = !throwsError(function() {
        return Object.keys("foo");
      });
      if (!objectKeysAcceptsPrimitives) {
        var originalObjectKeys = Object.keys;
        overrideNative(Object, "keys", function keys2(value) {
          return originalObjectKeys(ES.ToObject(value));
        });
        keys = Object.keys;
      }
      var objectKeysRejectsRegex = throwsError(function() {
        return Object.keys(/a/g);
      });
      if (objectKeysRejectsRegex) {
        var regexRejectingObjectKeys = Object.keys;
        overrideNative(Object, "keys", function keys2(value) {
          if (Type.regex(value)) {
            var regexKeys = [];
            for (var k in value) {
              if (_hasOwnProperty(value, k)) {
                _push(regexKeys, k);
              }
            }
            return regexKeys;
          }
          return regexRejectingObjectKeys(value);
        });
        keys = Object.keys;
      }
      if (Object.getOwnPropertyNames) {
        var objectGOPNAcceptsPrimitives = !throwsError(function() {
          return Object.getOwnPropertyNames("foo");
        });
        if (!objectGOPNAcceptsPrimitives) {
          var cachedWindowNames = typeof window === "object" ? Object.getOwnPropertyNames(window) : [];
          var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
          overrideNative(Object, "getOwnPropertyNames", function getOwnPropertyNames(value) {
            var val = ES.ToObject(value);
            if (_toString(val) === "[object Window]") {
              try {
                return originalObjectGetOwnPropertyNames(val);
              } catch (e) {
                return _concat([], cachedWindowNames);
              }
            }
            return originalObjectGetOwnPropertyNames(val);
          });
        }
      }
      if (Object.getOwnPropertyDescriptor) {
        var objectGOPDAcceptsPrimitives = !throwsError(function() {
          return Object.getOwnPropertyDescriptor("foo", "bar");
        });
        if (!objectGOPDAcceptsPrimitives) {
          var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          overrideNative(Object, "getOwnPropertyDescriptor", function getOwnPropertyDescriptor(value, property) {
            return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);
          });
        }
      }
      if (Object.seal) {
        var objectSealAcceptsPrimitives = !throwsError(function() {
          return Object.seal("foo");
        });
        if (!objectSealAcceptsPrimitives) {
          var originalObjectSeal = Object.seal;
          overrideNative(Object, "seal", function seal(value) {
            if (!ES.TypeIsObject(value)) {
              return value;
            }
            return originalObjectSeal(value);
          });
        }
      }
      if (Object.isSealed) {
        var objectIsSealedAcceptsPrimitives = !throwsError(function() {
          return Object.isSealed("foo");
        });
        if (!objectIsSealedAcceptsPrimitives) {
          var originalObjectIsSealed = Object.isSealed;
          overrideNative(Object, "isSealed", function isSealed(value) {
            if (!ES.TypeIsObject(value)) {
              return true;
            }
            return originalObjectIsSealed(value);
          });
        }
      }
      if (Object.freeze) {
        var objectFreezeAcceptsPrimitives = !throwsError(function() {
          return Object.freeze("foo");
        });
        if (!objectFreezeAcceptsPrimitives) {
          var originalObjectFreeze = Object.freeze;
          overrideNative(Object, "freeze", function freeze(value) {
            if (!ES.TypeIsObject(value)) {
              return value;
            }
            return originalObjectFreeze(value);
          });
        }
      }
      if (Object.isFrozen) {
        var objectIsFrozenAcceptsPrimitives = !throwsError(function() {
          return Object.isFrozen("foo");
        });
        if (!objectIsFrozenAcceptsPrimitives) {
          var originalObjectIsFrozen = Object.isFrozen;
          overrideNative(Object, "isFrozen", function isFrozen(value) {
            if (!ES.TypeIsObject(value)) {
              return true;
            }
            return originalObjectIsFrozen(value);
          });
        }
      }
      if (Object.preventExtensions) {
        var objectPreventExtensionsAcceptsPrimitives = !throwsError(function() {
          return Object.preventExtensions("foo");
        });
        if (!objectPreventExtensionsAcceptsPrimitives) {
          var originalObjectPreventExtensions = Object.preventExtensions;
          overrideNative(Object, "preventExtensions", function preventExtensions(value) {
            if (!ES.TypeIsObject(value)) {
              return value;
            }
            return originalObjectPreventExtensions(value);
          });
        }
      }
      if (Object.isExtensible) {
        var objectIsExtensibleAcceptsPrimitives = !throwsError(function() {
          return Object.isExtensible("foo");
        });
        if (!objectIsExtensibleAcceptsPrimitives) {
          var originalObjectIsExtensible = Object.isExtensible;
          overrideNative(Object, "isExtensible", function isExtensible(value) {
            if (!ES.TypeIsObject(value)) {
              return false;
            }
            return originalObjectIsExtensible(value);
          });
        }
      }
      if (Object.getPrototypeOf) {
        var objectGetProtoAcceptsPrimitives = !throwsError(function() {
          return Object.getPrototypeOf("foo");
        });
        if (!objectGetProtoAcceptsPrimitives) {
          var originalGetProto = Object.getPrototypeOf;
          overrideNative(Object, "getPrototypeOf", function getPrototypeOf(value) {
            return originalGetProto(ES.ToObject(value));
          });
        }
      }
      var hasFlags = supportsDescriptors && function() {
        var desc = Object.getOwnPropertyDescriptor(RegExp.prototype, "flags");
        return desc && ES.IsCallable(desc.get);
      }();
      if (supportsDescriptors && !hasFlags) {
        var regExpFlagsGetter = function flags() {
          if (!ES.TypeIsObject(this)) {
            throw new TypeError("Method called on incompatible type: must be an object.");
          }
          var result = "";
          if (this.global) {
            result += "g";
          }
          if (this.ignoreCase) {
            result += "i";
          }
          if (this.multiline) {
            result += "m";
          }
          if (this.unicode) {
            result += "u";
          }
          if (this.sticky) {
            result += "y";
          }
          return result;
        };
        Value.getter(RegExp.prototype, "flags", regExpFlagsGetter);
      }
      var regExpSupportsFlagsWithRegex = supportsDescriptors && valueOrFalseIfThrows(function() {
        return String(new RegExp(/a/g, "i")) === "/a/i";
      });
      var regExpNeedsToSupportSymbolMatch = hasSymbols && supportsDescriptors && function() {
        var regex = /./;
        regex[Symbol2.match] = false;
        return RegExp(regex) === regex;
      }();
      var regexToStringIsGeneric = valueOrFalseIfThrows(function() {
        return RegExp.prototype.toString.call({
          source: "abc"
        }) === "/abc/";
      });
      var regexToStringSupportsGenericFlags = regexToStringIsGeneric && valueOrFalseIfThrows(function() {
        return RegExp.prototype.toString.call({
          source: "a",
          flags: "b"
        }) === "/a/b";
      });
      if (!regexToStringIsGeneric || !regexToStringSupportsGenericFlags) {
        var origRegExpToString = RegExp.prototype.toString;
        defineProperty(RegExp.prototype, "toString", function toString() {
          var R = ES.RequireObjectCoercible(this);
          if (Type.regex(R)) {
            return _call(origRegExpToString, R);
          }
          var pattern = $String(R.source);
          var flags = $String(R.flags);
          return "/" + pattern + "/" + flags;
        }, true);
        Value.preserveToString(RegExp.prototype.toString, origRegExpToString);
      }
      if (supportsDescriptors && (!regExpSupportsFlagsWithRegex || regExpNeedsToSupportSymbolMatch)) {
        var flagsGetter = Object.getOwnPropertyDescriptor(RegExp.prototype, "flags").get;
        var sourceDesc = Object.getOwnPropertyDescriptor(RegExp.prototype, "source") || {};
        var legacySourceGetter = function() {
          return this.source;
        };
        var sourceGetter = ES.IsCallable(sourceDesc.get) ? sourceDesc.get : legacySourceGetter;
        var OrigRegExp = RegExp;
        var RegExpShim = function() {
          return function RegExp2(pattern, flags) {
            var patternIsRegExp = ES.IsRegExp(pattern);
            var calledWithNew = this instanceof RegExp2;
            if (!calledWithNew && patternIsRegExp && typeof flags === "undefined" && pattern.constructor === RegExp2) {
              return pattern;
            }
            var P = pattern;
            var F = flags;
            if (Type.regex(pattern)) {
              P = ES.Call(sourceGetter, pattern);
              F = typeof flags === "undefined" ? ES.Call(flagsGetter, pattern) : flags;
              return new RegExp2(P, F);
            } else if (patternIsRegExp) {
              P = pattern.source;
              F = typeof flags === "undefined" ? pattern.flags : flags;
            }
            return new OrigRegExp(pattern, flags);
          };
        }();
        wrapConstructor(OrigRegExp, RegExpShim, {
          $input: true
        });
        RegExp = RegExpShim;
        Value.redefine(globals, "RegExp", RegExpShim);
      }
      if (supportsDescriptors) {
        var regexGlobals = {
          input: "$_",
          lastMatch: "$&",
          lastParen: "$+",
          leftContext: "$`",
          rightContext: "$'"
        };
        _forEach(keys(regexGlobals), function(prop) {
          if (prop in RegExp && !(regexGlobals[prop] in RegExp)) {
            Value.getter(RegExp, regexGlobals[prop], function get() {
              return RegExp[prop];
            });
          }
        });
      }
      addDefaultSpecies(RegExp);
      var inverseEpsilon = 1 / Number.EPSILON;
      var roundTiesToEven = function roundTiesToEven2(n) {
        return n + inverseEpsilon - inverseEpsilon;
      };
      var BINARY_32_EPSILON = Math.pow(2, -23);
      var BINARY_32_MAX_VALUE = Math.pow(2, 127) * (2 - BINARY_32_EPSILON);
      var BINARY_32_MIN_VALUE = Math.pow(2, -126);
      var E = Math.E;
      var LOG2E = Math.LOG2E;
      var LOG10E = Math.LOG10E;
      var numberCLZ = Number.prototype.clz;
      delete Number.prototype.clz;
      var MathShims = {
        acosh: function acosh(value) {
          var x = Number(value);
          if (numberIsNaN(x) || value < 1) {
            return NaN;
          }
          if (x === 1) {
            return 0;
          }
          if (x === Infinity) {
            return x;
          }
          var xInvSquared = 1 / (x * x);
          if (x < 2) {
            return _log1p(x - 1 + _sqrt(1 - xInvSquared) * x);
          }
          var halfX = x / 2;
          return _log1p(halfX + _sqrt(1 - xInvSquared) * halfX - 1) + 1 / LOG2E;
        },
        asinh: function asinh(value) {
          var x = Number(value);
          if (x === 0 || !globalIsFinite(x)) {
            return x;
          }
          var a = _abs(x);
          var aSquared = a * a;
          var s = _sign(x);
          if (a < 1) {
            return s * _log1p(a + aSquared / (_sqrt(aSquared + 1) + 1));
          }
          return s * (_log1p(a / 2 + _sqrt(1 + 1 / aSquared) * a / 2 - 1) + 1 / LOG2E);
        },
        atanh: function atanh(value) {
          var x = Number(value);
          if (x === 0) {
            return x;
          }
          if (x === -1) {
            return -Infinity;
          }
          if (x === 1) {
            return Infinity;
          }
          if (numberIsNaN(x) || x < -1 || x > 1) {
            return NaN;
          }
          var a = _abs(x);
          return _sign(x) * _log1p(2 * a / (1 - a)) / 2;
        },
        cbrt: function cbrt(value) {
          var x = Number(value);
          if (x === 0) {
            return x;
          }
          var negate = x < 0;
          var result;
          if (negate) {
            x = -x;
          }
          if (x === Infinity) {
            result = Infinity;
          } else {
            result = _exp(_log(x) / 3);
            result = (x / (result * result) + 2 * result) / 3;
          }
          return negate ? -result : result;
        },
        clz32: function clz32(value) {
          var x = Number(value);
          var number = ES.ToUint32(x);
          if (number === 0) {
            return 32;
          }
          return numberCLZ ? ES.Call(numberCLZ, number) : 31 - _floor(_log(number + 0.5) * LOG2E);
        },
        cosh: function cosh(value) {
          var x = Number(value);
          if (x === 0) {
            return 1;
          }
          if (numberIsNaN(x)) {
            return NaN;
          }
          if (!globalIsFinite(x)) {
            return Infinity;
          }
          var t = _exp(_abs(x) - 1);
          return (t + 1 / (t * E * E)) * (E / 2);
        },
        expm1: function expm1(value) {
          var x = Number(value);
          if (x === -Infinity) {
            return -1;
          }
          if (!globalIsFinite(x) || x === 0) {
            return x;
          }
          if (_abs(x) > 0.5) {
            return _exp(x) - 1;
          }
          var t = x;
          var sum = 0;
          var n = 1;
          while (sum + t !== sum) {
            sum += t;
            n += 1;
            t *= x / n;
          }
          return sum;
        },
        hypot: function hypot(x, y) {
          var result = 0;
          var largest = 0;
          for (var i = 0; i < arguments.length; ++i) {
            var value = _abs(Number(arguments[i]));
            if (largest < value) {
              result *= largest / value * (largest / value);
              result += 1;
              largest = value;
            } else {
              result += value > 0 ? value / largest * (value / largest) : value;
            }
          }
          return largest === Infinity ? Infinity : largest * _sqrt(result);
        },
        log2: function log2(value) {
          return _log(value) * LOG2E;
        },
        log10: function log10(value) {
          return _log(value) * LOG10E;
        },
        log1p: _log1p,
        sign: _sign,
        sinh: function sinh(value) {
          var x = Number(value);
          if (!globalIsFinite(x) || x === 0) {
            return x;
          }
          var a = _abs(x);
          if (a < 1) {
            var u = Math.expm1(a);
            return _sign(x) * u * (1 + 1 / (u + 1)) / 2;
          }
          var t = _exp(a - 1);
          return _sign(x) * (t - 1 / (t * E * E)) * (E / 2);
        },
        tanh: function tanh(value) {
          var x = Number(value);
          if (numberIsNaN(x) || x === 0) {
            return x;
          }
          if (x >= 20) {
            return 1;
          }
          if (x <= -20) {
            return -1;
          }
          return (Math.expm1(x) - Math.expm1(-x)) / (_exp(x) + _exp(-x));
        },
        trunc: function trunc(value) {
          var x = Number(value);
          return x < 0 ? -_floor(-x) : _floor(x);
        },
        imul: function imul(x, y) {
          var a = ES.ToUint32(x);
          var b = ES.ToUint32(y);
          var ah = a >>> 16 & 65535;
          var al = a & 65535;
          var bh = b >>> 16 & 65535;
          var bl = b & 65535;
          return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
        },
        fround: function fround(x) {
          var v = Number(x);
          if (v === 0 || v === Infinity || v === -Infinity || numberIsNaN(v)) {
            return v;
          }
          var sign = _sign(v);
          var abs = _abs(v);
          if (abs < BINARY_32_MIN_VALUE) {
            return sign * roundTiesToEven(abs / BINARY_32_MIN_VALUE / BINARY_32_EPSILON) * BINARY_32_MIN_VALUE * BINARY_32_EPSILON;
          }
          var a = (1 + BINARY_32_EPSILON / Number.EPSILON) * abs;
          var result = a - (a - abs);
          if (result > BINARY_32_MAX_VALUE || numberIsNaN(result)) {
            return sign * Infinity;
          }
          return sign * result;
        }
      };
      var withinULPDistance = function withinULPDistance2(result, expected, distance) {
        return _abs(1 - result / expected) / Number.EPSILON < (distance || 8);
      };
      defineProperties(Math, MathShims);
      defineProperty(Math, "sinh", MathShims.sinh, Math.sinh(710) === Infinity);
      defineProperty(Math, "cosh", MathShims.cosh, Math.cosh(710) === Infinity);
      defineProperty(Math, "log1p", MathShims.log1p, Math.log1p(-1e-17) !== -1e-17);
      defineProperty(Math, "asinh", MathShims.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
      defineProperty(Math, "asinh", MathShims.asinh, Math.asinh(1e300) === Infinity);
      defineProperty(Math, "atanh", MathShims.atanh, Math.atanh(1e-300) === 0);
      defineProperty(Math, "tanh", MathShims.tanh, Math.tanh(-2e-17) !== -2e-17);
      defineProperty(Math, "acosh", MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
      defineProperty(Math, "acosh", MathShims.acosh, !withinULPDistance(Math.acosh(1 + Number.EPSILON), Math.sqrt(2 * Number.EPSILON)));
      defineProperty(Math, "cbrt", MathShims.cbrt, !withinULPDistance(Math.cbrt(1e-300), 1e-100));
      defineProperty(Math, "sinh", MathShims.sinh, Math.sinh(-2e-17) !== -2e-17);
      var expm1OfTen = Math.expm1(10);
      defineProperty(Math, "expm1", MathShims.expm1, expm1OfTen > 22025.465794806718 || expm1OfTen < 22025.465794806718);
      defineProperty(Math, "hypot", MathShims.hypot, Math.hypot(Infinity, NaN) !== Infinity);
      var origMathRound = Math.round;
      var roundHandlesBoundaryConditions = Math.round(0.5 - Number.EPSILON / 4) === 0 && Math.round(-0.5 + Number.EPSILON / 3.99) === 1;
      var smallestPositiveNumberWhereRoundBreaks = inverseEpsilon + 1;
      var largestPositiveNumberWhereRoundBreaks = 2 * inverseEpsilon - 1;
      var roundDoesNotIncreaseIntegers = [smallestPositiveNumberWhereRoundBreaks, largestPositiveNumberWhereRoundBreaks].every(function(num) {
        return Math.round(num) === num;
      });
      defineProperty(Math, "round", function round(x) {
        var floor = _floor(x);
        var ceil = floor === -1 ? -0 : floor + 1;
        return x - floor < 0.5 ? floor : ceil;
      }, !roundHandlesBoundaryConditions || !roundDoesNotIncreaseIntegers);
      Value.preserveToString(Math.round, origMathRound);
      var origImul = Math.imul;
      if (Math.imul(4294967295, 5) !== -5) {
        Math.imul = MathShims.imul;
        Value.preserveToString(Math.imul, origImul);
      }
      if (Math.imul.length !== 2) {
        overrideNative(Math, "imul", function imul(x, y) {
          return ES.Call(origImul, Math, arguments);
        });
      }
      var PromiseShim = function() {
        var setTimeout = globals.setTimeout;
        if (typeof setTimeout !== "function" && typeof setTimeout !== "object") {
          return;
        }
        ES.IsPromise = function(promise) {
          if (!ES.TypeIsObject(promise)) {
            return false;
          }
          if (typeof promise._promise === "undefined") {
            return false;
          }
          return true;
        };
        var PromiseCapability = function(C) {
          if (!ES.IsConstructor(C)) {
            throw new TypeError("Bad promise constructor");
          }
          var capability = this;
          var resolver = function(resolve, reject) {
            if (capability.resolve !== void 0 || capability.reject !== void 0) {
              throw new TypeError("Bad Promise implementation!");
            }
            capability.resolve = resolve;
            capability.reject = reject;
          };
          capability.resolve = void 0;
          capability.reject = void 0;
          capability.promise = new C(resolver);
          if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {
            throw new TypeError("Bad promise constructor");
          }
        };
        var makeZeroTimeout;
        if (typeof window !== "undefined" && ES.IsCallable(window.postMessage)) {
          makeZeroTimeout = function() {
            var timeouts = [];
            var messageName = "zero-timeout-message";
            var setZeroTimeout = function(fn) {
              _push(timeouts, fn);
              window.postMessage(messageName, "*");
            };
            var handleMessage = function(event) {
              if (event.source === window && event.data === messageName) {
                event.stopPropagation();
                if (timeouts.length === 0) {
                  return;
                }
                var fn = _shift(timeouts);
                fn();
              }
            };
            window.addEventListener("message", handleMessage, true);
            return setZeroTimeout;
          };
        }
        var makePromiseAsap = function() {
          var P = globals.Promise;
          var pr = P && P.resolve && P.resolve();
          return pr && function(task) {
            return pr.then(task);
          };
        };
        var enqueue = ES.IsCallable(globals.setImmediate) ? globals.setImmediate : typeof process === "object" && process.nextTick ? process.nextTick : makePromiseAsap() || (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() : function(task) {
          setTimeout(task, 0);
        });
        var PROMISE_IDENTITY = function(x) {
          return x;
        };
        var PROMISE_THROWER = function(e) {
          throw e;
        };
        var PROMISE_PENDING = 0;
        var PROMISE_FULFILLED = 1;
        var PROMISE_REJECTED = 2;
        var PROMISE_FULFILL_OFFSET = 0;
        var PROMISE_REJECT_OFFSET = 1;
        var PROMISE_CAPABILITY_OFFSET = 2;
        var PROMISE_FAKE_CAPABILITY = {};
        var enqueuePromiseReactionJob = function(handler, capability, argument) {
          enqueue(function() {
            promiseReactionJob(handler, capability, argument);
          });
        };
        var promiseReactionJob = function(handler, promiseCapability, argument) {
          var handlerResult, f;
          if (promiseCapability === PROMISE_FAKE_CAPABILITY) {
            return handler(argument);
          }
          try {
            handlerResult = handler(argument);
            f = promiseCapability.resolve;
          } catch (e) {
            handlerResult = e;
            f = promiseCapability.reject;
          }
          f(handlerResult);
        };
        var fulfillPromise = function(promise, value) {
          var _promise = promise._promise;
          var length = _promise.reactionLength;
          if (length > 0) {
            enqueuePromiseReactionJob(_promise.fulfillReactionHandler0, _promise.reactionCapability0, value);
            _promise.fulfillReactionHandler0 = void 0;
            _promise.rejectReactions0 = void 0;
            _promise.reactionCapability0 = void 0;
            if (length > 1) {
              for (var i = 1, idx = 0; i < length; i++, idx += 3) {
                enqueuePromiseReactionJob(_promise[idx + PROMISE_FULFILL_OFFSET], _promise[idx + PROMISE_CAPABILITY_OFFSET], value);
                promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
                promise[idx + PROMISE_REJECT_OFFSET] = void 0;
                promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
              }
            }
          }
          _promise.result = value;
          _promise.state = PROMISE_FULFILLED;
          _promise.reactionLength = 0;
        };
        var rejectPromise = function(promise, reason) {
          var _promise = promise._promise;
          var length = _promise.reactionLength;
          if (length > 0) {
            enqueuePromiseReactionJob(_promise.rejectReactionHandler0, _promise.reactionCapability0, reason);
            _promise.fulfillReactionHandler0 = void 0;
            _promise.rejectReactions0 = void 0;
            _promise.reactionCapability0 = void 0;
            if (length > 1) {
              for (var i = 1, idx = 0; i < length; i++, idx += 3) {
                enqueuePromiseReactionJob(_promise[idx + PROMISE_REJECT_OFFSET], _promise[idx + PROMISE_CAPABILITY_OFFSET], reason);
                promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
                promise[idx + PROMISE_REJECT_OFFSET] = void 0;
                promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
              }
            }
          }
          _promise.result = reason;
          _promise.state = PROMISE_REJECTED;
          _promise.reactionLength = 0;
        };
        var createResolvingFunctions = function(promise) {
          var alreadyResolved = false;
          var resolve = function(resolution) {
            var then;
            if (alreadyResolved) {
              return;
            }
            alreadyResolved = true;
            if (resolution === promise) {
              return rejectPromise(promise, new TypeError("Self resolution"));
            }
            if (!ES.TypeIsObject(resolution)) {
              return fulfillPromise(promise, resolution);
            }
            try {
              then = resolution.then;
            } catch (e) {
              return rejectPromise(promise, e);
            }
            if (!ES.IsCallable(then)) {
              return fulfillPromise(promise, resolution);
            }
            enqueue(function() {
              promiseResolveThenableJob(promise, resolution, then);
            });
          };
          var reject = function(reason) {
            if (alreadyResolved) {
              return;
            }
            alreadyResolved = true;
            return rejectPromise(promise, reason);
          };
          return {
            resolve,
            reject
          };
        };
        var optimizedThen = function(then, thenable, resolve, reject) {
          if (then === Promise$prototype$then) {
            _call(then, thenable, resolve, reject, PROMISE_FAKE_CAPABILITY);
          } else {
            _call(then, thenable, resolve, reject);
          }
        };
        var promiseResolveThenableJob = function(promise, thenable, then) {
          var resolvingFunctions = createResolvingFunctions(promise);
          var resolve = resolvingFunctions.resolve;
          var reject = resolvingFunctions.reject;
          try {
            optimizedThen(then, thenable, resolve, reject);
          } catch (e) {
            reject(e);
          }
        };
        var Promise$prototype, Promise$prototype$then;
        var Promise2 = function() {
          var PromiseShim2 = function Promise3(resolver) {
            if (!(this instanceof PromiseShim2)) {
              throw new TypeError('Constructor Promise requires "new"');
            }
            if (this && this._promise) {
              throw new TypeError("Bad construction");
            }
            if (!ES.IsCallable(resolver)) {
              throw new TypeError("not a valid resolver");
            }
            var promise = emulateES6construct(this, PromiseShim2, Promise$prototype, {
              _promise: {
                result: void 0,
                state: PROMISE_PENDING,
                reactionLength: 0,
                fulfillReactionHandler0: void 0,
                rejectReactionHandler0: void 0,
                reactionCapability0: void 0
              }
            });
            var resolvingFunctions = createResolvingFunctions(promise);
            var reject = resolvingFunctions.reject;
            try {
              resolver(resolvingFunctions.resolve, reject);
            } catch (e) {
              reject(e);
            }
            return promise;
          };
          return PromiseShim2;
        }();
        Promise$prototype = Promise2.prototype;
        var _promiseAllResolver = function(index, values, capability, remaining) {
          var alreadyCalled = false;
          return function(x) {
            if (alreadyCalled) {
              return;
            }
            alreadyCalled = true;
            values[index] = x;
            if (--remaining.count === 0) {
              var resolve = capability.resolve;
              resolve(values);
            }
          };
        };
        var performPromiseAll = function(iteratorRecord, C, resultCapability) {
          var it = iteratorRecord.iterator;
          var values = [];
          var remaining = {
            count: 1
          };
          var next, nextValue;
          var index = 0;
          while (true) {
            try {
              next = ES.IteratorStep(it);
              if (next === false) {
                iteratorRecord.done = true;
                break;
              }
              nextValue = next.value;
            } catch (e) {
              iteratorRecord.done = true;
              throw e;
            }
            values[index] = void 0;
            var nextPromise = C.resolve(nextValue);
            var resolveElement = _promiseAllResolver(index, values, resultCapability, remaining);
            remaining.count += 1;
            optimizedThen(nextPromise.then, nextPromise, resolveElement, resultCapability.reject);
            index += 1;
          }
          if (--remaining.count === 0) {
            var resolve = resultCapability.resolve;
            resolve(values);
          }
          return resultCapability.promise;
        };
        var performPromiseRace = function(iteratorRecord, C, resultCapability) {
          var it = iteratorRecord.iterator;
          var next, nextValue, nextPromise;
          while (true) {
            try {
              next = ES.IteratorStep(it);
              if (next === false) {
                iteratorRecord.done = true;
                break;
              }
              nextValue = next.value;
            } catch (e) {
              iteratorRecord.done = true;
              throw e;
            }
            nextPromise = C.resolve(nextValue);
            optimizedThen(nextPromise.then, nextPromise, resultCapability.resolve, resultCapability.reject);
          }
          return resultCapability.promise;
        };
        defineProperties(Promise2, {
          all: function all(iterable) {
            var C = this;
            if (!ES.TypeIsObject(C)) {
              throw new TypeError("Promise is not object");
            }
            var capability = new PromiseCapability(C);
            var iterator, iteratorRecord;
            try {
              iterator = ES.GetIterator(iterable);
              iteratorRecord = {
                iterator,
                done: false
              };
              return performPromiseAll(iteratorRecord, C, capability);
            } catch (e) {
              var exception = e;
              if (iteratorRecord && !iteratorRecord.done) {
                try {
                  ES.IteratorClose(iterator, true);
                } catch (ee) {
                  exception = ee;
                }
              }
              var reject = capability.reject;
              reject(exception);
              return capability.promise;
            }
          },
          race: function race(iterable) {
            var C = this;
            if (!ES.TypeIsObject(C)) {
              throw new TypeError("Promise is not object");
            }
            var capability = new PromiseCapability(C);
            var iterator, iteratorRecord;
            try {
              iterator = ES.GetIterator(iterable);
              iteratorRecord = {
                iterator,
                done: false
              };
              return performPromiseRace(iteratorRecord, C, capability);
            } catch (e) {
              var exception = e;
              if (iteratorRecord && !iteratorRecord.done) {
                try {
                  ES.IteratorClose(iterator, true);
                } catch (ee) {
                  exception = ee;
                }
              }
              var reject = capability.reject;
              reject(exception);
              return capability.promise;
            }
          },
          reject: function reject(reason) {
            var C = this;
            if (!ES.TypeIsObject(C)) {
              throw new TypeError("Bad promise constructor");
            }
            var capability = new PromiseCapability(C);
            var rejectFunc = capability.reject;
            rejectFunc(reason);
            return capability.promise;
          },
          resolve: function resolve(v) {
            var C = this;
            if (!ES.TypeIsObject(C)) {
              throw new TypeError("Bad promise constructor");
            }
            if (ES.IsPromise(v)) {
              var constructor = v.constructor;
              if (constructor === C) {
                return v;
              }
            }
            var capability = new PromiseCapability(C);
            var resolveFunc = capability.resolve;
            resolveFunc(v);
            return capability.promise;
          }
        });
        defineProperties(Promise$prototype, {
          "catch": function(onRejected) {
            return this.then(null, onRejected);
          },
          then: function then(onFulfilled, onRejected) {
            var promise = this;
            if (!ES.IsPromise(promise)) {
              throw new TypeError("not a promise");
            }
            var C = ES.SpeciesConstructor(promise, Promise2);
            var resultCapability;
            var returnValueIsIgnored = arguments.length > 2 && arguments[2] === PROMISE_FAKE_CAPABILITY;
            if (returnValueIsIgnored && C === Promise2) {
              resultCapability = PROMISE_FAKE_CAPABILITY;
            } else {
              resultCapability = new PromiseCapability(C);
            }
            var fulfillReactionHandler = ES.IsCallable(onFulfilled) ? onFulfilled : PROMISE_IDENTITY;
            var rejectReactionHandler = ES.IsCallable(onRejected) ? onRejected : PROMISE_THROWER;
            var _promise = promise._promise;
            var value;
            if (_promise.state === PROMISE_PENDING) {
              if (_promise.reactionLength === 0) {
                _promise.fulfillReactionHandler0 = fulfillReactionHandler;
                _promise.rejectReactionHandler0 = rejectReactionHandler;
                _promise.reactionCapability0 = resultCapability;
              } else {
                var idx = 3 * (_promise.reactionLength - 1);
                _promise[idx + PROMISE_FULFILL_OFFSET] = fulfillReactionHandler;
                _promise[idx + PROMISE_REJECT_OFFSET] = rejectReactionHandler;
                _promise[idx + PROMISE_CAPABILITY_OFFSET] = resultCapability;
              }
              _promise.reactionLength += 1;
            } else if (_promise.state === PROMISE_FULFILLED) {
              value = _promise.result;
              enqueuePromiseReactionJob(fulfillReactionHandler, resultCapability, value);
            } else if (_promise.state === PROMISE_REJECTED) {
              value = _promise.result;
              enqueuePromiseReactionJob(rejectReactionHandler, resultCapability, value);
            } else {
              throw new TypeError("unexpected Promise state");
            }
            return resultCapability.promise;
          }
        });
        PROMISE_FAKE_CAPABILITY = new PromiseCapability(Promise2);
        Promise$prototype$then = Promise$prototype.then;
        return Promise2;
      }();
      if (globals.Promise) {
        delete globals.Promise.accept;
        delete globals.Promise.defer;
        delete globals.Promise.prototype.chain;
      }
      if (typeof PromiseShim === "function") {
        defineProperties(globals, {
          Promise: PromiseShim
        });
        var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function(S) {
          return S.resolve(42).then(function() {
          }) instanceof S;
        });
        var promiseIgnoresNonFunctionThenCallbacks = !throwsError(function() {
          return globals.Promise.reject(42).then(null, 5).then(null, noop);
        });
        var promiseRequiresObjectContext = throwsError(function() {
          return globals.Promise.call(3, noop);
        });
        var promiseResolveBroken = function(Promise2) {
          var p = Promise2.resolve(5);
          p.constructor = {};
          var p2 = Promise2.resolve(p);
          try {
            p2.then(null, noop).then(null, noop);
          } catch (e) {
            return true;
          }
          return p === p2;
        }(globals.Promise);
        var getsThenSynchronously = supportsDescriptors && function() {
          var count = 0;
          var thenable = Object.defineProperty({}, "then", {
            get: function() {
              count += 1;
            }
          });
          Promise.resolve(thenable);
          return count === 1;
        }();
        var BadResolverPromise = function BadResolverPromise2(executor) {
          var p = new Promise(executor);
          executor(3, function() {
          });
          this.then = p.then;
          this.constructor = BadResolverPromise2;
        };
        BadResolverPromise.prototype = Promise.prototype;
        BadResolverPromise.all = Promise.all;
        var hasBadResolverPromise = valueOrFalseIfThrows(function() {
          return !!BadResolverPromise.all([1, 2]);
        });
        if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks || !promiseRequiresObjectContext || promiseResolveBroken || !getsThenSynchronously || hasBadResolverPromise) {
          Promise = PromiseShim;
          overrideNative(globals, "Promise", PromiseShim);
        }
        if (Promise.all.length !== 1) {
          var origAll = Promise.all;
          overrideNative(Promise, "all", function all(iterable) {
            return ES.Call(origAll, this, arguments);
          });
        }
        if (Promise.race.length !== 1) {
          var origRace = Promise.race;
          overrideNative(Promise, "race", function race(iterable) {
            return ES.Call(origRace, this, arguments);
          });
        }
        if (Promise.resolve.length !== 1) {
          var origResolve = Promise.resolve;
          overrideNative(Promise, "resolve", function resolve(x) {
            return ES.Call(origResolve, this, arguments);
          });
        }
        if (Promise.reject.length !== 1) {
          var origReject = Promise.reject;
          overrideNative(Promise, "reject", function reject(r) {
            return ES.Call(origReject, this, arguments);
          });
        }
        ensureEnumerable(Promise, "all");
        ensureEnumerable(Promise, "race");
        ensureEnumerable(Promise, "resolve");
        ensureEnumerable(Promise, "reject");
        addDefaultSpecies(Promise);
      }
      var testOrder = function(a) {
        var b = keys(_reduce(a, function(o, k) {
          o[k] = true;
          return o;
        }, {}));
        return a.join(":") === b.join(":");
      };
      var preservesInsertionOrder = testOrder(["z", "a", "bb"]);
      var preservesNumericInsertionOrder = testOrder(["z", 1, "a", "3", 2]);
      if (supportsDescriptors) {
        var fastkey = function fastkey2(key, skipInsertionOrderCheck) {
          if (!skipInsertionOrderCheck && !preservesInsertionOrder) {
            return null;
          }
          if (isNullOrUndefined(key)) {
            return "^" + ES.ToString(key);
          } else if (typeof key === "string") {
            return "$" + key;
          } else if (typeof key === "number") {
            if (!preservesNumericInsertionOrder) {
              return "n" + key;
            }
            return key;
          } else if (typeof key === "boolean") {
            return "b" + key;
          }
          return null;
        };
        var emptyObject = function emptyObject2() {
          return Object.create ? /* @__PURE__ */ Object.create(null) : {};
        };
        var addIterableToMap = function addIterableToMap2(MapConstructor, map, iterable) {
          if (isArray(iterable) || Type.string(iterable)) {
            _forEach(iterable, function(entry) {
              if (!ES.TypeIsObject(entry)) {
                throw new TypeError("Iterator value " + entry + " is not an entry object");
              }
              map.set(entry[0], entry[1]);
            });
          } else if (iterable instanceof MapConstructor) {
            _call(MapConstructor.prototype.forEach, iterable, function(value, key) {
              map.set(key, value);
            });
          } else {
            var iter, adder;
            if (!isNullOrUndefined(iterable)) {
              adder = map.set;
              if (!ES.IsCallable(adder)) {
                throw new TypeError("bad map");
              }
              iter = ES.GetIterator(iterable);
            }
            if (typeof iter !== "undefined") {
              while (true) {
                var next = ES.IteratorStep(iter);
                if (next === false) {
                  break;
                }
                var nextItem = next.value;
                try {
                  if (!ES.TypeIsObject(nextItem)) {
                    throw new TypeError("Iterator value " + nextItem + " is not an entry object");
                  }
                  _call(adder, map, nextItem[0], nextItem[1]);
                } catch (e) {
                  ES.IteratorClose(iter, true);
                  throw e;
                }
              }
            }
          }
        };
        var addIterableToSet = function addIterableToSet2(SetConstructor, set, iterable) {
          if (isArray(iterable) || Type.string(iterable)) {
            _forEach(iterable, function(value) {
              set.add(value);
            });
          } else if (iterable instanceof SetConstructor) {
            _call(SetConstructor.prototype.forEach, iterable, function(value) {
              set.add(value);
            });
          } else {
            var iter, adder;
            if (!isNullOrUndefined(iterable)) {
              adder = set.add;
              if (!ES.IsCallable(adder)) {
                throw new TypeError("bad set");
              }
              iter = ES.GetIterator(iterable);
            }
            if (typeof iter !== "undefined") {
              while (true) {
                var next = ES.IteratorStep(iter);
                if (next === false) {
                  break;
                }
                var nextValue = next.value;
                try {
                  _call(adder, set, nextValue);
                } catch (e) {
                  ES.IteratorClose(iter, true);
                  throw e;
                }
              }
            }
          }
        };
        var collectionShims = {
          Map: function() {
            var empty = {};
            var MapEntry = function MapEntry2(key, value) {
              this.key = key;
              this.value = value;
              this.next = null;
              this.prev = null;
            };
            MapEntry.prototype.isRemoved = function isRemoved() {
              return this.key === empty;
            };
            var isMap = function isMap2(map) {
              return !!map._es6map;
            };
            var requireMapSlot = function requireMapSlot2(map, method) {
              if (!ES.TypeIsObject(map) || !isMap(map)) {
                throw new TypeError("Method Map.prototype." + method + " called on incompatible receiver " + ES.ToString(map));
              }
            };
            var MapIterator = function MapIterator2(map, kind) {
              requireMapSlot(map, "[[MapIterator]]");
              this.head = map._head;
              this.i = this.head;
              this.kind = kind;
            };
            MapIterator.prototype = {
              isMapIterator: true,
              next: function next() {
                if (!this.isMapIterator) {
                  throw new TypeError("Not a MapIterator");
                }
                var i = this.i;
                var kind = this.kind;
                var head = this.head;
                if (typeof this.i === "undefined") {
                  return iteratorResult();
                }
                while (i.isRemoved() && i !== head) {
                  i = i.prev;
                }
                var result;
                while (i.next !== head) {
                  i = i.next;
                  if (!i.isRemoved()) {
                    if (kind === "key") {
                      result = i.key;
                    } else if (kind === "value") {
                      result = i.value;
                    } else {
                      result = [i.key, i.value];
                    }
                    this.i = i;
                    return iteratorResult(result);
                  }
                }
                this.i = void 0;
                return iteratorResult();
              }
            };
            addIterator(MapIterator.prototype);
            var Map$prototype;
            var MapShim = function Map2() {
              if (!(this instanceof Map2)) {
                throw new TypeError('Constructor Map requires "new"');
              }
              if (this && this._es6map) {
                throw new TypeError("Bad construction");
              }
              var map = emulateES6construct(this, Map2, Map$prototype, {
                _es6map: true,
                _head: null,
                _map: OrigMap ? new OrigMap() : null,
                _size: 0,
                _storage: emptyObject()
              });
              var head = new MapEntry(null, null);
              head.next = head.prev = head;
              map._head = head;
              if (arguments.length > 0) {
                addIterableToMap(Map2, map, arguments[0]);
              }
              return map;
            };
            Map$prototype = MapShim.prototype;
            Value.getter(Map$prototype, "size", function() {
              if (typeof this._size === "undefined") {
                throw new TypeError("size method called on incompatible Map");
              }
              return this._size;
            });
            defineProperties(Map$prototype, {
              get: function get(key) {
                requireMapSlot(this, "get");
                var entry;
                var fkey = fastkey(key, true);
                if (fkey !== null) {
                  entry = this._storage[fkey];
                  if (entry) {
                    return entry.value;
                  } else {
                    return;
                  }
                }
                if (this._map) {
                  entry = origMapGet.call(this._map, key);
                  if (entry) {
                    return entry.value;
                  } else {
                    return;
                  }
                }
                var head = this._head;
                var i = head;
                while ((i = i.next) !== head) {
                  if (ES.SameValueZero(i.key, key)) {
                    return i.value;
                  }
                }
              },
              has: function has(key) {
                requireMapSlot(this, "has");
                var fkey = fastkey(key, true);
                if (fkey !== null) {
                  return typeof this._storage[fkey] !== "undefined";
                }
                if (this._map) {
                  return origMapHas.call(this._map, key);
                }
                var head = this._head;
                var i = head;
                while ((i = i.next) !== head) {
                  if (ES.SameValueZero(i.key, key)) {
                    return true;
                  }
                }
                return false;
              },
              set: function set(key, value) {
                requireMapSlot(this, "set");
                var head = this._head;
                var i = head;
                var entry;
                var fkey = fastkey(key, true);
                if (fkey !== null) {
                  if (typeof this._storage[fkey] !== "undefined") {
                    this._storage[fkey].value = value;
                    return this;
                  } else {
                    entry = this._storage[fkey] = new MapEntry(key, value);
                    i = head.prev;
                  }
                } else if (this._map) {
                  if (origMapHas.call(this._map, key)) {
                    origMapGet.call(this._map, key).value = value;
                  } else {
                    entry = new MapEntry(key, value);
                    origMapSet.call(this._map, key, entry);
                    i = head.prev;
                  }
                }
                while ((i = i.next) !== head) {
                  if (ES.SameValueZero(i.key, key)) {
                    i.value = value;
                    return this;
                  }
                }
                entry = entry || new MapEntry(key, value);
                if (ES.SameValue(-0, key)) {
                  entry.key = 0;
                }
                entry.next = this._head;
                entry.prev = this._head.prev;
                entry.prev.next = entry;
                entry.next.prev = entry;
                this._size += 1;
                return this;
              },
              "delete": function(key) {
                requireMapSlot(this, "delete");
                var head = this._head;
                var i = head;
                var fkey = fastkey(key, true);
                if (fkey !== null) {
                  if (typeof this._storage[fkey] === "undefined") {
                    return false;
                  }
                  i = this._storage[fkey].prev;
                  delete this._storage[fkey];
                } else if (this._map) {
                  if (!origMapHas.call(this._map, key)) {
                    return false;
                  }
                  i = origMapGet.call(this._map, key).prev;
                  origMapDelete.call(this._map, key);
                }
                while ((i = i.next) !== head) {
                  if (ES.SameValueZero(i.key, key)) {
                    i.key = empty;
                    i.value = empty;
                    i.prev.next = i.next;
                    i.next.prev = i.prev;
                    this._size -= 1;
                    return true;
                  }
                }
                return false;
              },
              clear: function clear() {
                requireMapSlot(this, "clear");
                this._map = OrigMap ? new OrigMap() : null;
                this._size = 0;
                this._storage = emptyObject();
                var head = this._head;
                var i = head;
                var p = i.next;
                while ((i = p) !== head) {
                  i.key = empty;
                  i.value = empty;
                  p = i.next;
                  i.next = i.prev = head;
                }
                head.next = head.prev = head;
              },
              keys: function keys2() {
                requireMapSlot(this, "keys");
                return new MapIterator(this, "key");
              },
              values: function values() {
                requireMapSlot(this, "values");
                return new MapIterator(this, "value");
              },
              entries: function entries() {
                requireMapSlot(this, "entries");
                return new MapIterator(this, "key+value");
              },
              forEach: function forEach(callback) {
                requireMapSlot(this, "forEach");
                var context = arguments.length > 1 ? arguments[1] : null;
                var it = this.entries();
                for (var entry = it.next(); !entry.done; entry = it.next()) {
                  if (context) {
                    _call(callback, context, entry.value[1], entry.value[0], this);
                  } else {
                    callback(entry.value[1], entry.value[0], this);
                  }
                }
              }
            });
            addIterator(Map$prototype, Map$prototype.entries);
            return MapShim;
          }(),
          Set: function() {
            var isSet = function isSet2(set) {
              return set._es6set && typeof set._storage !== "undefined";
            };
            var requireSetSlot = function requireSetSlot2(set, method) {
              if (!ES.TypeIsObject(set) || !isSet(set)) {
                throw new TypeError("Set.prototype." + method + " called on incompatible receiver " + ES.ToString(set));
              }
            };
            var Set$prototype;
            var SetShim = function Set2() {
              if (!(this instanceof Set2)) {
                throw new TypeError('Constructor Set requires "new"');
              }
              if (this && this._es6set) {
                throw new TypeError("Bad construction");
              }
              var set = emulateES6construct(this, Set2, Set$prototype, {
                _es6set: true,
                "[[SetData]]": null,
                _storage: emptyObject()
              });
              if (!set._es6set) {
                throw new TypeError("bad set");
              }
              if (arguments.length > 0) {
                addIterableToSet(Set2, set, arguments[0]);
              }
              return set;
            };
            Set$prototype = SetShim.prototype;
            var decodeKey = function(key) {
              var k = key;
              if (k === "^null") {
                return null;
              } else if (k === "^undefined") {
                return void 0;
              } else {
                var first = k.charAt(0);
                if (first === "$") {
                  return _strSlice(k, 1);
                } else if (first === "n") {
                  return +_strSlice(k, 1);
                } else if (first === "b") {
                  return k === "btrue";
                }
              }
              return +k;
            };
            var ensureMap = function ensureMap2(set) {
              if (!set["[[SetData]]"]) {
                var m = new collectionShims.Map();
                set["[[SetData]]"] = m;
                _forEach(keys(set._storage), function(key) {
                  var k = decodeKey(key);
                  m.set(k, k);
                });
                set["[[SetData]]"] = m;
              }
              set._storage = null;
            };
            Value.getter(SetShim.prototype, "size", function() {
              requireSetSlot(this, "size");
              if (this._storage) {
                return keys(this._storage).length;
              }
              ensureMap(this);
              return this["[[SetData]]"].size;
            });
            defineProperties(SetShim.prototype, {
              has: function has(key) {
                requireSetSlot(this, "has");
                var fkey;
                if (this._storage && (fkey = fastkey(key)) !== null) {
                  return !!this._storage[fkey];
                }
                ensureMap(this);
                return this["[[SetData]]"].has(key);
              },
              add: function add(key) {
                requireSetSlot(this, "add");
                var fkey;
                if (this._storage && (fkey = fastkey(key)) !== null) {
                  this._storage[fkey] = true;
                  return this;
                }
                ensureMap(this);
                this["[[SetData]]"].set(key, key);
                return this;
              },
              "delete": function(key) {
                requireSetSlot(this, "delete");
                var fkey;
                if (this._storage && (fkey = fastkey(key)) !== null) {
                  var hasFKey = _hasOwnProperty(this._storage, fkey);
                  return delete this._storage[fkey] && hasFKey;
                }
                ensureMap(this);
                return this["[[SetData]]"]["delete"](key);
              },
              clear: function clear() {
                requireSetSlot(this, "clear");
                if (this._storage) {
                  this._storage = emptyObject();
                }
                if (this["[[SetData]]"]) {
                  this["[[SetData]]"].clear();
                }
              },
              values: function values() {
                requireSetSlot(this, "values");
                ensureMap(this);
                return new SetIterator(this["[[SetData]]"].values());
              },
              entries: function entries() {
                requireSetSlot(this, "entries");
                ensureMap(this);
                return new SetIterator(this["[[SetData]]"].entries());
              },
              forEach: function forEach(callback) {
                requireSetSlot(this, "forEach");
                var context = arguments.length > 1 ? arguments[1] : null;
                var entireSet = this;
                ensureMap(entireSet);
                this["[[SetData]]"].forEach(function(value, key) {
                  if (context) {
                    _call(callback, context, key, key, entireSet);
                  } else {
                    callback(key, key, entireSet);
                  }
                });
              }
            });
            defineProperty(SetShim.prototype, "keys", SetShim.prototype.values, true);
            addIterator(SetShim.prototype, SetShim.prototype.values);
            var SetIterator = function SetIterator2(it) {
              this.it = it;
            };
            SetIterator.prototype = {
              isSetIterator: true,
              next: function next() {
                if (!this.isSetIterator) {
                  throw new TypeError("Not a SetIterator");
                }
                return this.it.next();
              }
            };
            addIterator(SetIterator.prototype);
            return SetShim;
          }()
        };
        var isGoogleTranslate = globals.Set && !Set.prototype["delete"] && Set.prototype.remove && Set.prototype.items && Set.prototype.map && Array.isArray((/* @__PURE__ */ new Set()).keys);
        if (isGoogleTranslate) {
          globals.Set = collectionShims.Set;
        }
        if (globals.Map || globals.Set) {
          var mapAcceptsArguments = valueOrFalseIfThrows(function() {
            return (/* @__PURE__ */ new Map([[1, 2]])).get(1) === 2;
          });
          if (!mapAcceptsArguments) {
            globals.Map = function Map2() {
              if (!(this instanceof Map2)) {
                throw new TypeError('Constructor Map requires "new"');
              }
              var m = new OrigMap();
              if (arguments.length > 0) {
                addIterableToMap(Map2, m, arguments[0]);
              }
              delete m.constructor;
              Object.setPrototypeOf(m, globals.Map.prototype);
              return m;
            };
            globals.Map.prototype = create(OrigMap.prototype);
            defineProperty(globals.Map.prototype, "constructor", globals.Map, true);
            Value.preserveToString(globals.Map, OrigMap);
          }
          var testMap = /* @__PURE__ */ new Map();
          var mapUsesSameValueZero = function() {
            var m = /* @__PURE__ */ new Map([[1, 0], [2, 0], [3, 0], [4, 0]]);
            m.set(-0, m);
            return m.get(0) === m && m.get(-0) === m && m.has(0) && m.has(-0);
          }();
          var mapSupportsChaining = testMap.set(1, 2) === testMap;
          if (!mapUsesSameValueZero || !mapSupportsChaining) {
            overrideNative(Map.prototype, "set", function set(k, v) {
              _call(origMapSet, this, k === 0 ? 0 : k, v);
              return this;
            });
          }
          if (!mapUsesSameValueZero) {
            defineProperties(Map.prototype, {
              get: function get(k) {
                return _call(origMapGet, this, k === 0 ? 0 : k);
              },
              has: function has(k) {
                return _call(origMapHas, this, k === 0 ? 0 : k);
              }
            }, true);
            Value.preserveToString(Map.prototype.get, origMapGet);
            Value.preserveToString(Map.prototype.has, origMapHas);
          }
          var testSet = /* @__PURE__ */ new Set();
          var setUsesSameValueZero = Set.prototype["delete"] && Set.prototype.add && Set.prototype.has && function(s) {
            s["delete"](0);
            s.add(-0);
            return !s.has(0);
          }(testSet);
          var setSupportsChaining = testSet.add(1) === testSet;
          if (!setUsesSameValueZero || !setSupportsChaining) {
            var origSetAdd = Set.prototype.add;
            Set.prototype.add = function add(v) {
              _call(origSetAdd, this, v === 0 ? 0 : v);
              return this;
            };
            Value.preserveToString(Set.prototype.add, origSetAdd);
          }
          if (!setUsesSameValueZero) {
            var origSetHas = Set.prototype.has;
            Set.prototype.has = function has(v) {
              return _call(origSetHas, this, v === 0 ? 0 : v);
            };
            Value.preserveToString(Set.prototype.has, origSetHas);
            var origSetDel = Set.prototype["delete"];
            Set.prototype["delete"] = function SetDelete(v) {
              return _call(origSetDel, this, v === 0 ? 0 : v);
            };
            Value.preserveToString(Set.prototype["delete"], origSetDel);
          }
          var mapSupportsSubclassing = supportsSubclassing(globals.Map, function(M) {
            var m = new M([]);
            m.set(42, 42);
            return m instanceof M;
          });
          var mapFailsToSupportSubclassing = Object.setPrototypeOf && !mapSupportsSubclassing;
          var mapRequiresNew = function() {
            try {
              return !(globals.Map() instanceof globals.Map);
            } catch (e) {
              return e instanceof TypeError;
            }
          }();
          if (globals.Map.length !== 0 || mapFailsToSupportSubclassing || !mapRequiresNew) {
            globals.Map = function Map2() {
              if (!(this instanceof Map2)) {
                throw new TypeError('Constructor Map requires "new"');
              }
              var m = new OrigMap();
              if (arguments.length > 0) {
                addIterableToMap(Map2, m, arguments[0]);
              }
              delete m.constructor;
              Object.setPrototypeOf(m, Map2.prototype);
              return m;
            };
            globals.Map.prototype = OrigMap.prototype;
            defineProperty(globals.Map.prototype, "constructor", globals.Map, true);
            Value.preserveToString(globals.Map, OrigMap);
          }
          var setSupportsSubclassing = supportsSubclassing(globals.Set, function(S) {
            var s = new S([]);
            s.add(42, 42);
            return s instanceof S;
          });
          var setFailsToSupportSubclassing = Object.setPrototypeOf && !setSupportsSubclassing;
          var setRequiresNew = function() {
            try {
              return !(globals.Set() instanceof globals.Set);
            } catch (e) {
              return e instanceof TypeError;
            }
          }();
          if (globals.Set.length !== 0 || setFailsToSupportSubclassing || !setRequiresNew) {
            var OrigSet = globals.Set;
            globals.Set = function Set2() {
              if (!(this instanceof Set2)) {
                throw new TypeError('Constructor Set requires "new"');
              }
              var s = new OrigSet();
              if (arguments.length > 0) {
                addIterableToSet(Set2, s, arguments[0]);
              }
              delete s.constructor;
              Object.setPrototypeOf(s, Set2.prototype);
              return s;
            };
            globals.Set.prototype = OrigSet.prototype;
            defineProperty(globals.Set.prototype, "constructor", globals.Set, true);
            Value.preserveToString(globals.Set, OrigSet);
          }
          var newMap = new globals.Map();
          var mapIterationThrowsStopIterator = !valueOrFalseIfThrows(function() {
            return newMap.keys().next().done;
          });
          if (typeof globals.Map.prototype.clear !== "function" || new globals.Set().size !== 0 || newMap.size !== 0 || typeof globals.Map.prototype.keys !== "function" || typeof globals.Set.prototype.keys !== "function" || typeof globals.Map.prototype.forEach !== "function" || typeof globals.Set.prototype.forEach !== "function" || isCallableWithoutNew(globals.Map) || isCallableWithoutNew(globals.Set) || typeof newMap.keys().next !== "function" || mapIterationThrowsStopIterator || !mapSupportsSubclassing) {
            defineProperties(globals, {
              Map: collectionShims.Map,
              Set: collectionShims.Set
            }, true);
          }
          if (globals.Set.prototype.keys !== globals.Set.prototype.values) {
            defineProperty(globals.Set.prototype, "keys", globals.Set.prototype.values, true);
          }
          addIterator(Object.getPrototypeOf(new globals.Map().keys()));
          addIterator(Object.getPrototypeOf(new globals.Set().keys()));
          if (functionsHaveNames && globals.Set.prototype.has.name !== "has") {
            var anonymousSetHas = globals.Set.prototype.has;
            overrideNative(globals.Set.prototype, "has", function has(key) {
              return _call(anonymousSetHas, this, key);
            });
          }
        }
        defineProperties(globals, collectionShims);
        addDefaultSpecies(globals.Map);
        addDefaultSpecies(globals.Set);
      }
      var throwUnlessTargetIsObject = function throwUnlessTargetIsObject2(target) {
        if (!ES.TypeIsObject(target)) {
          throw new TypeError("target must be an object");
        }
      };
      var ReflectShims = {
        apply: function apply() {
          return ES.Call(ES.Call, null, arguments);
        },
        construct: function construct(constructor, args) {
          if (!ES.IsConstructor(constructor)) {
            throw new TypeError("First argument must be a constructor.");
          }
          var newTarget = arguments.length > 2 ? arguments[2] : constructor;
          if (!ES.IsConstructor(newTarget)) {
            throw new TypeError("new.target must be a constructor.");
          }
          return ES.Construct(constructor, args, newTarget, "internal");
        },
        deleteProperty: function deleteProperty(target, key) {
          throwUnlessTargetIsObject(target);
          if (supportsDescriptors) {
            var desc = Object.getOwnPropertyDescriptor(target, key);
            if (desc && !desc.configurable) {
              return false;
            }
          }
          return delete target[key];
        },
        has: function has(target, key) {
          throwUnlessTargetIsObject(target);
          return key in target;
        }
      };
      if (Object.getOwnPropertyNames) {
        Object.assign(ReflectShims, {
          ownKeys: function ownKeys(target) {
            throwUnlessTargetIsObject(target);
            var keys2 = Object.getOwnPropertyNames(target);
            if (ES.IsCallable(Object.getOwnPropertySymbols)) {
              _pushApply(keys2, Object.getOwnPropertySymbols(target));
            }
            return keys2;
          }
        });
      }
      var callAndCatchException = function ConvertExceptionToBoolean(func) {
        return !throwsError(func);
      };
      if (Object.preventExtensions) {
        Object.assign(ReflectShims, {
          isExtensible: function isExtensible(target) {
            throwUnlessTargetIsObject(target);
            return Object.isExtensible(target);
          },
          preventExtensions: function preventExtensions(target) {
            throwUnlessTargetIsObject(target);
            return callAndCatchException(function() {
              return Object.preventExtensions(target);
            });
          }
        });
      }
      if (supportsDescriptors) {
        var internalGet = function get(target, key, receiver) {
          var desc = Object.getOwnPropertyDescriptor(target, key);
          if (!desc) {
            var parent = Object.getPrototypeOf(target);
            if (parent === null) {
              return void 0;
            }
            return internalGet(parent, key, receiver);
          }
          if ("value" in desc) {
            return desc.value;
          }
          if (desc.get) {
            return ES.Call(desc.get, receiver);
          }
          return void 0;
        };
        var internalSet = function set(target, key, value, receiver) {
          var desc = Object.getOwnPropertyDescriptor(target, key);
          if (!desc) {
            var parent = Object.getPrototypeOf(target);
            if (parent !== null) {
              return internalSet(parent, key, value, receiver);
            }
            desc = {
              value: void 0,
              writable: true,
              enumerable: true,
              configurable: true
            };
          }
          if ("value" in desc) {
            if (!desc.writable) {
              return false;
            }
            if (!ES.TypeIsObject(receiver)) {
              return false;
            }
            var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);
            if (existingDesc) {
              return Reflect2.defineProperty(receiver, key, {
                value
              });
            } else {
              return Reflect2.defineProperty(receiver, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
          if (desc.set) {
            _call(desc.set, receiver, value);
            return true;
          }
          return false;
        };
        Object.assign(ReflectShims, {
          defineProperty: function defineProperty2(target, propertyKey, attributes) {
            throwUnlessTargetIsObject(target);
            return callAndCatchException(function() {
              return Object.defineProperty(target, propertyKey, attributes);
            });
          },
          getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
            throwUnlessTargetIsObject(target);
            return Object.getOwnPropertyDescriptor(target, propertyKey);
          },
          get: function get(target, key) {
            throwUnlessTargetIsObject(target);
            var receiver = arguments.length > 2 ? arguments[2] : target;
            return internalGet(target, key, receiver);
          },
          set: function set(target, key, value) {
            throwUnlessTargetIsObject(target);
            var receiver = arguments.length > 3 ? arguments[3] : target;
            return internalSet(target, key, value, receiver);
          }
        });
      }
      if (Object.getPrototypeOf) {
        var objectDotGetPrototypeOf = Object.getPrototypeOf;
        ReflectShims.getPrototypeOf = function getPrototypeOf(target) {
          throwUnlessTargetIsObject(target);
          return objectDotGetPrototypeOf(target);
        };
      }
      if (Object.setPrototypeOf && ReflectShims.getPrototypeOf) {
        var willCreateCircularPrototype = function(object, lastProto) {
          var proto = lastProto;
          while (proto) {
            if (object === proto) {
              return true;
            }
            proto = ReflectShims.getPrototypeOf(proto);
          }
          return false;
        };
        Object.assign(ReflectShims, {
          setPrototypeOf: function setPrototypeOf(object, proto) {
            throwUnlessTargetIsObject(object);
            if (proto !== null && !ES.TypeIsObject(proto)) {
              throw new TypeError("proto must be an object or null");
            }
            if (proto === Reflect2.getPrototypeOf(object)) {
              return true;
            }
            if (Reflect2.isExtensible && !Reflect2.isExtensible(object)) {
              return false;
            }
            if (willCreateCircularPrototype(object, proto)) {
              return false;
            }
            Object.setPrototypeOf(object, proto);
            return true;
          }
        });
      }
      var defineOrOverrideReflectProperty = function(key, shim) {
        if (!ES.IsCallable(globals.Reflect[key])) {
          defineProperty(globals.Reflect, key, shim);
        } else {
          var acceptsPrimitives = valueOrFalseIfThrows(function() {
            globals.Reflect[key](1);
            globals.Reflect[key](NaN);
            globals.Reflect[key](true);
            return true;
          });
          if (acceptsPrimitives) {
            overrideNative(globals.Reflect, key, shim);
          }
        }
      };
      Object.keys(ReflectShims).forEach(function(key) {
        defineOrOverrideReflectProperty(key, ReflectShims[key]);
      });
      var originalReflectGetProto = globals.Reflect.getPrototypeOf;
      if (functionsHaveNames && originalReflectGetProto && originalReflectGetProto.name !== "getPrototypeOf") {
        overrideNative(globals.Reflect, "getPrototypeOf", function getPrototypeOf(target) {
          return _call(originalReflectGetProto, globals.Reflect, target);
        });
      }
      if (globals.Reflect.setPrototypeOf) {
        if (valueOrFalseIfThrows(function() {
          globals.Reflect.setPrototypeOf(1, {});
          return true;
        })) {
          overrideNative(globals.Reflect, "setPrototypeOf", ReflectShims.setPrototypeOf);
        }
      }
      if (globals.Reflect.defineProperty) {
        if (!valueOrFalseIfThrows(function() {
          var basic = !globals.Reflect.defineProperty(1, "test", {
            value: 1
          });
          var extensible = typeof Object.preventExtensions !== "function" || !globals.Reflect.defineProperty(Object.preventExtensions({}), "test", {});
          return basic && extensible;
        })) {
          overrideNative(globals.Reflect, "defineProperty", ReflectShims.defineProperty);
        }
      }
      if (globals.Reflect.construct) {
        if (!valueOrFalseIfThrows(function() {
          var F = function F2() {
          };
          return globals.Reflect.construct(function() {
          }, [], F) instanceof F;
        })) {
          overrideNative(globals.Reflect, "construct", ReflectShims.construct);
        }
      }
      if (String(new Date(NaN)) !== "Invalid Date") {
        var dateToString = Date.prototype.toString;
        var shimmedDateToString = function toString() {
          var valueOf = +this;
          if (valueOf !== valueOf) {
            return "Invalid Date";
          }
          return ES.Call(dateToString, this);
        };
        overrideNative(Date.prototype, "toString", shimmedDateToString);
      }
      var stringHTMLshims = {
        anchor: function anchor(name) {
          return ES.CreateHTML(this, "a", "name", name);
        },
        big: function big() {
          return ES.CreateHTML(this, "big", "", "");
        },
        blink: function blink() {
          return ES.CreateHTML(this, "blink", "", "");
        },
        bold: function bold() {
          return ES.CreateHTML(this, "b", "", "");
        },
        fixed: function fixed() {
          return ES.CreateHTML(this, "tt", "", "");
        },
        fontcolor: function fontcolor(color) {
          return ES.CreateHTML(this, "font", "color", color);
        },
        fontsize: function fontsize(size) {
          return ES.CreateHTML(this, "font", "size", size);
        },
        italics: function italics() {
          return ES.CreateHTML(this, "i", "", "");
        },
        link: function link(url) {
          return ES.CreateHTML(this, "a", "href", url);
        },
        small: function small() {
          return ES.CreateHTML(this, "small", "", "");
        },
        strike: function strike() {
          return ES.CreateHTML(this, "strike", "", "");
        },
        sub: function sub() {
          return ES.CreateHTML(this, "sub", "", "");
        },
        sup: function sub() {
          return ES.CreateHTML(this, "sup", "", "");
        }
      };
      _forEach(Object.keys(stringHTMLshims), function(key) {
        var method = String.prototype[key];
        var shouldOverwrite = false;
        if (ES.IsCallable(method)) {
          var output = _call(method, "", ' " ');
          var quotesCount = _concat([], output.match(/"/g)).length;
          shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;
        } else {
          shouldOverwrite = true;
        }
        if (shouldOverwrite) {
          overrideNative(String.prototype, key, stringHTMLshims[key]);
        }
      });
      var JSONstringifiesSymbols = function() {
        if (!hasSymbols) {
          return false;
        }
        var stringify = typeof JSON === "object" && typeof JSON.stringify === "function" ? JSON.stringify : null;
        if (!stringify) {
          return false;
        }
        if (typeof stringify(Symbol2()) !== "undefined") {
          return true;
        }
        if (stringify([Symbol2()]) !== "[null]") {
          return true;
        }
        var obj = {
          a: Symbol2()
        };
        obj[Symbol2()] = true;
        if (stringify(obj) !== "{}") {
          return true;
        }
        return false;
      }();
      var JSONstringifyAcceptsObjectSymbol = valueOrFalseIfThrows(function() {
        if (!hasSymbols) {
          return true;
        }
        return JSON.stringify(Object(Symbol2())) === "{}" && JSON.stringify([Object(Symbol2())]) === "[{}]";
      });
      if (JSONstringifiesSymbols || !JSONstringifyAcceptsObjectSymbol) {
        var origStringify = JSON.stringify;
        overrideNative(JSON, "stringify", function stringify(value) {
          if (typeof value === "symbol") {
            return;
          }
          var replacer;
          if (arguments.length > 1) {
            replacer = arguments[1];
          }
          var args = [value];
          if (!isArray(replacer)) {
            var replaceFn = ES.IsCallable(replacer) ? replacer : null;
            var wrappedReplacer = function(key, val) {
              var parsedValue = replaceFn ? _call(replaceFn, this, key, val) : val;
              if (typeof parsedValue !== "symbol") {
                if (Type.symbol(parsedValue)) {
                  return assignTo({})(parsedValue);
                } else {
                  return parsedValue;
                }
              }
            };
            args.push(wrappedReplacer);
          } else {
            args.push(replacer);
          }
          if (arguments.length > 2) {
            args.push(arguments[2]);
          }
          return origStringify.apply(this, args);
        });
      }
      return globals;
    });
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({
        toString: null
      }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", {
            value: 1
          });
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", {
          value: 1
        }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
    var defineProperty = function(object, name, value, predicate) {
      if (name in object && (!isFunction(predicate) || !predicate())) {
        return;
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name] = value;
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/functions-have-names/index.js
var require_functions_have_names = __commonJS({
  "node_modules/functions-have-names/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var functionsHaveNames = function functionsHaveNames2() {
      return typeof function f() {
      }.name === "string";
    };
    var gOPD = Object.getOwnPropertyDescriptor;
    if (gOPD) {
      try {
        gOPD([], "length");
      } catch (e) {
        gOPD = null;
      }
    }
    functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
      if (!functionsHaveNames() || !gOPD) {
        return false;
      }
      var desc = gOPD(function() {
      }, "name");
      return !!desc && !!desc.configurable;
    };
    var $bind = Function.prototype.bind;
    functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
      return functionsHaveNames() && typeof $bind === "function" && function f() {
      }.bind().name !== "";
    };
    module.exports = functionsHaveNames;
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var documentDotAll = typeof document === "object" && typeof document.all === "undefined" && document.all !== void 0 ? document.all : {};
    module.exports = reflectApply ? function isCallable(value) {
      if (value === documentDotAll) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (typeof value === "function" && !value.prototype) {
        return true;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value);
    } : function isCallable(value) {
      if (value === documentDotAll) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (typeof value === "function" && !value.prototype) {
        return true;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      return strClass === fnClass || strClass === genClass;
    };
  }
});

// node_modules/es-abstract/2021/IsCallable.js
var require_IsCallable = __commonJS({
  "node_modules/es-abstract/2021/IsCallable.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = require_is_callable();
  }
});

// node_modules/function.prototype.name/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function.prototype.name/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var IsCallable = require_IsCallable();
    var functionsHaveNames = require_functions_have_names()();
    var callBound = require_callBound();
    var $functionToString = callBound("Function.prototype.toString");
    var $stringMatch = callBound("String.prototype.match");
    var classRegex = /^class /;
    var isClass = function isClassConstructor(fn) {
      if (IsCallable(fn)) {
        return false;
      }
      if (typeof fn !== "function") {
        return false;
      }
      try {
        var match = $stringMatch($functionToString(fn), classRegex);
        return !!match;
      } catch (e) {
      }
      return false;
    };
    var regex = /\s*function\s+([^(\s]*)\s*/;
    var functionProto = Function.prototype;
    module.exports = function getName() {
      if (!isClass(this) && !IsCallable(this)) {
        throw new TypeError("Function.prototype.name sham getter called on non-function");
      }
      if (functionsHaveNames) {
        return this.name;
      }
      if (this === functionProto) {
        return "";
      }
      var str = $functionToString(this);
      var match = $stringMatch(str, regex);
      var name = match && match[1];
      return name;
    };
  }
});

// node_modules/function.prototype.name/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/function.prototype.name/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation2();
    module.exports = function getPolyfill() {
      return implementation;
    };
  }
});

// node_modules/function.prototype.name/shim.js
var require_shim = __commonJS({
  "node_modules/function.prototype.name/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var functionsHaveNames = require_functions_have_names()();
    var getPolyfill = require_polyfill();
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    module.exports = function shimName() {
      var polyfill = getPolyfill();
      if (functionsHaveNames) {
        return polyfill;
      }
      if (!supportsDescriptors) {
        throw new TypeErr("Shimming Function.prototype.name support requires ES5 property descriptor support.");
      }
      var functionProto = Function.prototype;
      defineProperty(functionProto, "name", {
        configurable: true,
        enumerable: false,
        get: function() {
          var name = polyfill.call(this);
          if (this !== functionProto) {
            defineProperty(this, "name", {
              configurable: true,
              enumerable: false,
              value: name,
              writable: false
            });
          }
          return name;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/es-abstract/2021/abs.js
var require_abs = __commonJS({
  "node_modules/es-abstract/2021/abs.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $abs = GetIntrinsic("%Math.abs%");
    module.exports = function abs(x) {
      return $abs(x);
    };
  }
});

// node_modules/es-abstract/2021/floor.js
var require_floor = __commonJS({
  "node_modules/es-abstract/2021/floor.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var $floor = Math.floor;
    module.exports = function floor(x) {
      return $floor(x);
    };
  }
});

// node_modules/es-abstract/helpers/regexTester.js
var require_regexTester = __commonJS({
  "node_modules/es-abstract/helpers/regexTester.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var callBound = require_callBound();
    var $exec = callBound("RegExp.prototype.exec");
    module.exports = function regexTester(regex) {
      return function test(s) {
        return $exec(regex, s) !== null;
      };
    };
  }
});

// node_modules/es-abstract/helpers/isPrimitive.js
var require_isPrimitive = __commonJS({
  "node_modules/es-abstract/helpers/isPrimitive.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// node_modules/es-to-primitive/helpers/isPrimitive.js
var require_isPrimitive2 = __commonJS({
  "node_modules/es-to-primitive/helpers/isPrimitive.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "node_modules/is-date-object/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
      try {
        getDay.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag = require_shams2()();
    module.exports = function isDateObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };
  }
});

// node_modules/es-to-primitive/es2015.js
var require_es2015 = __commonJS({
  "node_modules/es-to-primitive/es2015.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "symbol";
    var isPrimitive = require_isPrimitive2();
    var isCallable = require_is_callable();
    var isDate = require_is_date_object();
    var isSymbol = require_is_symbol();
    var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
      if (typeof O === "undefined" || O === null) {
        throw new TypeError("Cannot call method on " + O);
      }
      if (typeof hint !== "string" || hint !== "number" && hint !== "string") {
        throw new TypeError('hint must be "string" or "number"');
      }
      var methodNames = hint === "string" ? ["toString", "valueOf"] : ["valueOf", "toString"];
      var method, result, i;
      for (i = 0; i < methodNames.length; ++i) {
        method = O[methodNames[i]];
        if (isCallable(method)) {
          result = method.call(O);
          if (isPrimitive(result)) {
            return result;
          }
        }
      }
      throw new TypeError("No default value");
    };
    var GetMethod = function GetMethod2(O, P) {
      var func = O[P];
      if (func !== null && typeof func !== "undefined") {
        if (!isCallable(func)) {
          throw new TypeError(func + " returned for property " + P + " of object " + O + " is not a function");
        }
        return func;
      }
      return void 0;
    };
    module.exports = function ToPrimitive(input) {
      if (isPrimitive(input)) {
        return input;
      }
      var hint = "default";
      if (arguments.length > 1) {
        if (arguments[1] === String) {
          hint = "string";
        } else if (arguments[1] === Number) {
          hint = "number";
        }
      }
      var exoticToPrim;
      if (hasSymbols) {
        if (Symbol.toPrimitive) {
          exoticToPrim = GetMethod(input, Symbol.toPrimitive);
        } else if (isSymbol(input)) {
          exoticToPrim = Symbol.prototype.valueOf;
        }
      }
      if (typeof exoticToPrim !== "undefined") {
        var result = exoticToPrim.call(input, hint);
        if (isPrimitive(result)) {
          return result;
        }
        throw new TypeError("unable to convert exotic object to primitive");
      }
      if (hint === "default" && (isDate(input) || isSymbol(input))) {
        hint = "string";
      }
      return ordinaryToPrimitive(input, hint === "default" ? "number" : hint);
    };
  }
});

// node_modules/es-abstract/2021/ToPrimitive.js
var require_ToPrimitive = __commonJS({
  "node_modules/es-abstract/2021/ToPrimitive.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var toPrimitive = require_es2015();
    module.exports = function ToPrimitive(input) {
      if (arguments.length > 1) {
        return toPrimitive(input, arguments[1]);
      }
      return toPrimitive(input);
    };
  }
});

// node_modules/es-abstract/2021/ToNumber.js
var require_ToNumber = __commonJS({
  "node_modules/es-abstract/2021/ToNumber.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $Number = GetIntrinsic("%Number%");
    var $RegExp = GetIntrinsic("%RegExp%");
    var $parseInteger = GetIntrinsic("%parseInt%");
    var callBound = require_callBound();
    var regexTester = require_regexTester();
    var isPrimitive = require_isPrimitive();
    var $strSlice = callBound("String.prototype.slice");
    var isBinary = regexTester(/^0b[01]+$/i);
    var isOctal = regexTester(/^0o[0-7]+$/i);
    var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
    var nonWS = ["\x85", "\u200B", "\uFFFE"].join("");
    var nonWSregex = new $RegExp("[" + nonWS + "]", "g");
    var hasNonWS = regexTester(nonWSregex);
    var ws = ["	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003", "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028", "\u2029\uFEFF"].join("");
    var trimRegex = new RegExp("(^[" + ws + "]+)|([" + ws + "]+$)", "g");
    var $replace = callBound("String.prototype.replace");
    var $trim = function(value) {
      return $replace(value, trimRegex, "");
    };
    var ToPrimitive = require_ToPrimitive();
    module.exports = function ToNumber(argument) {
      var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
      if (typeof value === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a number");
      }
      if (typeof value === "bigint") {
        throw new $TypeError("Conversion from 'BigInt' to 'number' is not allowed.");
      }
      if (typeof value === "string") {
        if (isBinary(value)) {
          return ToNumber($parseInteger($strSlice(value, 2), 2));
        } else if (isOctal(value)) {
          return ToNumber($parseInteger($strSlice(value, 2), 8));
        } else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
          return NaN;
        }
        var trimmed = $trim(value);
        if (trimmed !== value) {
          return ToNumber(trimmed);
        }
      }
      return $Number(value);
    };
  }
});

// node_modules/es-abstract/helpers/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/es-abstract/helpers/isNaN.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/es-abstract/helpers/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/es-abstract/helpers/isFinite.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var $isNaN = Number.isNaN || function(a) {
      return a !== a;
    };
    module.exports = Number.isFinite || function(x) {
      return typeof x === "number" && !$isNaN(x) && x !== Infinity && x !== -Infinity;
    };
  }
});

// node_modules/es-abstract/helpers/sign.js
var require_sign = __commonJS({
  "node_modules/es-abstract/helpers/sign.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = function sign(number) {
      return number >= 0 ? 1 : -1;
    };
  }
});

// node_modules/es-abstract/2021/ToIntegerOrInfinity.js
var require_ToIntegerOrInfinity = __commonJS({
  "node_modules/es-abstract/2021/ToIntegerOrInfinity.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var abs = require_abs();
    var floor = require_floor();
    var ToNumber = require_ToNumber();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    var $sign = require_sign();
    module.exports = function ToIntegerOrInfinity(value) {
      var number = ToNumber(value);
      if ($isNaN(number) || number === 0) {
        return 0;
      }
      if (!$isFinite(number)) {
        return number;
      }
      return $sign(number) * floor(abs(number));
    };
  }
});

// node_modules/es-abstract/helpers/maxSafeInteger.js
var require_maxSafeInteger = __commonJS({
  "node_modules/es-abstract/helpers/maxSafeInteger.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $Math = GetIntrinsic("%Math%");
    var $Number = GetIntrinsic("%Number%");
    module.exports = $Number.MAX_SAFE_INTEGER || $Math.pow(2, 53) - 1;
  }
});

// node_modules/es-abstract/2021/ToLength.js
var require_ToLength = __commonJS({
  "node_modules/es-abstract/2021/ToLength.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var ToIntegerOrInfinity = require_ToIntegerOrInfinity();
    module.exports = function ToLength(argument) {
      var len = ToIntegerOrInfinity(argument);
      if (len <= 0) {
        return 0;
      }
      if (len > MAX_SAFE_INTEGER) {
        return MAX_SAFE_INTEGER;
      }
      return len;
    };
  }
});

// node_modules/es-abstract/5/CheckObjectCoercible.js
var require_CheckObjectCoercible = __commonJS({
  "node_modules/es-abstract/5/CheckObjectCoercible.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    module.exports = function CheckObjectCoercible(value, optMessage) {
      if (value == null) {
        throw new $TypeError(optMessage || "Cannot call method on " + value);
      }
      return value;
    };
  }
});

// node_modules/es-abstract/2021/RequireObjectCoercible.js
var require_RequireObjectCoercible = __commonJS({
  "node_modules/es-abstract/2021/RequireObjectCoercible.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = require_CheckObjectCoercible();
  }
});

// node_modules/es-abstract/2021/ToObject.js
var require_ToObject = __commonJS({
  "node_modules/es-abstract/2021/ToObject.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $Object = GetIntrinsic("%Object%");
    var RequireObjectCoercible = require_RequireObjectCoercible();
    module.exports = function ToObject(value) {
      RequireObjectCoercible(value);
      return $Object(value);
    };
  }
});

// node_modules/es-abstract/2021/SameValueZero.js
var require_SameValueZero = __commonJS({
  "node_modules/es-abstract/2021/SameValueZero.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var $isNaN = require_isNaN();
    module.exports = function SameValueZero(x, y) {
      return x === y || $isNaN(x) && $isNaN(y);
    };
  }
});

// node_modules/is-string/index.js
var require_is_string = __commonJS({
  "node_modules/is-string/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var strValue = String.prototype.valueOf;
    var tryStringObject = function tryStringObject2(value) {
      try {
        strValue.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var strClass = "[object String]";
    var hasToStringTag = require_shams2()();
    module.exports = function isString(value) {
      if (typeof value === "string") {
        return true;
      }
      if (typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
    };
  }
});

// node_modules/array-includes/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/array-includes/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var ToIntegerOrInfinity = require_ToIntegerOrInfinity();
    var ToLength = require_ToLength();
    var ToObject = require_ToObject();
    var SameValueZero = require_SameValueZero();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var isString = require_is_string();
    var $charAt = callBound("String.prototype.charAt");
    var $indexOf = GetIntrinsic("%Array.prototype.indexOf%");
    var $max = GetIntrinsic("%Math.max%");
    module.exports = function includes(searchElement) {
      var fromIndex = arguments.length > 1 ? ToIntegerOrInfinity(arguments[1]) : 0;
      if ($indexOf && !$isNaN(searchElement) && $isFinite(fromIndex) && typeof searchElement !== "undefined") {
        return $indexOf.apply(this, arguments) > -1;
      }
      var O = ToObject(this);
      var length = ToLength(O.length);
      if (length === 0) {
        return false;
      }
      var k = fromIndex >= 0 ? fromIndex : $max(0, length + fromIndex);
      while (k < length) {
        if (SameValueZero(searchElement, isString(O) ? $charAt(O, k) : O[k])) {
          return true;
        }
        k += 1;
      }
      return false;
    };
  }
});

// node_modules/array-includes/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/array-includes/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation3();
    module.exports = function getPolyfill() {
      if (Array.prototype.includes && Array(1).includes(void 0)) {
        return Array.prototype.includes;
      }
      return implementation;
    };
  }
});

// node_modules/array-includes/shim.js
var require_shim2 = __commonJS({
  "node_modules/array-includes/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill2();
    module.exports = function shimArrayPrototypeIncludes() {
      var polyfill = getPolyfill();
      define2(Array.prototype, {
        includes: polyfill
      }, {
        includes: function() {
          return Array.prototype.includes !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object.values/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/object.values/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var $push = callBound("Array.prototype.push");
    module.exports = function values(O) {
      var obj = RequireObjectCoercible(O);
      var vals = [];
      for (var key in obj) {
        if ($isEnumerable(obj, key)) {
          $push(vals, obj[key]);
        }
      }
      return vals;
    };
  }
});

// node_modules/object.values/polyfill.js
var require_polyfill3 = __commonJS({
  "node_modules/object.values/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation4();
    module.exports = function getPolyfill() {
      return typeof Object.values === "function" ? Object.values : implementation;
    };
  }
});

// node_modules/object.values/shim.js
var require_shim3 = __commonJS({
  "node_modules/object.values/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var getPolyfill = require_polyfill3();
    var define2 = require_define_properties();
    module.exports = function shimValues() {
      var polyfill = getPolyfill();
      define2(Object, {
        values: polyfill
      }, {
        values: function testValues() {
          return Object.values !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object.entries/implementation.js
var require_implementation5 = __commonJS({
  "node_modules/object.entries/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var $push = callBound("Array.prototype.push");
    module.exports = function entries(O) {
      var obj = RequireObjectCoercible(O);
      var entrys = [];
      for (var key in obj) {
        if ($isEnumerable(obj, key)) {
          $push(entrys, [key, obj[key]]);
        }
      }
      return entrys;
    };
  }
});

// node_modules/object.entries/polyfill.js
var require_polyfill4 = __commonJS({
  "node_modules/object.entries/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation5();
    module.exports = function getPolyfill() {
      return typeof Object.entries === "function" ? Object.entries : implementation;
    };
  }
});

// node_modules/object.entries/shim.js
var require_shim4 = __commonJS({
  "node_modules/object.entries/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var getPolyfill = require_polyfill4();
    var define2 = require_define_properties();
    module.exports = function shimEntries() {
      var polyfill = getPolyfill();
      define2(Object, {
        entries: polyfill
      }, {
        entries: function testEntries() {
          return Object.entries !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/es-abstract/2021/ToString.js
var require_ToString = __commonJS({
  "node_modules/es-abstract/2021/ToString.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $String = GetIntrinsic("%String%");
    var $TypeError = GetIntrinsic("%TypeError%");
    module.exports = function ToString(argument) {
      if (typeof argument === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a string");
      }
      return $String(argument);
    };
  }
});

// node_modules/string.prototype.padstart/implementation.js
var require_implementation6 = __commonJS({
  "node_modules/string.prototype.padstart/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var ToLength = require_ToLength();
    var ToString = require_ToString();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var $slice = callBound("String.prototype.slice");
    module.exports = function padStart(maxLength) {
      var O = RequireObjectCoercible(this);
      var S = ToString(O);
      var stringLength = ToLength(S.length);
      var fillString;
      if (arguments.length > 1) {
        fillString = arguments[1];
      }
      var filler = typeof fillString === "undefined" ? "" : ToString(fillString);
      if (filler === "") {
        filler = " ";
      }
      var intMaxLength = ToLength(maxLength);
      if (intMaxLength <= stringLength) {
        return S;
      }
      var fillLen = intMaxLength - stringLength;
      while (filler.length < fillLen) {
        var fLen = filler.length;
        var remainingCodeUnits = fillLen - fLen;
        filler += fLen > remainingCodeUnits ? $slice(filler, 0, remainingCodeUnits) : filler;
      }
      var truncatedStringFiller = filler.length > fillLen ? $slice(filler, 0, fillLen) : filler;
      return truncatedStringFiller + S;
    };
  }
});

// node_modules/string.prototype.padstart/polyfill.js
var require_polyfill5 = __commonJS({
  "node_modules/string.prototype.padstart/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation6();
    module.exports = function getPolyfill() {
      return typeof String.prototype.padStart === "function" ? String.prototype.padStart : implementation;
    };
  }
});

// node_modules/string.prototype.padstart/shim.js
var require_shim5 = __commonJS({
  "node_modules/string.prototype.padstart/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var getPolyfill = require_polyfill5();
    var define2 = require_define_properties();
    module.exports = function shimPadStart() {
      var polyfill = getPolyfill();
      define2(String.prototype, {
        padStart: polyfill
      }, {
        padStart: function testPadStart() {
          return String.prototype.padStart !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/string.prototype.padend/implementation.js
var require_implementation7 = __commonJS({
  "node_modules/string.prototype.padend/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var ToLength = require_ToLength();
    var ToString = require_ToString();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var $slice = callBound("String.prototype.slice");
    module.exports = function padEnd(maxLength) {
      var O = RequireObjectCoercible(this);
      var S = ToString(O);
      var stringLength = ToLength(S.length);
      var fillString;
      if (arguments.length > 1) {
        fillString = arguments[1];
      }
      var filler = typeof fillString === "undefined" ? "" : ToString(fillString);
      if (filler === "") {
        filler = " ";
      }
      var intMaxLength = ToLength(maxLength);
      if (intMaxLength <= stringLength) {
        return S;
      }
      var fillLen = intMaxLength - stringLength;
      while (filler.length < fillLen) {
        var fLen = filler.length;
        var remainingCodeUnits = fillLen - fLen;
        filler += fLen > remainingCodeUnits ? $slice(filler, 0, remainingCodeUnits) : filler;
      }
      var truncatedStringFiller = filler.length > fillLen ? $slice(filler, 0, fillLen) : filler;
      return S + truncatedStringFiller;
    };
  }
});

// node_modules/string.prototype.padend/polyfill.js
var require_polyfill6 = __commonJS({
  "node_modules/string.prototype.padend/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation7();
    module.exports = function getPolyfill() {
      return typeof String.prototype.padEnd === "function" ? String.prototype.padEnd : implementation;
    };
  }
});

// node_modules/string.prototype.padend/shim.js
var require_shim6 = __commonJS({
  "node_modules/string.prototype.padend/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var getPolyfill = require_polyfill6();
    var define2 = require_define_properties();
    module.exports = function shimPadEnd() {
      var polyfill = getPolyfill();
      define2(String.prototype, {
        padEnd: polyfill
      }, {
        padEnd: function testPadEnd() {
          return String.prototype.padEnd !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/es-abstract/helpers/IsArray.js
var require_IsArray = __commonJS({
  "node_modules/es-abstract/helpers/IsArray.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $Array = GetIntrinsic("%Array%");
    var toStr = !$Array.isArray && require_callBound()("Object.prototype.toString");
    module.exports = $Array.isArray || function IsArray(argument) {
      return toStr(argument) === "[object Array]";
    };
  }
});

// node_modules/es-abstract/helpers/DefineOwnProperty.js
var require_DefineOwnProperty = __commonJS({
  "node_modules/es-abstract/helpers/DefineOwnProperty.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var hasPropertyDescriptors = require_has_property_descriptors();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors() && GetIntrinsic("%Object.defineProperty%", true);
    var hasArrayLengthDefineBug = hasPropertyDescriptors.hasArrayLengthDefineBug();
    var isArray = hasArrayLengthDefineBug && require_IsArray();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    module.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {
      if (!$defineProperty) {
        if (!IsDataDescriptor(desc)) {
          return false;
        }
        if (!desc["[[Configurable]]"] || !desc["[[Writable]]"]) {
          return false;
        }
        if (P in O && $isEnumerable(O, P) !== !!desc["[[Enumerable]]"]) {
          return false;
        }
        var V = desc["[[Value]]"];
        O[P] = V;
        return SameValue(O[P], V);
      }
      if (hasArrayLengthDefineBug && P === "length" && "[[Value]]" in desc && isArray(O) && O.length !== desc["[[Value]]"]) {
        O.length = desc["[[Value]]"];
        return O.length === desc["[[Value]]"];
      }
      $defineProperty(O, P, FromPropertyDescriptor(desc));
      return true;
    };
  }
});

// node_modules/es-abstract/helpers/isMatchRecord.js
var require_isMatchRecord = __commonJS({
  "node_modules/es-abstract/helpers/isMatchRecord.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var has = require_src();
    module.exports = function isMatchRecord(record) {
      return has(record, "[[StartIndex]]") && has(record, "[[EndIndex]]") && record["[[StartIndex]]"] >= 0 && record["[[EndIndex]]"] >= record["[[StartIndex]]"] && String(parseInt(record["[[StartIndex]]"], 10)) === String(record["[[StartIndex]]"]) && String(parseInt(record["[[EndIndex]]"], 10)) === String(record["[[EndIndex]]"]);
    };
  }
});

// node_modules/es-abstract/helpers/assertRecord.js
var require_assertRecord = __commonJS({
  "node_modules/es-abstract/helpers/assertRecord.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var has = require_src();
    var isMatchRecord = require_isMatchRecord();
    var predicates = {
      "Property Descriptor": function isPropertyDescriptor(Desc) {
        var allowed = {
          "[[Configurable]]": true,
          "[[Enumerable]]": true,
          "[[Get]]": true,
          "[[Set]]": true,
          "[[Value]]": true,
          "[[Writable]]": true
        };
        for (var key in Desc) {
          if (has(Desc, key) && !allowed[key]) {
            return false;
          }
        }
        var isData = has(Desc, "[[Value]]");
        var IsAccessor = has(Desc, "[[Get]]") || has(Desc, "[[Set]]");
        if (isData && IsAccessor) {
          throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
        }
        return true;
      },
      "Match Record": isMatchRecord
    };
    module.exports = function assertRecord(Type, recordType, argumentName, value) {
      var predicate = predicates[recordType];
      if (typeof predicate !== "function") {
        throw new $SyntaxError("unknown record type: " + recordType);
      }
      if (Type(value) !== "Object" || !predicate(value)) {
        throw new $TypeError(argumentName + " must be a " + recordType);
      }
    };
  }
});

// node_modules/es-abstract/helpers/fromPropertyDescriptor.js
var require_fromPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/fromPropertyDescriptor.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = function fromPropertyDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return Desc;
      }
      var obj = {};
      if ("[[Value]]" in Desc) {
        obj.value = Desc["[[Value]]"];
      }
      if ("[[Writable]]" in Desc) {
        obj.writable = !!Desc["[[Writable]]"];
      }
      if ("[[Get]]" in Desc) {
        obj.get = Desc["[[Get]]"];
      }
      if ("[[Set]]" in Desc) {
        obj.set = Desc["[[Set]]"];
      }
      if ("[[Enumerable]]" in Desc) {
        obj.enumerable = !!Desc["[[Enumerable]]"];
      }
      if ("[[Configurable]]" in Desc) {
        obj.configurable = !!Desc["[[Configurable]]"];
      }
      return obj;
    };
  }
});

// node_modules/es-abstract/5/Type.js
var require_Type = __commonJS({
  "node_modules/es-abstract/5/Type.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = function Type(x) {
      if (x === null) {
        return "Null";
      }
      if (typeof x === "undefined") {
        return "Undefined";
      }
      if (typeof x === "function" || typeof x === "object") {
        return "Object";
      }
      if (typeof x === "number") {
        return "Number";
      }
      if (typeof x === "boolean") {
        return "Boolean";
      }
      if (typeof x === "string") {
        return "String";
      }
    };
  }
});

// node_modules/es-abstract/2021/Type.js
var require_Type2 = __commonJS({
  "node_modules/es-abstract/2021/Type.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var ES5Type = require_Type();
    module.exports = function Type(x) {
      if (typeof x === "symbol") {
        return "Symbol";
      }
      if (typeof x === "bigint") {
        return "BigInt";
      }
      return ES5Type(x);
    };
  }
});

// node_modules/es-abstract/2021/FromPropertyDescriptor.js
var require_FromPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/2021/FromPropertyDescriptor.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var assertRecord = require_assertRecord();
    var fromPropertyDescriptor = require_fromPropertyDescriptor();
    var Type = require_Type2();
    module.exports = function FromPropertyDescriptor(Desc) {
      if (typeof Desc !== "undefined") {
        assertRecord(Type, "Property Descriptor", "Desc", Desc);
      }
      return fromPropertyDescriptor(Desc);
    };
  }
});

// node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
var require_getOwnPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/es-abstract/2021/IsArray.js
var require_IsArray2 = __commonJS({
  "node_modules/es-abstract/2021/IsArray.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = require_IsArray();
  }
});

// node_modules/es-abstract/2021/IsPropertyKey.js
var require_IsPropertyKey = __commonJS({
  "node_modules/es-abstract/2021/IsPropertyKey.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = function IsPropertyKey(argument) {
      return typeof argument === "string" || typeof argument === "symbol";
    };
  }
});

// node_modules/es-abstract/2021/ToBoolean.js
var require_ToBoolean = __commonJS({
  "node_modules/es-abstract/2021/ToBoolean.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = function ToBoolean(value) {
      return !!value;
    };
  }
});

// node_modules/es-abstract/2021/IsRegExp.js
var require_IsRegExp = __commonJS({
  "node_modules/es-abstract/2021/IsRegExp.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $match = GetIntrinsic("%Symbol.match%", true);
    var hasRegExpMatcher = require_is_regex();
    var ToBoolean = require_ToBoolean();
    module.exports = function IsRegExp(argument) {
      if (!argument || typeof argument !== "object") {
        return false;
      }
      if ($match) {
        var isRegExp = argument[$match];
        if (typeof isRegExp !== "undefined") {
          return ToBoolean(isRegExp);
        }
      }
      return hasRegExpMatcher(argument);
    };
  }
});

// node_modules/es-abstract/2021/ToPropertyDescriptor.js
var require_ToPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/2021/ToPropertyDescriptor.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var has = require_src();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Type = require_Type2();
    var ToBoolean = require_ToBoolean();
    var IsCallable = require_IsCallable();
    module.exports = function ToPropertyDescriptor(Obj) {
      if (Type(Obj) !== "Object") {
        throw new $TypeError("ToPropertyDescriptor requires an object");
      }
      var desc = {};
      if (has(Obj, "enumerable")) {
        desc["[[Enumerable]]"] = ToBoolean(Obj.enumerable);
      }
      if (has(Obj, "configurable")) {
        desc["[[Configurable]]"] = ToBoolean(Obj.configurable);
      }
      if (has(Obj, "value")) {
        desc["[[Value]]"] = Obj.value;
      }
      if (has(Obj, "writable")) {
        desc["[[Writable]]"] = ToBoolean(Obj.writable);
      }
      if (has(Obj, "get")) {
        var getter = Obj.get;
        if (typeof getter !== "undefined" && !IsCallable(getter)) {
          throw new $TypeError("getter must be a function");
        }
        desc["[[Get]]"] = getter;
      }
      if (has(Obj, "set")) {
        var setter = Obj.set;
        if (typeof setter !== "undefined" && !IsCallable(setter)) {
          throw new $TypeError("setter must be a function");
        }
        desc["[[Set]]"] = setter;
      }
      if ((has(desc, "[[Get]]") || has(desc, "[[Set]]")) && (has(desc, "[[Value]]") || has(desc, "[[Writable]]"))) {
        throw new $TypeError("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
      }
      return desc;
    };
  }
});

// node_modules/es-abstract/2021/OrdinaryGetOwnProperty.js
var require_OrdinaryGetOwnProperty = __commonJS({
  "node_modules/es-abstract/2021/OrdinaryGetOwnProperty.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = require_getOwnPropertyDescriptor();
    var $TypeError = GetIntrinsic("%TypeError%");
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var has = require_src();
    var IsArray = require_IsArray2();
    var IsPropertyKey = require_IsPropertyKey();
    var IsRegExp = require_IsRegExp();
    var ToPropertyDescriptor = require_ToPropertyDescriptor();
    var Type = require_Type2();
    module.exports = function OrdinaryGetOwnProperty(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: O must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (!has(O, P)) {
        return void 0;
      }
      if (!$gOPD) {
        var arrayLength = IsArray(O) && P === "length";
        var regexLastIndex = IsRegExp(O) && P === "lastIndex";
        return {
          "[[Configurable]]": !(arrayLength || regexLastIndex),
          "[[Enumerable]]": $isEnumerable(O, P),
          "[[Value]]": O[P],
          "[[Writable]]": true
        };
      }
      return ToPropertyDescriptor($gOPD(O, P));
    };
  }
});

// node_modules/es-abstract/2021/IsDataDescriptor.js
var require_IsDataDescriptor = __commonJS({
  "node_modules/es-abstract/2021/IsDataDescriptor.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var has = require_src();
    var assertRecord = require_assertRecord();
    var Type = require_Type2();
    module.exports = function IsDataDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!has(Desc, "[[Value]]") && !has(Desc, "[[Writable]]")) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/es-abstract/2021/IsExtensible.js
var require_IsExtensible = __commonJS({
  "node_modules/es-abstract/2021/IsExtensible.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $preventExtensions = GetIntrinsic("%Object.preventExtensions%", true);
    var $isExtensible = GetIntrinsic("%Object.isExtensible%", true);
    var isPrimitive = require_isPrimitive();
    module.exports = $preventExtensions ? function IsExtensible(obj) {
      return !isPrimitive(obj) && $isExtensible(obj);
    } : function IsExtensible(obj) {
      return !isPrimitive(obj);
    };
  }
});

// node_modules/es-abstract/2021/SameValue.js
var require_SameValue = __commonJS({
  "node_modules/es-abstract/2021/SameValue.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var $isNaN = require_isNaN();
    module.exports = function SameValue(x, y) {
      if (x === y) {
        if (x === 0) {
          return 1 / x === 1 / y;
        }
        return true;
      }
      return $isNaN(x) && $isNaN(y);
    };
  }
});

// node_modules/es-abstract/2021/CreateDataProperty.js
var require_CreateDataProperty = __commonJS({
  "node_modules/es-abstract/2021/CreateDataProperty.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var DefineOwnProperty = require_DefineOwnProperty();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var OrdinaryGetOwnProperty = require_OrdinaryGetOwnProperty();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsExtensible = require_IsExtensible();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    module.exports = function CreateDataProperty(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var oldDesc = OrdinaryGetOwnProperty(O, P);
      var extensible = !oldDesc || IsExtensible(O);
      var nonConfigurable = oldDesc && !oldDesc["[[Configurable]]"];
      if (nonConfigurable || !extensible) {
        return false;
      }
      return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Value]]": V,
        "[[Writable]]": true
      });
    };
  }
});

// node_modules/es-abstract/2021/Call.js
var require_Call = __commonJS({
  "node_modules/es-abstract/2021/Call.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsArray = require_IsArray2();
    var $apply = GetIntrinsic("%Reflect.apply%", true) || callBound("%Function.prototype.apply%");
    module.exports = function Call(F, V) {
      var argumentsList = arguments.length > 2 ? arguments[2] : [];
      if (!IsArray(argumentsList)) {
        throw new $TypeError("Assertion failed: optional `argumentsList`, if provided, must be a List");
      }
      return $apply(F, V, argumentsList);
    };
  }
});

// node_modules/es-abstract/2021/Get.js
var require_Get = __commonJS({
  "node_modules/es-abstract/2021/Get.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var inspect = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module.exports = function Get(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect(P));
      }
      return O[P];
    };
  }
});

// node_modules/es-abstract/2021/HasProperty.js
var require_HasProperty = __commonJS({
  "node_modules/es-abstract/2021/HasProperty.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module.exports = function HasProperty(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: `O` must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: `P` must be a Property Key");
      }
      return P in O;
    };
  }
});

// node_modules/es-abstract/2021/LengthOfArrayLike.js
var require_LengthOfArrayLike = __commonJS({
  "node_modules/es-abstract/2021/LengthOfArrayLike.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Get = require_Get();
    var ToLength = require_ToLength();
    var Type = require_Type2();
    module.exports = function LengthOfArrayLike(obj) {
      if (Type(obj) !== "Object") {
        throw new $TypeError("Assertion failed: `obj` must be an Object");
      }
      return ToLength(Get(obj, "length"));
    };
  }
});

// node_modules/array.prototype.reduce/implementation.js
var require_implementation8 = __commonJS({
  "node_modules/array.prototype.reduce/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var Call = require_Call();
    var Get = require_Get();
    var HasProperty = require_HasProperty();
    var IsCallable = require_IsCallable();
    var LengthOfArrayLike = require_LengthOfArrayLike();
    var ToObject = require_ToObject();
    var ToString = require_ToString();
    var callBound = require_callBound();
    var isString = require_is_string();
    var $TypeError = TypeError;
    var boxedString = Object("a");
    var splitString = boxedString[0] !== "a" || !(0 in boxedString);
    var strSplit = callBound("%String.prototype.split%");
    module.exports = function reduce(callbackfn) {
      var O = ToObject(this);
      var self2 = splitString && isString(O) ? strSplit(O, "") : O;
      var len = LengthOfArrayLike(self2);
      if (!IsCallable(callbackfn)) {
        throw new $TypeError("Array.prototype.reduce callback must be a function");
      }
      if (len === 0 && arguments.length < 2) {
        throw new $TypeError("reduce of empty array with no initial value");
      }
      var k = 0;
      var accumulator;
      var Pk, kPresent;
      if (arguments.length > 1) {
        accumulator = arguments[1];
      } else {
        kPresent = false;
        while (!kPresent && k < len) {
          Pk = ToString(k);
          kPresent = HasProperty(O, Pk);
          if (kPresent) {
            accumulator = Get(O, Pk);
          }
          k += 1;
        }
        if (!kPresent) {
          throw new $TypeError("reduce of empty array with no initial value");
        }
      }
      while (k < len) {
        Pk = ToString(k);
        kPresent = HasProperty(O, Pk);
        if (kPresent) {
          var kValue = Get(O, Pk);
          accumulator = Call(callbackfn, void 0, [accumulator, kValue, k, O]);
        }
        k += 1;
      }
      return accumulator;
    };
  }
});

// node_modules/es-array-method-boxes-properly/index.js
var require_es_array_method_boxes_properly = __commonJS({
  "node_modules/es-array-method-boxes-properly/index.js"(exports, module) {
    init_define_ngDevMode();
    module.exports = function properlyBoxed(method) {
      var properlyBoxesNonStrict = true;
      var properlyBoxesStrict = true;
      var threwException = false;
      if (typeof method === "function") {
        try {
          method.call("f", function(_, __, O) {
            if (typeof O !== "object") {
              properlyBoxesNonStrict = false;
            }
          });
          method.call([null], function() {
            "use strict";
            properlyBoxesStrict = typeof this === "string";
          }, "x");
        } catch (e) {
          threwException = true;
        }
        return !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
      }
      return false;
    };
  }
});

// node_modules/array.prototype.reduce/polyfill.js
var require_polyfill7 = __commonJS({
  "node_modules/array.prototype.reduce/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var arrayMethodBoxesProperly = require_es_array_method_boxes_properly();
    var implementation = require_implementation8();
    module.exports = function getPolyfill() {
      var method = Array.prototype.reduce;
      return arrayMethodBoxesProperly(method) ? method : implementation;
    };
  }
});

// node_modules/array.prototype.reduce/shim.js
var require_shim7 = __commonJS({
  "node_modules/array.prototype.reduce/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill7();
    module.exports = function shimArrayPrototypeReduce() {
      var polyfill = getPolyfill();
      define2(Array.prototype, {
        reduce: polyfill
      }, {
        reduce: function() {
          return Array.prototype.reduce !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/array.prototype.reduce/index.js
var require_array_prototype = __commonJS({
  "node_modules/array.prototype.reduce/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var define2 = require_define_properties();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var implementation = require_implementation8();
    var getPolyfill = require_polyfill7();
    var polyfill = callBind.apply(getPolyfill());
    var shim = require_shim7();
    var $slice = callBound("%Array.prototype.slice%");
    var boundShim = function reduce(array, callbackfn) {
      RequireObjectCoercible(array);
      return polyfill(array, $slice(arguments, 1));
    };
    define2(boundShim, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = boundShim;
  }
});

// node_modules/object.getownpropertydescriptors/implementation.js
var require_implementation9 = __commonJS({
  "node_modules/object.getownpropertydescriptors/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var CreateDataProperty = require_CreateDataProperty();
    var IsCallable = require_IsCallable();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var ToObject = require_ToObject();
    var callBound = require_callBound();
    var reduce = require_array_prototype();
    var $gOPD = Object.getOwnPropertyDescriptor;
    var $getOwnNames = Object.getOwnPropertyNames;
    var $getSymbols = Object.getOwnPropertySymbols;
    var $concat = callBound("Array.prototype.concat");
    var getAll = $getSymbols ? function(obj) {
      return $concat($getOwnNames(obj), $getSymbols(obj));
    } : $getOwnNames;
    var isES5 = IsCallable($gOPD) && IsCallable($getOwnNames);
    module.exports = function getOwnPropertyDescriptors(value) {
      RequireObjectCoercible(value);
      if (!isES5) {
        throw new TypeError("getOwnPropertyDescriptors requires Object.getOwnPropertyDescriptor");
      }
      var O = ToObject(value);
      return reduce(getAll(O), function(acc, key) {
        var descriptor = $gOPD(O, key);
        if (typeof descriptor !== "undefined") {
          CreateDataProperty(acc, key, descriptor);
        }
        return acc;
      }, {});
    };
  }
});

// node_modules/object.getownpropertydescriptors/polyfill.js
var require_polyfill8 = __commonJS({
  "node_modules/object.getownpropertydescriptors/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation9();
    module.exports = function getPolyfill() {
      return typeof Object.getOwnPropertyDescriptors === "function" ? Object.getOwnPropertyDescriptors : implementation;
    };
  }
});

// node_modules/object.getownpropertydescriptors/shim.js
var require_shim8 = __commonJS({
  "node_modules/object.getownpropertydescriptors/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var getPolyfill = require_polyfill8();
    var define2 = require_define_properties();
    module.exports = function shimGetOwnPropertyDescriptors() {
      var polyfill = getPolyfill();
      define2(Object, {
        getOwnPropertyDescriptors: polyfill
      }, {
        getOwnPropertyDescriptors: function() {
          return Object.getOwnPropertyDescriptors !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/promise.prototype.finally/requirePromise.js
var require_requirePromise = __commonJS({
  "node_modules/promise.prototype.finally/requirePromise.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = function requirePromise() {
      if (typeof Promise !== "function") {
        throw new TypeError("`Promise.prototype.finally` requires a global `Promise` be available.");
      }
    };
  }
});

// node_modules/es-abstract/GetIntrinsic.js
var require_GetIntrinsic = __commonJS({
  "node_modules/es-abstract/GetIntrinsic.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = require_get_intrinsic();
  }
});

// node_modules/es-abstract/helpers/isPropertyDescriptor.js
var require_isPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/isPropertyDescriptor.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var has = require_src();
    var $TypeError = GetIntrinsic("%TypeError%");
    module.exports = function IsPropertyDescriptor(ES, Desc) {
      if (ES.Type(Desc) !== "Object") {
        return false;
      }
      var allowed = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Get]]": true,
        "[[Set]]": true,
        "[[Value]]": true,
        "[[Writable]]": true
      };
      for (var key in Desc) {
        if (has(Desc, key) && !allowed[key]) {
          return false;
        }
      }
      if (ES.IsDataDescriptor(Desc) && ES.IsAccessorDescriptor(Desc)) {
        throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
      }
      return true;
    };
  }
});

// node_modules/es-abstract/2021/IsAccessorDescriptor.js
var require_IsAccessorDescriptor = __commonJS({
  "node_modules/es-abstract/2021/IsAccessorDescriptor.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var has = require_src();
    var assertRecord = require_assertRecord();
    var Type = require_Type2();
    module.exports = function IsAccessorDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!has(Desc, "[[Get]]") && !has(Desc, "[[Set]]")) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/es-abstract/2021/DefinePropertyOrThrow.js
var require_DefinePropertyOrThrow = __commonJS({
  "node_modules/es-abstract/2021/DefinePropertyOrThrow.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var isPropertyDescriptor = require_isPropertyDescriptor();
    var DefineOwnProperty = require_DefineOwnProperty();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var ToPropertyDescriptor = require_ToPropertyDescriptor();
    var Type = require_Type2();
    module.exports = function DefinePropertyOrThrow(O, P, desc) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var Desc = isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, desc) ? desc : ToPropertyDescriptor(desc);
      if (!isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, Desc)) {
        throw new $TypeError("Assertion failed: Desc is not a valid Property Descriptor");
      }
      return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, Desc);
    };
  }
});

// node_modules/es-abstract/2021/IsConstructor.js
var require_IsConstructor = __commonJS({
  "node_modules/es-abstract/2021/IsConstructor.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_GetIntrinsic();
    var $construct = GetIntrinsic("%Reflect.construct%", true);
    var DefinePropertyOrThrow = require_DefinePropertyOrThrow();
    try {
      DefinePropertyOrThrow({}, "", {
        "[[Get]]": function() {
        }
      });
    } catch (e) {
      DefinePropertyOrThrow = null;
    }
    if (DefinePropertyOrThrow && $construct) {
      isConstructorMarker = {};
      badArrayLike = {};
      DefinePropertyOrThrow(badArrayLike, "length", {
        "[[Get]]": function() {
          throw isConstructorMarker;
        },
        "[[Enumerable]]": true
      });
      module.exports = function IsConstructor(argument) {
        try {
          $construct(argument, badArrayLike);
        } catch (err) {
          return err === isConstructorMarker;
        }
      };
    } else {
      module.exports = function IsConstructor(argument) {
        return typeof argument === "function" && !!argument.prototype;
      };
    }
    var isConstructorMarker;
    var badArrayLike;
  }
});

// node_modules/es-abstract/2021/SpeciesConstructor.js
var require_SpeciesConstructor = __commonJS({
  "node_modules/es-abstract/2021/SpeciesConstructor.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $species = GetIntrinsic("%Symbol.species%", true);
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsConstructor = require_IsConstructor();
    var Type = require_Type2();
    module.exports = function SpeciesConstructor(O, defaultConstructor) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      var C = O.constructor;
      if (typeof C === "undefined") {
        return defaultConstructor;
      }
      if (Type(C) !== "Object") {
        throw new $TypeError("O.constructor is not an Object");
      }
      var S = $species ? C[$species] : void 0;
      if (S == null) {
        return defaultConstructor;
      }
      if (IsConstructor(S)) {
        return S;
      }
      throw new $TypeError("no constructor found");
    };
  }
});

// node_modules/promise.prototype.finally/implementation.js
var require_implementation10 = __commonJS({
  "node_modules/promise.prototype.finally/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var requirePromise = require_requirePromise();
    requirePromise();
    var IsCallable = require_IsCallable();
    var SpeciesConstructor = require_SpeciesConstructor();
    var Type = require_Type2();
    var promiseResolve = function PromiseResolve(C, value) {
      return new C(function(resolve) {
        resolve(value);
      });
    };
    var OriginalPromise = Promise;
    var createThenFinally = function CreateThenFinally(C, onFinally) {
      return function(value) {
        var result = onFinally();
        var promise = promiseResolve(C, result);
        var valueThunk = function() {
          return value;
        };
        return promise.then(valueThunk);
      };
    };
    var createCatchFinally = function CreateCatchFinally(C, onFinally) {
      return function(reason) {
        var result = onFinally();
        var promise = promiseResolve(C, result);
        var thrower = function() {
          throw reason;
        };
        return promise.then(thrower);
      };
    };
    var promiseFinally = function finally_(onFinally) {
      var promise = this;
      if (Type(promise) !== "Object") {
        throw new TypeError("receiver is not an Object");
      }
      var C = SpeciesConstructor(promise, OriginalPromise);
      var thenFinally = onFinally;
      var catchFinally = onFinally;
      if (IsCallable(onFinally)) {
        thenFinally = createThenFinally(C, onFinally);
        catchFinally = createCatchFinally(C, onFinally);
      }
      return promise.then(thenFinally, catchFinally);
    };
    if (Object.getOwnPropertyDescriptor) {
      descriptor = Object.getOwnPropertyDescriptor(promiseFinally, "name");
      if (descriptor && descriptor.configurable) {
        Object.defineProperty(promiseFinally, "name", {
          configurable: true,
          value: "finally"
        });
      }
    }
    var descriptor;
    module.exports = promiseFinally;
  }
});

// node_modules/promise.prototype.finally/polyfill.js
var require_polyfill9 = __commonJS({
  "node_modules/promise.prototype.finally/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var requirePromise = require_requirePromise();
    var implementation = require_implementation10();
    module.exports = function getPolyfill() {
      requirePromise();
      return typeof Promise.prototype["finally"] === "function" ? Promise.prototype["finally"] : implementation;
    };
  }
});

// node_modules/promise.prototype.finally/shim.js
var require_shim9 = __commonJS({
  "node_modules/promise.prototype.finally/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var requirePromise = require_requirePromise();
    var getPolyfill = require_polyfill9();
    var define2 = require_define_properties();
    module.exports = function shimPromiseFinally() {
      requirePromise();
      var polyfill = getPolyfill();
      define2(Promise.prototype, {
        "finally": polyfill
      }, {
        "finally": function testFinally() {
          return Promise.prototype["finally"] !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/promise.prototype.finally/auto.js
var require_auto = __commonJS({
  "node_modules/promise.prototype.finally/auto.js"() {
    "use strict";
    init_define_ngDevMode();
    require_shim9()();
  }
});

// node_modules/es-shim-unscopables/index.js
var require_es_shim_unscopables = __commonJS({
  "node_modules/es-shim-unscopables/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var has = require_src();
    var hasUnscopables = typeof Symbol === "function" && typeof Symbol.unscopables === "symbol";
    var map = hasUnscopables && Array.prototype[Symbol.unscopables];
    var $TypeError = TypeError;
    module.exports = function shimUnscopables(method) {
      if (typeof method !== "string" || !method) {
        throw new $TypeError("method must be a non-empty string");
      }
      if (!has(Array.prototype, method)) {
        throw new $TypeError("method must be on Array.prototype");
      }
      if (hasUnscopables) {
        map[method] = true;
      }
    };
  }
});

// node_modules/es-abstract/2021/IsIntegralNumber.js
var require_IsIntegralNumber = __commonJS({
  "node_modules/es-abstract/2021/IsIntegralNumber.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var abs = require_abs();
    var floor = require_floor();
    var Type = require_Type2();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    module.exports = function IsIntegralNumber(argument) {
      if (Type(argument) !== "Number" || $isNaN(argument) || !$isFinite(argument)) {
        return false;
      }
      var absValue = abs(argument);
      return floor(absValue) === absValue;
    };
  }
});

// node_modules/es-abstract/2021/ArrayCreate.js
var require_ArrayCreate = __commonJS({
  "node_modules/es-abstract/2021/ArrayCreate.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $ArrayPrototype = GetIntrinsic("%Array.prototype%");
    var $RangeError = GetIntrinsic("%RangeError%");
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsIntegralNumber = require_IsIntegralNumber();
    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1;
    var $setProto = GetIntrinsic("%Object.setPrototypeOf%", true) || ([].__proto__ !== $ArrayPrototype ? null : function(O, proto) {
      O.__proto__ = proto;
      return O;
    });
    module.exports = function ArrayCreate(length) {
      if (!IsIntegralNumber(length) || length < 0) {
        throw new $TypeError("Assertion failed: `length` must be an integer Number >= 0");
      }
      if (length > MAX_ARRAY_LENGTH) {
        throw new $RangeError("length is greater than (2**32 - 1)");
      }
      var proto = arguments.length > 1 ? arguments[1] : $ArrayPrototype;
      var A = [];
      if (proto !== $ArrayPrototype) {
        if (!$setProto) {
          throw new $SyntaxError("ArrayCreate: a `proto` argument that is not `Array.prototype` is not supported in an environment that does not support setting the [[Prototype]]");
        }
        $setProto(A, proto);
      }
      if (length !== 0) {
        A.length = length;
      }
      return A;
    };
  }
});

// node_modules/es-abstract/2021/ArraySpeciesCreate.js
var require_ArraySpeciesCreate = __commonJS({
  "node_modules/es-abstract/2021/ArraySpeciesCreate.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $species = GetIntrinsic("%Symbol.species%", true);
    var $TypeError = GetIntrinsic("%TypeError%");
    var ArrayCreate = require_ArrayCreate();
    var Get = require_Get();
    var IsArray = require_IsArray2();
    var IsConstructor = require_IsConstructor();
    var IsIntegralNumber = require_IsIntegralNumber();
    var Type = require_Type2();
    module.exports = function ArraySpeciesCreate(originalArray, length) {
      if (!IsIntegralNumber(length) || length < 0) {
        throw new $TypeError("Assertion failed: length must be an integer >= 0");
      }
      var isArray = IsArray(originalArray);
      if (!isArray) {
        return ArrayCreate(length);
      }
      var C = Get(originalArray, "constructor");
      if ($species && Type(C) === "Object") {
        C = Get(C, $species);
        if (C === null) {
          C = void 0;
        }
      }
      if (typeof C === "undefined") {
        return ArrayCreate(length);
      }
      if (!IsConstructor(C)) {
        throw new $TypeError("C must be a constructor");
      }
      return new C(length);
    };
  }
});

// node_modules/es-abstract/2021/CreateDataPropertyOrThrow.js
var require_CreateDataPropertyOrThrow = __commonJS({
  "node_modules/es-abstract/2021/CreateDataPropertyOrThrow.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var CreateDataProperty = require_CreateDataProperty();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module.exports = function CreateDataPropertyOrThrow(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var success = CreateDataProperty(O, P, V);
      if (!success) {
        throw new $TypeError("unable to create data property");
      }
      return success;
    };
  }
});

// node_modules/es-abstract/2021/FlattenIntoArray.js
var require_FlattenIntoArray = __commonJS({
  "node_modules/es-abstract/2021/FlattenIntoArray.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var Call = require_Call();
    var CreateDataPropertyOrThrow = require_CreateDataPropertyOrThrow();
    var Get = require_Get();
    var HasProperty = require_HasProperty();
    var IsArray = require_IsArray2();
    var LengthOfArrayLike = require_LengthOfArrayLike();
    var ToString = require_ToString();
    module.exports = function FlattenIntoArray(target, source, sourceLen, start, depth) {
      var mapperFunction;
      if (arguments.length > 5) {
        mapperFunction = arguments[5];
      }
      var targetIndex = start;
      var sourceIndex = 0;
      while (sourceIndex < sourceLen) {
        var P = ToString(sourceIndex);
        var exists = HasProperty(source, P);
        if (exists === true) {
          var element = Get(source, P);
          if (typeof mapperFunction !== "undefined") {
            if (arguments.length <= 6) {
              throw new $TypeError("Assertion failed: thisArg is required when mapperFunction is provided");
            }
            element = Call(mapperFunction, arguments[6], [element, sourceIndex, source]);
          }
          var shouldFlatten = false;
          if (depth > 0) {
            shouldFlatten = IsArray(element);
          }
          if (shouldFlatten) {
            var elementLen = LengthOfArrayLike(element);
            targetIndex = FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);
          } else {
            if (targetIndex >= MAX_SAFE_INTEGER) {
              throw new $TypeError("index too large");
            }
            CreateDataPropertyOrThrow(target, ToString(targetIndex), element);
            targetIndex += 1;
          }
        }
        sourceIndex += 1;
      }
      return targetIndex;
    };
  }
});

// node_modules/array.prototype.flat/implementation.js
var require_implementation11 = __commonJS({
  "node_modules/array.prototype.flat/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var ArraySpeciesCreate = require_ArraySpeciesCreate();
    var FlattenIntoArray = require_FlattenIntoArray();
    var Get = require_Get();
    var ToIntegerOrInfinity = require_ToIntegerOrInfinity();
    var ToLength = require_ToLength();
    var ToObject = require_ToObject();
    module.exports = function flat() {
      var O = ToObject(this);
      var sourceLen = ToLength(Get(O, "length"));
      var depthNum = 1;
      if (arguments.length > 0 && typeof arguments[0] !== "undefined") {
        depthNum = ToIntegerOrInfinity(arguments[0]);
      }
      var A = ArraySpeciesCreate(O, 0);
      FlattenIntoArray(A, O, sourceLen, 0, depthNum);
      return A;
    };
  }
});

// node_modules/array.prototype.flat/polyfill.js
var require_polyfill10 = __commonJS({
  "node_modules/array.prototype.flat/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation11();
    module.exports = function getPolyfill() {
      return Array.prototype.flat || implementation;
    };
  }
});

// node_modules/array.prototype.flat/shim.js
var require_shim10 = __commonJS({
  "node_modules/array.prototype.flat/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var define2 = require_define_properties();
    var shimUnscopables = require_es_shim_unscopables();
    var getPolyfill = require_polyfill10();
    module.exports = function shimFlat() {
      var polyfill = getPolyfill();
      define2(Array.prototype, {
        flat: polyfill
      }, {
        flat: function() {
          return Array.prototype.flat !== polyfill;
        }
      });
      shimUnscopables("flat");
      return polyfill;
    };
  }
});

// node_modules/array.prototype.flat/auto.js
var require_auto2 = __commonJS({
  "node_modules/array.prototype.flat/auto.js"() {
    "use strict";
    init_define_ngDevMode();
    require_shim10()();
  }
});

// node_modules/array.prototype.flatmap/implementation.js
var require_implementation12 = __commonJS({
  "node_modules/array.prototype.flatmap/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var ArraySpeciesCreate = require_ArraySpeciesCreate();
    var FlattenIntoArray = require_FlattenIntoArray();
    var Get = require_Get();
    var IsCallable = require_IsCallable();
    var ToLength = require_ToLength();
    var ToObject = require_ToObject();
    module.exports = function flatMap(mapperFunction) {
      var O = ToObject(this);
      var sourceLen = ToLength(Get(O, "length"));
      if (!IsCallable(mapperFunction)) {
        throw new TypeError("mapperFunction must be a function");
      }
      var T;
      if (arguments.length > 1) {
        T = arguments[1];
      }
      var A = ArraySpeciesCreate(O, 0);
      FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, T);
      return A;
    };
  }
});

// node_modules/array.prototype.flatmap/polyfill.js
var require_polyfill11 = __commonJS({
  "node_modules/array.prototype.flatmap/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation12();
    module.exports = function getPolyfill() {
      return Array.prototype.flatMap || implementation;
    };
  }
});

// node_modules/array.prototype.flatmap/shim.js
var require_shim11 = __commonJS({
  "node_modules/array.prototype.flatmap/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var define2 = require_define_properties();
    var shimUnscopables = require_es_shim_unscopables();
    var getPolyfill = require_polyfill11();
    module.exports = function shimFlatMap() {
      var polyfill = getPolyfill();
      define2(Array.prototype, {
        flatMap: polyfill
      }, {
        flatMap: function() {
          return Array.prototype.flatMap !== polyfill;
        }
      });
      shimUnscopables("flatMap");
      return polyfill;
    };
  }
});

// node_modules/array.prototype.flatmap/auto.js
var require_auto3 = __commonJS({
  "node_modules/array.prototype.flatmap/auto.js"() {
    "use strict";
    init_define_ngDevMode();
    require_shim11()();
  }
});

// node_modules/get-symbol-description/getInferredName.js
var require_getInferredName = __commonJS({
  "node_modules/get-symbol-description/getInferredName.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var getInferredName;
    try {
      getInferredName = Function("s", "return { [s]() {} }[s].name;");
    } catch (e) {
    }
    var inferred = function() {
    };
    module.exports = getInferredName && inferred.name === "inferred" ? getInferredName : null;
  }
});

// node_modules/get-symbol-description/index.js
var require_get_symbol_description = __commonJS({
  "node_modules/get-symbol-description/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var getGlobalSymbolDescription = GetIntrinsic("%Symbol.keyFor%", true);
    var thisSymbolValue = callBound("%Symbol.prototype.valueOf%", true);
    var symToStr = callBound("Symbol.prototype.toString", true);
    var getInferredName = require_getInferredName();
    module.exports = callBound("%Symbol.prototype.description%", true) || function getSymbolDescription(symbol) {
      if (!thisSymbolValue) {
        throw new $SyntaxError("Symbols are not supported in this environment");
      }
      var sym = thisSymbolValue(symbol);
      if (getInferredName) {
        var name = getInferredName(sym);
        if (name === "") {
          return;
        }
        return name.slice(1, -1);
      }
      var desc;
      if (getGlobalSymbolDescription) {
        desc = getGlobalSymbolDescription(sym);
        if (typeof desc === "string") {
          return desc;
        }
      }
      desc = symToStr(sym).slice(7, -1);
      if (desc) {
        return desc;
      }
    };
  }
});

// node_modules/symbol.prototype.description/implementation.js
var require_implementation13 = __commonJS({
  "node_modules/symbol.prototype.description/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var getSymbolDescription = require_get_symbol_description();
    module.exports = function description() {
      return getSymbolDescription(this);
    };
  }
});

// node_modules/symbol.prototype.description/polyfill.js
var require_polyfill12 = __commonJS({
  "node_modules/symbol.prototype.description/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var hasSymbols = require_has_symbols()();
    var implementation = require_implementation13();
    var gOPD = Object.getOwnPropertyDescriptor;
    module.exports = function descriptionPolyfill() {
      if (!hasSymbols || typeof gOPD !== "function") {
        return null;
      }
      var desc = gOPD(Symbol.prototype, "description");
      if (!desc || typeof desc.get !== "function") {
        return implementation;
      }
      var emptySymbolDesc = desc.get.call(Symbol());
      var emptyDescValid = typeof emptySymbolDesc === "undefined" || emptySymbolDesc === "";
      if (!emptyDescValid || desc.get.call(Symbol("a")) !== "a") {
        return implementation;
      }
      return desc.get;
    };
  }
});

// node_modules/symbol.prototype.description/shim.js
var require_shim12 = __commonJS({
  "node_modules/symbol.prototype.description/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var hasSymbols = require_has_symbols()();
    var polyfill = require_polyfill12();
    var getInferredName = require_getInferredName();
    var gOPD = Object.getOwnPropertyDescriptor;
    var gOPDs = require_polyfill8()();
    var dP = Object.defineProperty;
    var dPs = Object.defineProperties;
    var setProto = Object.setPrototypeOf;
    var define2 = function defineGetter(getter) {
      dP(Symbol.prototype, "description", {
        configurable: true,
        enumerable: false,
        get: getter
      });
    };
    var shimGlobal = function shimGlobalSymbol(getter) {
      var origSym = Function.apply.bind(Symbol);
      var emptyStrings = Object.create ? /* @__PURE__ */ Object.create(null) : {};
      var SymNew = function Symbol2() {
        var sym = origSym(this, arguments);
        if (arguments.length > 0 && arguments[0] === "") {
          emptyStrings[sym] = true;
        }
        return sym;
      };
      SymNew.prototype = Symbol.prototype;
      setProto(SymNew, Symbol);
      var props = gOPDs(Symbol);
      delete props.length;
      delete props.arguments;
      delete props.caller;
      dPs(SymNew, props);
      Symbol = SymNew;
      var boundGetter = Function.call.bind(getter);
      var wrappedGetter = function description() {
        var symbolDescription = boundGetter(this);
        if (emptyStrings[this]) {
          return "";
        }
        return symbolDescription;
      };
      define2(wrappedGetter);
      return wrappedGetter;
    };
    module.exports = function shimSymbolDescription() {
      if (!hasSymbols) {
        return false;
      }
      var desc = gOPD(Symbol.prototype, "description");
      var getter = polyfill();
      var isMissing = !desc || typeof desc.get !== "function";
      var isBroken = !isMissing && (typeof Symbol().description !== "undefined" || Symbol("").description !== "");
      if (isMissing || isBroken) {
        if (!getInferredName) {
          return shimGlobal(getter);
        }
        define2(getter);
      }
      return getter;
    };
  }
});

// node_modules/symbol.prototype.description/auto.js
var require_auto4 = __commonJS({
  "node_modules/symbol.prototype.description/auto.js"() {
    "use strict";
    init_define_ngDevMode();
    require_shim12()();
  }
});

// node_modules/es-abstract/helpers/getIteratorMethod.js
var require_getIteratorMethod = __commonJS({
  "node_modules/es-abstract/helpers/getIteratorMethod.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var hasSymbols = require_has_symbols()();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var isString = require_is_string();
    var $iterator = GetIntrinsic("%Symbol.iterator%", true);
    var $stringSlice = callBound("String.prototype.slice");
    var $String = GetIntrinsic("%String%", true);
    module.exports = function getIteratorMethod(ES, iterable) {
      var usingIterator;
      if (hasSymbols) {
        usingIterator = ES.GetMethod(iterable, $iterator);
      } else if (ES.IsArray(iterable)) {
        usingIterator = function() {
          var i = -1;
          var arr = this;
          return {
            next: function() {
              i += 1;
              return {
                done: i >= arr.length,
                value: arr[i]
              };
            }
          };
        };
      } else if (isString(iterable)) {
        usingIterator = function() {
          var i = 0;
          return {
            next: function() {
              var nextIndex = ES.AdvanceStringIndex($String(iterable), i, true);
              var value = $stringSlice(iterable, i, nextIndex);
              i = nextIndex;
              return {
                done: nextIndex > iterable.length,
                value
              };
            }
          };
        };
      }
      return usingIterator;
    };
  }
});

// node_modules/es-abstract/helpers/isLeadingSurrogate.js
var require_isLeadingSurrogate = __commonJS({
  "node_modules/es-abstract/helpers/isLeadingSurrogate.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = function isLeadingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 55296 && charCode <= 56319;
    };
  }
});

// node_modules/es-abstract/helpers/isTrailingSurrogate.js
var require_isTrailingSurrogate = __commonJS({
  "node_modules/es-abstract/helpers/isTrailingSurrogate.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = function isTrailingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 56320 && charCode <= 57343;
    };
  }
});

// node_modules/es-abstract/2021/UTF16SurrogatePairToCodePoint.js
var require_UTF16SurrogatePairToCodePoint = __commonJS({
  "node_modules/es-abstract/2021/UTF16SurrogatePairToCodePoint.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $fromCharCode = GetIntrinsic("%String.fromCharCode%");
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    module.exports = function UTF16SurrogatePairToCodePoint(lead, trail) {
      if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
        throw new $TypeError("Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code");
      }
      return $fromCharCode(lead) + $fromCharCode(trail);
    };
  }
});

// node_modules/es-abstract/2021/CodePointAt.js
var require_CodePointAt = __commonJS({
  "node_modules/es-abstract/2021/CodePointAt.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var callBound = require_callBound();
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    var Type = require_Type2();
    var UTF16SurrogatePairToCodePoint = require_UTF16SurrogatePairToCodePoint();
    var $charAt = callBound("String.prototype.charAt");
    var $charCodeAt = callBound("String.prototype.charCodeAt");
    module.exports = function CodePointAt(string, position) {
      if (Type(string) !== "String") {
        throw new $TypeError("Assertion failed: `string` must be a String");
      }
      var size = string.length;
      if (position < 0 || position >= size) {
        throw new $TypeError("Assertion failed: `position` must be >= 0, and < the length of `string`");
      }
      var first = $charCodeAt(string, position);
      var cp = $charAt(string, position);
      var firstIsLeading = isLeadingSurrogate(first);
      var firstIsTrailing = isTrailingSurrogate(first);
      if (!firstIsLeading && !firstIsTrailing) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": false
        };
      }
      if (firstIsTrailing || position + 1 === size) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      var second = $charCodeAt(string, position + 1);
      if (!isTrailingSurrogate(second)) {
        return {
          "[[CodePoint]]": cp,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      return {
        "[[CodePoint]]": UTF16SurrogatePairToCodePoint(first, second),
        "[[CodeUnitCount]]": 2,
        "[[IsUnpairedSurrogate]]": false
      };
    };
  }
});

// node_modules/es-abstract/2021/AdvanceStringIndex.js
var require_AdvanceStringIndex = __commonJS({
  "node_modules/es-abstract/2021/AdvanceStringIndex.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var CodePointAt = require_CodePointAt();
    var IsIntegralNumber = require_IsIntegralNumber();
    var Type = require_Type2();
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var $TypeError = GetIntrinsic("%TypeError%");
    module.exports = function AdvanceStringIndex(S, index, unicode) {
      if (Type(S) !== "String") {
        throw new $TypeError("Assertion failed: `S` must be a String");
      }
      if (!IsIntegralNumber(index) || index < 0 || index > MAX_SAFE_INTEGER) {
        throw new $TypeError("Assertion failed: `length` must be an integer >= 0 and <= 2**53");
      }
      if (Type(unicode) !== "Boolean") {
        throw new $TypeError("Assertion failed: `unicode` must be a Boolean");
      }
      if (!unicode) {
        return index + 1;
      }
      var length = S.length;
      if (index + 1 >= length) {
        return index + 1;
      }
      var cp = CodePointAt(S, index);
      return index + cp["[[CodeUnitCount]]"];
    };
  }
});

// node_modules/es-abstract/2021/GetV.js
var require_GetV = __commonJS({
  "node_modules/es-abstract/2021/GetV.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsPropertyKey = require_IsPropertyKey();
    var ToObject = require_ToObject();
    module.exports = function GetV(V, P) {
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var O = ToObject(V);
      return O[P];
    };
  }
});

// node_modules/es-abstract/2021/GetMethod.js
var require_GetMethod = __commonJS({
  "node_modules/es-abstract/2021/GetMethod.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var GetV = require_GetV();
    var IsCallable = require_IsCallable();
    var IsPropertyKey = require_IsPropertyKey();
    module.exports = function GetMethod(O, P) {
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var func = GetV(O, P);
      if (func == null) {
        return void 0;
      }
      if (!IsCallable(func)) {
        throw new $TypeError(P + "is not a function");
      }
      return func;
    };
  }
});

// node_modules/es-abstract/2021/GetIterator.js
var require_GetIterator = __commonJS({
  "node_modules/es-abstract/2021/GetIterator.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $asyncIterator = GetIntrinsic("%Symbol.asyncIterator%", true);
    var inspect = require_object_inspect();
    var hasSymbols = require_has_symbols()();
    var getIteratorMethod = require_getIteratorMethod();
    var AdvanceStringIndex = require_AdvanceStringIndex();
    var Call = require_Call();
    var GetMethod = require_GetMethod();
    var IsArray = require_IsArray2();
    var Type = require_Type2();
    module.exports = function GetIterator(obj, hint, method) {
      var actualHint = hint;
      if (arguments.length < 2) {
        actualHint = "sync";
      }
      if (actualHint !== "sync" && actualHint !== "async") {
        throw new $TypeError("Assertion failed: `hint` must be one of 'sync' or 'async', got " + inspect(hint));
      }
      var actualMethod = method;
      if (arguments.length < 3) {
        if (actualHint === "async") {
          if (hasSymbols && $asyncIterator) {
            actualMethod = GetMethod(obj, $asyncIterator);
          }
          if (actualMethod === void 0) {
            throw new $TypeError("async from sync iterators aren't currently supported");
          }
        } else {
          actualMethod = getIteratorMethod({
            AdvanceStringIndex,
            GetMethod,
            IsArray
          }, obj);
        }
      }
      var iterator = Call(actualMethod, obj);
      if (Type(iterator) !== "Object") {
        throw new $TypeError("iterator must return an object");
      }
      return iterator;
    };
  }
});

// node_modules/es-abstract/2021/IteratorClose.js
var require_IteratorClose = __commonJS({
  "node_modules/es-abstract/2021/IteratorClose.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Call = require_Call();
    var GetMethod = require_GetMethod();
    var IsCallable = require_IsCallable();
    var Type = require_Type2();
    module.exports = function IteratorClose(iterator, completion) {
      if (Type(iterator) !== "Object") {
        throw new $TypeError("Assertion failed: Type(iterator) is not Object");
      }
      if (!IsCallable(completion)) {
        throw new $TypeError("Assertion failed: completion is not a thunk for a Completion Record");
      }
      var completionThunk = completion;
      var iteratorReturn = GetMethod(iterator, "return");
      if (typeof iteratorReturn === "undefined") {
        return completionThunk();
      }
      var completionRecord;
      try {
        var innerResult = Call(iteratorReturn, iterator, []);
      } catch (e) {
        completionThunk();
        completionThunk = null;
        throw e;
      }
      completionRecord = completionThunk();
      completionThunk = null;
      if (Type(innerResult) !== "Object") {
        throw new $TypeError("iterator .return must return an object");
      }
      return completionRecord;
    };
  }
});

// node_modules/es-abstract/2021/IteratorComplete.js
var require_IteratorComplete = __commonJS({
  "node_modules/es-abstract/2021/IteratorComplete.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Get = require_Get();
    var ToBoolean = require_ToBoolean();
    var Type = require_Type2();
    module.exports = function IteratorComplete(iterResult) {
      if (Type(iterResult) !== "Object") {
        throw new $TypeError("Assertion failed: Type(iterResult) is not Object");
      }
      return ToBoolean(Get(iterResult, "done"));
    };
  }
});

// node_modules/es-abstract/2021/Invoke.js
var require_Invoke = __commonJS({
  "node_modules/es-abstract/2021/Invoke.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Call = require_Call();
    var IsArray = require_IsArray2();
    var GetV = require_GetV();
    var IsPropertyKey = require_IsPropertyKey();
    module.exports = function Invoke(O, P) {
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      var argumentsList = arguments.length > 2 ? arguments[2] : [];
      if (!IsArray(argumentsList)) {
        throw new $TypeError("Assertion failed: optional `argumentsList`, if provided, must be a List");
      }
      var func = GetV(O, P);
      return Call(func, O, argumentsList);
    };
  }
});

// node_modules/es-abstract/2021/IteratorNext.js
var require_IteratorNext = __commonJS({
  "node_modules/es-abstract/2021/IteratorNext.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Invoke = require_Invoke();
    var Type = require_Type2();
    module.exports = function IteratorNext(iterator, value) {
      var result = Invoke(iterator, "next", arguments.length < 2 ? [] : [value]);
      if (Type(result) !== "Object") {
        throw new $TypeError("iterator next must return an object");
      }
      return result;
    };
  }
});

// node_modules/es-abstract/2021/IteratorStep.js
var require_IteratorStep = __commonJS({
  "node_modules/es-abstract/2021/IteratorStep.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var IteratorComplete = require_IteratorComplete();
    var IteratorNext = require_IteratorNext();
    module.exports = function IteratorStep(iterator) {
      var result = IteratorNext(iterator);
      var done = IteratorComplete(result);
      return done === true ? false : result;
    };
  }
});

// node_modules/es-abstract/2021/IteratorValue.js
var require_IteratorValue = __commonJS({
  "node_modules/es-abstract/2021/IteratorValue.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Get = require_Get();
    var Type = require_Type2();
    module.exports = function IteratorValue(iterResult) {
      if (Type(iterResult) !== "Object") {
        throw new $TypeError("Assertion failed: Type(iterResult) is not Object");
      }
      return Get(iterResult, "value");
    };
  }
});

// node_modules/es-abstract/2021/AddEntriesFromIterable.js
var require_AddEntriesFromIterable = __commonJS({
  "node_modules/es-abstract/2021/AddEntriesFromIterable.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var inspect = require_object_inspect();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Call = require_Call();
    var Get = require_Get();
    var GetIterator = require_GetIterator();
    var IsCallable = require_IsCallable();
    var IteratorClose = require_IteratorClose();
    var IteratorStep = require_IteratorStep();
    var IteratorValue = require_IteratorValue();
    var Type = require_Type2();
    module.exports = function AddEntriesFromIterable(target, iterable, adder) {
      if (!IsCallable(adder)) {
        throw new $TypeError("Assertion failed: `adder` is not callable");
      }
      if (iterable == null) {
        throw new $TypeError("Assertion failed: `iterable` is present, and not nullish");
      }
      var iteratorRecord = GetIterator(iterable);
      while (true) {
        var next = IteratorStep(iteratorRecord);
        if (!next) {
          return target;
        }
        var nextItem = IteratorValue(next);
        if (Type(nextItem) !== "Object") {
          var error = new $TypeError("iterator next must return an Object, got " + inspect(nextItem));
          return IteratorClose(
            iteratorRecord,
            function() {
              throw error;
            }
          );
        }
        try {
          var k = Get(nextItem, "0");
          var v = Get(nextItem, "1");
          Call(adder, target, [k, v]);
        } catch (e) {
          return IteratorClose(iteratorRecord, function() {
            throw e;
          });
        }
      }
    };
  }
});

// node_modules/es-abstract/2021/ToPropertyKey.js
var require_ToPropertyKey = __commonJS({
  "node_modules/es-abstract/2021/ToPropertyKey.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $String = GetIntrinsic("%String%");
    var ToPrimitive = require_ToPrimitive();
    var ToString = require_ToString();
    module.exports = function ToPropertyKey(argument) {
      var key = ToPrimitive(argument, $String);
      return typeof key === "symbol" ? key : ToString(key);
    };
  }
});

// node_modules/object.fromentries/implementation.js
var require_implementation14 = __commonJS({
  "node_modules/object.fromentries/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var AddEntriesFromIterable = require_AddEntriesFromIterable();
    var CreateDataPropertyOrThrow = require_CreateDataPropertyOrThrow();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var ToPropertyKey = require_ToPropertyKey();
    var adder = function addDataProperty(key, value) {
      var O = this;
      var propertyKey = ToPropertyKey(key);
      CreateDataPropertyOrThrow(O, propertyKey, value);
    };
    module.exports = function fromEntries(iterable) {
      RequireObjectCoercible(iterable);
      return AddEntriesFromIterable({}, iterable, adder);
    };
  }
});

// node_modules/object.fromentries/polyfill.js
var require_polyfill13 = __commonJS({
  "node_modules/object.fromentries/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation14();
    module.exports = function getPolyfill() {
      return typeof Object.fromEntries === "function" ? Object.fromEntries : implementation;
    };
  }
});

// node_modules/object.fromentries/shim.js
var require_shim13 = __commonJS({
  "node_modules/object.fromentries/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var getPolyfill = require_polyfill13();
    var define2 = require_define_properties();
    module.exports = function shimEntries() {
      var polyfill = getPolyfill();
      define2(Object, {
        fromEntries: polyfill
      }, {
        fromEntries: function testEntries() {
          return Object.fromEntries !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object.fromentries/auto.js
var require_auto5 = __commonJS({
  "node_modules/object.fromentries/auto.js"() {
    "use strict";
    init_define_ngDevMode();
    require_shim13()();
  }
});

// node_modules/regexp.prototype.flags/implementation.js
var require_implementation15 = __commonJS({
  "node_modules/regexp.prototype.flags/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
    var $Object = Object;
    var $TypeError = TypeError;
    module.exports = function flags() {
      if (this != null && this !== $Object(this)) {
        throw new $TypeError("RegExp.prototype.flags getter called on non-object");
      }
      var result = "";
      if (this.hasIndices) {
        result += "d";
      }
      if (this.global) {
        result += "g";
      }
      if (this.ignoreCase) {
        result += "i";
      }
      if (this.multiline) {
        result += "m";
      }
      if (this.dotAll) {
        result += "s";
      }
      if (this.unicode) {
        result += "u";
      }
      if (this.sticky) {
        result += "y";
      }
      return result;
    };
    if (functionsHaveConfigurableNames && Object.defineProperty) {
      Object.defineProperty(module.exports, "name", {
        value: "get flags"
      });
    }
  }
});

// node_modules/regexp.prototype.flags/polyfill.js
var require_polyfill14 = __commonJS({
  "node_modules/regexp.prototype.flags/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation15();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    module.exports = function getPolyfill() {
      if (supportsDescriptors && /a/mig.flags === "gim") {
        var descriptor = $gOPD(RegExp.prototype, "flags");
        if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
          var calls = "";
          var o = {};
          Object.defineProperty(o, "hasIndices", {
            get: function() {
              calls += "d";
            }
          });
          Object.defineProperty(o, "sticky", {
            get: function() {
              calls += "y";
            }
          });
          if (calls === "dy") {
            return descriptor.get;
          }
        }
      }
      return implementation;
    };
  }
});

// node_modules/regexp.prototype.flags/shim.js
var require_shim14 = __commonJS({
  "node_modules/regexp.prototype.flags/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var getPolyfill = require_polyfill14();
    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;
    module.exports = function shimFlags() {
      if (!supportsDescriptors || !getProto) {
        throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      var polyfill = getPolyfill();
      var proto = getProto(regex);
      var descriptor = gOPD(proto, "flags");
      if (!descriptor || descriptor.get !== polyfill) {
        defineProperty(proto, "flags", {
          configurable: true,
          enumerable: false,
          get: polyfill
        });
      }
      return polyfill;
    };
  }
});

// node_modules/regexp.prototype.flags/index.js
var require_regexp_prototype = __commonJS({
  "node_modules/regexp.prototype.flags/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation15();
    var getPolyfill = require_polyfill14();
    var shim = require_shim14();
    var flagsBound = callBind(getPolyfill());
    define2(flagsBound, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = flagsBound;
  }
});

// node_modules/es-abstract/2021/CreateIterResultObject.js
var require_CreateIterResultObject = __commonJS({
  "node_modules/es-abstract/2021/CreateIterResultObject.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Type = require_Type2();
    module.exports = function CreateIterResultObject(value, done) {
      if (Type(done) !== "Boolean") {
        throw new $TypeError("Assertion failed: Type(done) is not Boolean");
      }
      return {
        value,
        done
      };
    };
  }
});

// node_modules/es-abstract/2021/CreateMethodProperty.js
var require_CreateMethodProperty = __commonJS({
  "node_modules/es-abstract/2021/CreateMethodProperty.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var DefineOwnProperty = require_DefineOwnProperty();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    module.exports = function CreateMethodProperty(O, P, V) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var newDesc = {
        "[[Configurable]]": true,
        "[[Enumerable]]": false,
        "[[Value]]": V,
        "[[Writable]]": true
      };
      return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, newDesc);
    };
  }
});

// node_modules/es-abstract/2021/OrdinaryObjectCreate.js
var require_OrdinaryObjectCreate = __commonJS({
  "node_modules/es-abstract/2021/OrdinaryObjectCreate.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $ObjectCreate = GetIntrinsic("%Object.create%", true);
    var $TypeError = GetIntrinsic("%TypeError%");
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var IsArray = require_IsArray2();
    var Type = require_Type2();
    var hasProto = !({
      __proto__: null
    } instanceof Object);
    module.exports = function OrdinaryObjectCreate(proto) {
      if (proto !== null && Type(proto) !== "Object") {
        throw new $TypeError("Assertion failed: `proto` must be null or an object");
      }
      var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
      if (!IsArray(additionalInternalSlotsList)) {
        throw new $TypeError("Assertion failed: `additionalInternalSlotsList` must be an Array");
      }
      if (additionalInternalSlotsList.length > 0) {
        throw new $SyntaxError("es-abstract does not yet support internal slots");
      }
      if ($ObjectCreate) {
        return $ObjectCreate(proto);
      }
      if (hasProto) {
        return {
          __proto__: proto
        };
      }
      if (proto === null) {
        throw new $SyntaxError("native Object.create support is required to create null objects");
      }
      var T = function T2() {
      };
      T.prototype = proto;
      return new T();
    };
  }
});

// node_modules/es-abstract/2021/RegExpExec.js
var require_RegExpExec = __commonJS({
  "node_modules/es-abstract/2021/RegExpExec.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var regexExec = require_callBound()("RegExp.prototype.exec");
    var Call = require_Call();
    var Get = require_Get();
    var IsCallable = require_IsCallable();
    var Type = require_Type2();
    module.exports = function RegExpExec(R, S) {
      if (Type(R) !== "Object") {
        throw new $TypeError("Assertion failed: `R` must be an Object");
      }
      if (Type(S) !== "String") {
        throw new $TypeError("Assertion failed: `S` must be a String");
      }
      var exec = Get(R, "exec");
      if (IsCallable(exec)) {
        var result = Call(exec, R, [S]);
        if (result === null || Type(result) === "Object") {
          return result;
        }
        throw new $TypeError('"exec" method must return `null` or an Object');
      }
      return regexExec(R, S);
    };
  }
});

// node_modules/es-abstract/2021/Set.js
var require_Set = __commonJS({
  "node_modules/es-abstract/2021/Set.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    var noThrowOnStrictViolation = function() {
      try {
        delete [].length;
        return true;
      } catch (e) {
        return false;
      }
    }();
    module.exports = function Set2(O, P, V, Throw) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: `O` must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: `P` must be a Property Key");
      }
      if (Type(Throw) !== "Boolean") {
        throw new $TypeError("Assertion failed: `Throw` must be a Boolean");
      }
      if (Throw) {
        O[P] = V;
        if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
          throw new $TypeError("Attempted to assign to readonly property.");
        }
        return true;
      }
      try {
        O[P] = V;
        return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
      } catch (e) {
        return false;
      }
    };
  }
});

// node_modules/internal-slot/index.js
var require_internal_slot = __commonJS({
  "node_modules/internal-slot/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var has = require_src();
    var channel = require_side_channel()();
    var $TypeError = GetIntrinsic("%TypeError%");
    var SLOT = {
      assert: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        channel.assert(O);
      },
      get: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        return slots && slots["$" + slot];
      },
      has: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        return !!slots && has(slots, "$" + slot);
      },
      set: function(O, slot, V) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        if (!slots) {
          slots = {};
          channel.set(O, slots);
        }
        slots["$" + slot] = V;
      }
    };
    if (Object.freeze) {
      Object.freeze(SLOT);
    }
    module.exports = SLOT;
  }
});

// node_modules/es-abstract/2021/CreateRegExpStringIterator.js
var require_CreateRegExpStringIterator = __commonJS({
  "node_modules/es-abstract/2021/CreateRegExpStringIterator.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var hasSymbols = require_has_symbols()();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IteratorPrototype = GetIntrinsic("%IteratorPrototype%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var AdvanceStringIndex = require_AdvanceStringIndex();
    var CreateIterResultObject = require_CreateIterResultObject();
    var CreateMethodProperty = require_CreateMethodProperty();
    var Get = require_Get();
    var OrdinaryObjectCreate = require_OrdinaryObjectCreate();
    var RegExpExec = require_RegExpExec();
    var Set2 = require_Set();
    var ToLength = require_ToLength();
    var ToString = require_ToString();
    var Type = require_Type2();
    var SLOT = require_internal_slot();
    var RegExpStringIterator = function RegExpStringIterator2(R, S, global2, fullUnicode) {
      if (Type(S) !== "String") {
        throw new $TypeError("`S` must be a string");
      }
      if (Type(global2) !== "Boolean") {
        throw new $TypeError("`global` must be a boolean");
      }
      if (Type(fullUnicode) !== "Boolean") {
        throw new $TypeError("`fullUnicode` must be a boolean");
      }
      SLOT.set(this, "[[IteratingRegExp]]", R);
      SLOT.set(this, "[[IteratedString]]", S);
      SLOT.set(this, "[[Global]]", global2);
      SLOT.set(this, "[[Unicode]]", fullUnicode);
      SLOT.set(this, "[[Done]]", false);
    };
    if (IteratorPrototype) {
      RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);
    }
    var RegExpStringIteratorNext = function next() {
      var O = this;
      if (Type(O) !== "Object") {
        throw new $TypeError("receiver must be an object");
      }
      if (!(O instanceof RegExpStringIterator) || !SLOT.has(O, "[[IteratingRegExp]]") || !SLOT.has(O, "[[IteratedString]]") || !SLOT.has(O, "[[Global]]") || !SLOT.has(O, "[[Unicode]]") || !SLOT.has(O, "[[Done]]")) {
        throw new $TypeError('"this" value must be a RegExpStringIterator instance');
      }
      if (SLOT.get(O, "[[Done]]")) {
        return CreateIterResultObject(void 0, true);
      }
      var R = SLOT.get(O, "[[IteratingRegExp]]");
      var S = SLOT.get(O, "[[IteratedString]]");
      var global2 = SLOT.get(O, "[[Global]]");
      var fullUnicode = SLOT.get(O, "[[Unicode]]");
      var match = RegExpExec(R, S);
      if (match === null) {
        SLOT.set(O, "[[Done]]", true);
        return CreateIterResultObject(void 0, true);
      }
      if (global2) {
        var matchStr = ToString(Get(match, "0"));
        if (matchStr === "") {
          var thisIndex = ToLength(Get(R, "lastIndex"));
          var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
          Set2(R, "lastIndex", nextIndex, true);
        }
        return CreateIterResultObject(match, false);
      }
      SLOT.set(O, "[[Done]]", true);
      return CreateIterResultObject(match, false);
    };
    CreateMethodProperty(RegExpStringIterator.prototype, "next", RegExpStringIteratorNext);
    if (hasSymbols) {
      if (Symbol.toStringTag) {
        if ($defineProperty) {
          $defineProperty(RegExpStringIterator.prototype, Symbol.toStringTag, {
            configurable: true,
            enumerable: false,
            value: "RegExp String Iterator",
            writable: false
          });
        } else {
          RegExpStringIterator.prototype[Symbol.toStringTag] = "RegExp String Iterator";
        }
      }
      if (Symbol.iterator && typeof RegExpStringIterator.prototype[Symbol.iterator] !== "function") {
        iteratorFn = function SymbolIterator() {
          return this;
        };
        CreateMethodProperty(RegExpStringIterator.prototype, Symbol.iterator, iteratorFn);
      }
    }
    var iteratorFn;
    module.exports = function CreateRegExpStringIterator(R, S, global2, fullUnicode) {
      return new RegExpStringIterator(R, S, global2, fullUnicode);
    };
  }
});

// node_modules/string.prototype.matchall/regexp-matchall.js
var require_regexp_matchall = __commonJS({
  "node_modules/string.prototype.matchall/regexp-matchall.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var CreateRegExpStringIterator = require_CreateRegExpStringIterator();
    var Get = require_Get();
    var Set2 = require_Set();
    var SpeciesConstructor = require_SpeciesConstructor();
    var ToLength = require_ToLength();
    var ToString = require_ToString();
    var Type = require_Type2();
    var flagsGetter = require_regexp_prototype();
    var callBound = require_callBound();
    var $indexOf = callBound("String.prototype.indexOf");
    var OrigRegExp = RegExp;
    var supportsConstructingWithFlags = "flags" in RegExp.prototype;
    var constructRegexWithFlags = function constructRegex(C, R) {
      var matcher;
      var flags = "flags" in R ? Get(R, "flags") : ToString(flagsGetter(R));
      if (supportsConstructingWithFlags && typeof flags === "string") {
        matcher = new C(R, flags);
      } else if (C === OrigRegExp) {
        matcher = new C(R.source, flags);
      } else {
        matcher = new C(R, flags);
      }
      return {
        flags,
        matcher
      };
    };
    var regexMatchAll = function SymbolMatchAll(string) {
      var R = this;
      if (Type(R) !== "Object") {
        throw new TypeError('"this" value must be an Object');
      }
      var S = ToString(string);
      var C = SpeciesConstructor(R, OrigRegExp);
      var tmp = constructRegexWithFlags(C, R);
      var flags = tmp.flags;
      var matcher = tmp.matcher;
      var lastIndex = ToLength(Get(R, "lastIndex"));
      Set2(matcher, "lastIndex", lastIndex, true);
      var global2 = $indexOf(flags, "g") > -1;
      var fullUnicode = $indexOf(flags, "u") > -1;
      return CreateRegExpStringIterator(matcher, S, global2, fullUnicode);
    };
    var defineP = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    if (defineP && gOPD) {
      desc = gOPD(regexMatchAll, "name");
      if (desc && desc.configurable) {
        defineP(regexMatchAll, "name", {
          value: "[Symbol.matchAll]"
        });
      }
    }
    var desc;
    module.exports = regexMatchAll;
  }
});

// node_modules/string.prototype.matchall/polyfill-regexp-matchall.js
var require_polyfill_regexp_matchall = __commonJS({
  "node_modules/string.prototype.matchall/polyfill-regexp-matchall.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var hasSymbols = require_has_symbols()();
    var regexpMatchAll = require_regexp_matchall();
    module.exports = function getRegExpMatchAllPolyfill() {
      if (!hasSymbols || typeof Symbol.matchAll !== "symbol" || typeof RegExp.prototype[Symbol.matchAll] !== "function") {
        return regexpMatchAll;
      }
      return RegExp.prototype[Symbol.matchAll];
    };
  }
});

// node_modules/string.prototype.matchall/implementation.js
var require_implementation16 = __commonJS({
  "node_modules/string.prototype.matchall/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var Call = require_Call();
    var Get = require_Get();
    var GetMethod = require_GetMethod();
    var IsRegExp = require_IsRegExp();
    var ToString = require_ToString();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var hasSymbols = require_has_symbols()();
    var flagsGetter = require_regexp_prototype();
    var $indexOf = callBound("String.prototype.indexOf");
    var regexpMatchAllPolyfill = require_polyfill_regexp_matchall();
    var getMatcher = function getMatcher2(regexp) {
      var matcherPolyfill = regexpMatchAllPolyfill();
      if (hasSymbols && typeof Symbol.matchAll === "symbol") {
        var matcher = GetMethod(regexp, Symbol.matchAll);
        if (matcher === RegExp.prototype[Symbol.matchAll] && matcher !== matcherPolyfill) {
          return matcherPolyfill;
        }
        return matcher;
      }
      if (IsRegExp(regexp)) {
        return matcherPolyfill;
      }
    };
    module.exports = function matchAll(regexp) {
      var O = RequireObjectCoercible(this);
      if (typeof regexp !== "undefined" && regexp !== null) {
        var isRegExp = IsRegExp(regexp);
        if (isRegExp) {
          var flags = "flags" in regexp ? Get(regexp, "flags") : flagsGetter(regexp);
          RequireObjectCoercible(flags);
          if ($indexOf(ToString(flags), "g") < 0) {
            throw new TypeError("matchAll requires a global regular expression");
          }
        }
        var matcher = getMatcher(regexp);
        if (typeof matcher !== "undefined") {
          return Call(matcher, regexp, [O]);
        }
      }
      var S = ToString(O);
      var rx = new RegExp(regexp, "g");
      return Call(getMatcher(rx), rx, [S]);
    };
  }
});

// node_modules/string.prototype.matchall/polyfill.js
var require_polyfill15 = __commonJS({
  "node_modules/string.prototype.matchall/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation16();
    module.exports = function getPolyfill() {
      if (String.prototype.matchAll) {
        try {
          "".matchAll(RegExp.prototype);
        } catch (e) {
          return String.prototype.matchAll;
        }
      }
      return implementation;
    };
  }
});

// node_modules/string.prototype.matchall/shim.js
var require_shim15 = __commonJS({
  "node_modules/string.prototype.matchall/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var define2 = require_define_properties();
    var hasSymbols = require_has_symbols()();
    var getPolyfill = require_polyfill15();
    var regexpMatchAllPolyfill = require_polyfill_regexp_matchall();
    var defineP = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    module.exports = function shimMatchAll() {
      var polyfill = getPolyfill();
      define2(String.prototype, {
        matchAll: polyfill
      }, {
        matchAll: function() {
          return String.prototype.matchAll !== polyfill;
        }
      });
      if (hasSymbols) {
        var symbol = Symbol.matchAll || (Symbol["for"] ? Symbol["for"]("Symbol.matchAll") : Symbol("Symbol.matchAll"));
        define2(Symbol, {
          matchAll: symbol
        }, {
          matchAll: function() {
            return Symbol.matchAll !== symbol;
          }
        });
        if (defineP && gOPD) {
          var desc = gOPD(Symbol, symbol);
          if (!desc || desc.configurable) {
            defineP(Symbol, symbol, {
              configurable: false,
              enumerable: false,
              value: symbol,
              writable: false
            });
          }
        }
        var regexpMatchAll = regexpMatchAllPolyfill();
        var func = {};
        func[symbol] = regexpMatchAll;
        var predicate = {};
        predicate[symbol] = function() {
          return RegExp.prototype[symbol] !== regexpMatchAll;
        };
        define2(RegExp.prototype, func, predicate);
      }
      return polyfill;
    };
  }
});

// node_modules/string.prototype.matchall/auto.js
var require_auto6 = __commonJS({
  "node_modules/string.prototype.matchall/auto.js"() {
    "use strict";
    init_define_ngDevMode();
    require_shim15()();
  }
});

// node_modules/globalthis/implementation.browser.js
var require_implementation_browser = __commonJS({
  "node_modules/globalthis/implementation.browser.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    if (typeof self !== "undefined") {
      module.exports = self;
    } else if (typeof window !== "undefined") {
      module.exports = window;
    } else {
      module.exports = Function("return this")();
    }
  }
});

// node_modules/globalthis/polyfill.js
var require_polyfill16 = __commonJS({
  "node_modules/globalthis/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var implementation = require_implementation_browser();
    module.exports = function getPolyfill() {
      if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
        return implementation;
      }
      return global;
    };
  }
});

// node_modules/globalthis/shim.js
var require_shim16 = __commonJS({
  "node_modules/globalthis/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill16();
    module.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define2.supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// node_modules/globalthis/auto.js
var require_auto7 = __commonJS({
  "node_modules/globalthis/auto.js"() {
    "use strict";
    init_define_ngDevMode();
    require_shim16()();
  }
});

// node_modules/promise.allsettled/requirePromise.js
var require_requirePromise2 = __commonJS({
  "node_modules/promise.allsettled/requirePromise.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    module.exports = function requirePromise() {
      if (typeof Promise !== "function") {
        throw new TypeError("`Promise.allSettled` requires a global `Promise` be available.");
      }
    };
  }
});

// node_modules/es-abstract/2021/PromiseResolve.js
var require_PromiseResolve = __commonJS({
  "node_modules/es-abstract/2021/PromiseResolve.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $resolve = GetIntrinsic("%Promise.resolve%", true);
    var $PromiseResolve = $resolve && callBind($resolve);
    module.exports = function PromiseResolve(C, x) {
      if (!$PromiseResolve) {
        throw new SyntaxError("This environment does not support Promises.");
      }
      return $PromiseResolve(C, x);
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/es-get-iterator/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/es-get-iterator/node_modules/isarray/index.js"(exports, module) {
    init_define_ngDevMode();
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/is-map/index.js
var require_is_map = __commonJS({
  "node_modules/is-map/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Map) {
      exported = function isMap(x) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$mapHas) {
      exported = function isMap(x) {
        return false;
      };
    }
    module.exports = exported || function isMap(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      try {
        $mapHas.call(x);
        if ($setHas) {
          try {
            $setHas.call(x);
          } catch (e) {
            return true;
          }
        }
        return x instanceof $Map;
      } catch (e) {
      }
      return false;
    };
  }
});

// node_modules/is-set/index.js
var require_is_set = __commonJS({
  "node_modules/is-set/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var $Map = typeof Map === "function" && Map.prototype ? Map : null;
    var $Set = typeof Set === "function" && Set.prototype ? Set : null;
    var exported;
    if (!$Set) {
      exported = function isSet(x) {
        return false;
      };
    }
    var $mapHas = $Map ? Map.prototype.has : null;
    var $setHas = $Set ? Set.prototype.has : null;
    if (!exported && !$setHas) {
      exported = function isSet(x) {
        return false;
      };
    }
    module.exports = exported || function isSet(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      try {
        $setHas.call(x);
        if ($mapHas) {
          try {
            $mapHas.call(x);
          } catch (e) {
            return true;
          }
        }
        return x instanceof $Set;
      } catch (e) {
      }
      return false;
    };
  }
});

// node_modules/es-get-iterator/index.js
var require_es_get_iterator = __commonJS({
  "node_modules/es-get-iterator/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var isArguments = require_is_arguments();
    if (require_has_symbols()() || require_shams()()) {
      $iterator = Symbol.iterator;
      module.exports = function getIterator(iterable) {
        if (iterable != null && typeof iterable[$iterator] !== "undefined") {
          return iterable[$iterator]();
        }
        if (isArguments(iterable)) {
          return Array.prototype[$iterator].call(iterable);
        }
      };
    } else {
      isArray = require_isarray();
      isString = require_is_string();
      GetIntrinsic = require_get_intrinsic();
      $Map = GetIntrinsic("%Map%", true);
      $Set = GetIntrinsic("%Set%", true);
      callBound = require_callBound();
      $arrayPush = callBound("Array.prototype.push");
      $charCodeAt = callBound("String.prototype.charCodeAt");
      $stringSlice = callBound("String.prototype.slice");
      advanceStringIndex = function advanceStringIndex2(S, index) {
        var length = S.length;
        if (index + 1 >= length) {
          return index + 1;
        }
        var first = $charCodeAt(S, index);
        if (first < 55296 || first > 56319) {
          return index + 1;
        }
        var second = $charCodeAt(S, index + 1);
        if (second < 56320 || second > 57343) {
          return index + 1;
        }
        return index + 2;
      };
      getArrayIterator = function getArrayIterator2(arraylike) {
        var i = 0;
        return {
          next: function next() {
            var done = i >= arraylike.length;
            var value;
            if (!done) {
              value = arraylike[i];
              i += 1;
            }
            return {
              done,
              value
            };
          }
        };
      };
      getNonCollectionIterator = function getNonCollectionIterator2(iterable, noPrimordialCollections) {
        if (isArray(iterable) || isArguments(iterable)) {
          return getArrayIterator(iterable);
        }
        if (isString(iterable)) {
          var i = 0;
          return {
            next: function next() {
              var nextIndex = advanceStringIndex(iterable, i);
              var value = $stringSlice(iterable, i, nextIndex);
              i = nextIndex;
              return {
                done: nextIndex > iterable.length,
                value
              };
            }
          };
        }
        if (noPrimordialCollections && typeof iterable["_es6-shim iterator_"] !== "undefined") {
          return iterable["_es6-shim iterator_"]();
        }
      };
      if (!$Map && !$Set) {
        module.exports = function getIterator(iterable) {
          if (iterable != null) {
            return getNonCollectionIterator(iterable, true);
          }
        };
      } else {
        isMap = require_is_map();
        isSet = require_is_set();
        $mapForEach = callBound("Map.prototype.forEach", true);
        $setForEach = callBound("Set.prototype.forEach", true);
        if (typeof process === "undefined" || !process.versions || !process.versions.node) {
          $mapIterator = callBound("Map.prototype.iterator", true);
          $setIterator = callBound("Set.prototype.iterator", true);
          getStopIterationIterator = function(iterator) {
            var done = false;
            return {
              next: function next() {
                try {
                  return {
                    done,
                    value: done ? void 0 : iterator.next()
                  };
                } catch (e) {
                  done = true;
                  return {
                    done: true,
                    value: void 0
                  };
                }
              }
            };
          };
        }
        $mapAtAtIterator = callBound("Map.prototype.@@iterator", true) || callBound("Map.prototype._es6-shim iterator_", true);
        $setAtAtIterator = callBound("Set.prototype.@@iterator", true) || callBound("Set.prototype._es6-shim iterator_", true);
        getCollectionIterator = function getCollectionIterator2(iterable) {
          if (isMap(iterable)) {
            if ($mapIterator) {
              return getStopIterationIterator($mapIterator(iterable));
            }
            if ($mapAtAtIterator) {
              return $mapAtAtIterator(iterable);
            }
            if ($mapForEach) {
              var entries = [];
              $mapForEach(iterable, function(v, k) {
                $arrayPush(entries, [k, v]);
              });
              return getArrayIterator(entries);
            }
          }
          if (isSet(iterable)) {
            if ($setIterator) {
              return getStopIterationIterator($setIterator(iterable));
            }
            if ($setAtAtIterator) {
              return $setAtAtIterator(iterable);
            }
            if ($setForEach) {
              var values = [];
              $setForEach(iterable, function(v) {
                $arrayPush(values, v);
              });
              return getArrayIterator(values);
            }
          }
        };
        module.exports = function getIterator(iterable) {
          return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
        };
      }
    }
    var $iterator;
    var isArray;
    var isString;
    var GetIntrinsic;
    var $Map;
    var $Set;
    var callBound;
    var $arrayPush;
    var $charCodeAt;
    var $stringSlice;
    var advanceStringIndex;
    var getArrayIterator;
    var getNonCollectionIterator;
    var isMap;
    var isSet;
    var $mapForEach;
    var $setForEach;
    var $mapIterator;
    var $setIterator;
    var getStopIterationIterator;
    var $mapAtAtIterator;
    var $setAtAtIterator;
    var getCollectionIterator;
  }
});

// node_modules/iterate-iterator/index.js
var require_iterate_iterator = __commonJS({
  "node_modules/iterate-iterator/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var $TypeError = TypeError;
    module.exports = function iterateIterator(iterator) {
      if (!iterator || typeof iterator.next !== "function") {
        throw new $TypeError("iterator must be an object with a `next` method");
      }
      if (arguments.length > 1) {
        var callback = arguments[1];
        if (typeof callback !== "function") {
          throw new $TypeError("`callback`, if provided, must be a function");
        }
      }
      var values = callback || [];
      var result;
      while ((result = iterator.next()) && !result.done) {
        if (callback) {
          callback(result.value);
        } else {
          values.push(result.value);
        }
      }
      if (!callback) {
        return values;
      }
    };
  }
});

// node_modules/iterate-value/index.js
var require_iterate_value = __commonJS({
  "node_modules/iterate-value/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var getIterator = require_es_get_iterator();
    var $TypeError = TypeError;
    var iterate = require_iterate_iterator();
    module.exports = function iterateValue(iterable) {
      var iterator = getIterator(iterable);
      if (!iterator) {
        throw new $TypeError("non-iterable value provided");
      }
      if (arguments.length > 1) {
        return iterate(iterator, arguments[1]);
      }
      return iterate(iterator);
    };
  }
});

// node_modules/es-abstract/2021/ToUint32.js
var require_ToUint32 = __commonJS({
  "node_modules/es-abstract/2021/ToUint32.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var ToNumber = require_ToNumber();
    module.exports = function ToUint32(x) {
      return ToNumber(x) >>> 0;
    };
  }
});

// node_modules/array.prototype.map/implementation.js
var require_implementation17 = __commonJS({
  "node_modules/array.prototype.map/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var ArraySpeciesCreate = require_ArraySpeciesCreate();
    var Call = require_Call();
    var CreateDataPropertyOrThrow = require_CreateDataPropertyOrThrow();
    var Get = require_Get();
    var HasProperty = require_HasProperty();
    var IsCallable = require_IsCallable();
    var ToUint32 = require_ToUint32();
    var ToObject = require_ToObject();
    var ToString = require_ToString();
    var callBound = require_callBound();
    var isString = require_is_string();
    var boxedString = Object("a");
    var splitString = boxedString[0] !== "a" || !(0 in boxedString);
    var strSplit = callBound("String.prototype.split");
    module.exports = function map(callbackfn) {
      var O = ToObject(this);
      var self2 = splitString && isString(O) ? strSplit(O, "") : O;
      var len = ToUint32(self2.length);
      if (!IsCallable(callbackfn)) {
        throw new TypeError("Array.prototype.map callback must be a function");
      }
      var T;
      if (arguments.length > 1) {
        T = arguments[1];
      }
      var A = ArraySpeciesCreate(O, len);
      var k = 0;
      while (k < len) {
        var Pk = ToString(k);
        var kPresent = HasProperty(O, Pk);
        if (kPresent) {
          var kValue = Get(O, Pk);
          var mappedValue = Call(callbackfn, T, [kValue, k, O]);
          CreateDataPropertyOrThrow(A, Pk, mappedValue);
        }
        k += 1;
      }
      return A;
    };
  }
});

// node_modules/array.prototype.map/polyfill.js
var require_polyfill17 = __commonJS({
  "node_modules/array.prototype.map/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var arrayMethodBoxesProperly = require_es_array_method_boxes_properly();
    var implementation = require_implementation17();
    module.exports = function getPolyfill() {
      var method = Array.prototype.map;
      return arrayMethodBoxesProperly(method) ? method : implementation;
    };
  }
});

// node_modules/array.prototype.map/shim.js
var require_shim17 = __commonJS({
  "node_modules/array.prototype.map/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill17();
    module.exports = function shimArrayPrototypeMap() {
      var polyfill = getPolyfill();
      define2(Array.prototype, {
        map: polyfill
      }, {
        map: function() {
          return Array.prototype.map !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/array.prototype.map/index.js
var require_array_prototype2 = __commonJS({
  "node_modules/array.prototype.map/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var define2 = require_define_properties();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var implementation = require_implementation17();
    var getPolyfill = require_polyfill17();
    var polyfill = getPolyfill();
    var shim = require_shim17();
    var $slice = callBound("Array.prototype.slice");
    var boundMapShim = function map(array, callbackfn) {
      RequireObjectCoercible(array);
      return polyfill.apply(array, $slice(arguments, 1));
    };
    define2(boundMapShim, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = boundMapShim;
  }
});

// node_modules/promise.allsettled/implementation.js
var require_implementation18 = __commonJS({
  "node_modules/promise.allsettled/implementation.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var requirePromise = require_requirePromise2();
    requirePromise();
    var PromiseResolve = require_PromiseResolve();
    var Type = require_Type2();
    var iterate = require_iterate_value();
    var map = require_array_prototype2();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var all = callBind(GetIntrinsic("%Promise.all%"));
    var reject = callBind(GetIntrinsic("%Promise.reject%"));
    module.exports = function allSettled(iterable) {
      var C = this;
      if (Type(C) !== "Object") {
        throw new TypeError("`this` value must be an object");
      }
      var values = iterate(iterable);
      return all(C, map(values, function(item) {
        var onFulfill = function(value) {
          return {
            status: "fulfilled",
            value
          };
        };
        var onReject = function(reason) {
          return {
            status: "rejected",
            reason
          };
        };
        var itemPromise = PromiseResolve(C, item);
        try {
          return itemPromise.then(onFulfill, onReject);
        } catch (e) {
          return reject(C, e);
        }
      }));
    };
  }
});

// node_modules/promise.allsettled/polyfill.js
var require_polyfill18 = __commonJS({
  "node_modules/promise.allsettled/polyfill.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var requirePromise = require_requirePromise2();
    var implementation = require_implementation18();
    module.exports = function getPolyfill() {
      requirePromise();
      return typeof Promise.allSettled === "function" ? Promise.allSettled : implementation;
    };
  }
});

// node_modules/promise.allsettled/shim.js
var require_shim18 = __commonJS({
  "node_modules/promise.allsettled/shim.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var requirePromise = require_requirePromise2();
    var getPolyfill = require_polyfill18();
    var define2 = require_define_properties();
    module.exports = function shimAllSettled() {
      requirePromise();
      var polyfill = getPolyfill();
      define2(Promise, {
        allSettled: polyfill
      }, {
        allSettled: function testAllSettled() {
          return Promise.allSettled !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/promise.allsettled/auto.js
var require_auto8 = __commonJS({
  "node_modules/promise.allsettled/auto.js"() {
    "use strict";
    init_define_ngDevMode();
    require_shim18()();
  }
});

// node_modules/airbnb-js-shims/target/es2020.js
var require_es2020 = __commonJS({
  "node_modules/airbnb-js-shims/target/es2020.js"() {
    "use strict";
    init_define_ngDevMode();
    require_auto6();
    require_auto7();
    require_auto8();
  }
});

// node_modules/airbnb-js-shims/target/es2019.js
var require_es2019 = __commonJS({
  "node_modules/airbnb-js-shims/target/es2019.js"() {
    "use strict";
    init_define_ngDevMode();
    require_auto2();
    require_auto3();
    require_auto4();
    require_auto5();
    require_es2020();
  }
});

// node_modules/airbnb-js-shims/target/es2018.js
var require_es2018 = __commonJS({
  "node_modules/airbnb-js-shims/target/es2018.js"() {
    "use strict";
    init_define_ngDevMode();
    if (typeof Promise === "function") {
      require_auto();
    }
    require_es2019();
  }
});

// node_modules/airbnb-js-shims/target/es2017.js
var require_es2017 = __commonJS({
  "node_modules/airbnb-js-shims/target/es2017.js"() {
    "use strict";
    init_define_ngDevMode();
    require_shim3()();
    require_shim4()();
    require_shim5()();
    require_shim6()();
    require_shim8()();
    require_es2018();
  }
});

// node_modules/airbnb-js-shims/target/es2016.js
var require_es2016 = __commonJS({
  "node_modules/airbnb-js-shims/target/es2016.js"() {
    "use strict";
    init_define_ngDevMode();
    require_shim2()();
    require_es2017();
  }
});

// node_modules/airbnb-js-shims/target/es2015.js
var require_es20152 = __commonJS({
  "node_modules/airbnb-js-shims/target/es2015.js"() {
    "use strict";
    init_define_ngDevMode();
    require_es6_shim();
    require_shim()();
    require_es2016();
  }
});

// node_modules/airbnb-js-shims/target/es5.js
var require_es5 = __commonJS({
  "node_modules/airbnb-js-shims/target/es5.js"() {
    "use strict";
    init_define_ngDevMode();
    require_es5_shim();
    require_es5_sham();
    require_es20152();
  }
});

// node_modules/airbnb-js-shims/index.js
var require_airbnb_js_shims = __commonJS({
  "node_modules/airbnb-js-shims/index.js"() {
    "use strict";
    init_define_ngDevMode();
    require_es5();
  }
});

// dep:airbnb-js-shims
init_define_ngDevMode();
var airbnb_js_shims_default = require_airbnb_js_shims();
export {
  airbnb_js_shims_default as default
};
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2020 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */
/*!
 * https://github.com/paulmillr/es6-shim
 * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
 *   and contributors,  MIT License
 * es6-shim: v0.35.4
 * see https://github.com/paulmillr/es6-shim/blob/0.35.3/LICENSE
 * Details and documentation:
 * https://github.com/paulmillr/es6-shim/
 */
//# sourceMappingURL=airbnb-js-shims.js.map
