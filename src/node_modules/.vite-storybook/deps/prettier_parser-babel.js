import {
  __commonJS,
  init_define_ngDevMode
} from "./chunk-XN7ES5DP.js";

// node_modules/prettier/parser-babel.js
var require_parser_babel = __commonJS({
  "node_modules/prettier/parser-babel.js"(exports, module) {
    init_define_ngDevMode();
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : ((t = "undefined" != typeof globalThis ? globalThis : t || self).prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.babel = e());
    }(exports, function() {
      "use strict";
      var t = function(t2, e2) {
        for (var s2 = -1, r2 = e2.length, i2 = t2.length; ++s2 < r2; )
          t2[i2 + s2] = e2[s2];
        return t2;
      }, e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
      function s(t2) {
        return t2 && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
      }
      function r(t2) {
        var e2 = {
          exports: {}
        };
        return t2(e2, e2.exports), e2.exports;
      }
      var i = "object" == typeof e && e && e.Object === Object && e, a = "object" == typeof self && self && self.Object === Object && self, n = (i || a || Function("return this")()).Symbol, o = Object.prototype, u = o.hasOwnProperty, h = o.toString, c = n ? n.toStringTag : void 0;
      var p = function(t2) {
        var e2 = u.call(t2, c), s2 = t2[c];
        try {
          t2[c] = void 0;
          var r2 = true;
        } catch (t3) {
        }
        var i2 = h.call(t2);
        return r2 && (e2 ? t2[c] = s2 : delete t2[c]), i2;
      }, l = Object.prototype.toString;
      var d = function(t2) {
        return l.call(t2);
      }, D = n ? n.toStringTag : void 0;
      var m = function(t2) {
        return null == t2 ? void 0 === t2 ? "[object Undefined]" : "[object Null]" : D && D in Object(t2) ? p(t2) : d(t2);
      };
      var f = function(t2) {
        return null != t2 && "object" == typeof t2;
      };
      var y = function(t2) {
        return f(t2) && "[object Arguments]" == m(t2);
      }, A = Object.prototype, E = A.hasOwnProperty, C = A.propertyIsEnumerable, x = y(function() {
        return arguments;
      }()) ? y : function(t2) {
        return f(t2) && E.call(t2, "callee") && !C.call(t2, "callee");
      }, F = Array.isArray, g = n ? n.isConcatSpreadable : void 0;
      var b = function(t2) {
        return F(t2) || x(t2) || !!(g && t2 && t2[g]);
      };
      var P = function e2(s2, r2, i2, a2, n2) {
        var o2 = -1, u2 = s2.length;
        for (i2 || (i2 = b), n2 || (n2 = []); ++o2 < u2; ) {
          var h2 = s2[o2];
          r2 > 0 && i2(h2) ? r2 > 1 ? e2(h2, r2 - 1, i2, a2, n2) : t(n2, h2) : a2 || (n2[n2.length] = h2);
        }
        return n2;
      };
      var T = function(t2) {
        return (null == t2 ? 0 : t2.length) ? P(t2, 1) : [];
      };
      var w = function(...t2) {
        let e2;
        for (const [s2, r2] of t2.entries())
          try {
            return {
              result: r2()
            };
          } catch (t3) {
            0 === s2 && (e2 = t3);
          }
        return {
          error: e2
        };
      }, B = (t2) => "string" == typeof t2 ? t2.replace((({
        onlyFirst: t3 = false
      } = {}) => {
        const e2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(e2, t3 ? void 0 : "g");
      })(), "") : t2;
      const S = (t2) => !Number.isNaN(t2) && t2 >= 4352 && (t2 <= 4447 || 9001 === t2 || 9002 === t2 || 11904 <= t2 && t2 <= 12871 && 12351 !== t2 || 12880 <= t2 && t2 <= 19903 || 19968 <= t2 && t2 <= 42182 || 43360 <= t2 && t2 <= 43388 || 44032 <= t2 && t2 <= 55203 || 63744 <= t2 && t2 <= 64255 || 65040 <= t2 && t2 <= 65049 || 65072 <= t2 && t2 <= 65131 || 65281 <= t2 && t2 <= 65376 || 65504 <= t2 && t2 <= 65510 || 110592 <= t2 && t2 <= 110593 || 127488 <= t2 && t2 <= 127569 || 131072 <= t2 && t2 <= 262141);
      var N = S, I = S;
      N.default = I;
      const v = (t2) => {
        if ("string" != typeof t2 || 0 === t2.length)
          return 0;
        if (0 === (t2 = B(t2)).length)
          return 0;
        t2 = t2.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
        let e2 = 0;
        for (let s2 = 0; s2 < t2.length; s2++) {
          const r2 = t2.codePointAt(s2);
          r2 <= 31 || r2 >= 127 && r2 <= 159 || r2 >= 768 && r2 <= 879 || (r2 > 65535 && s2++, e2 += N(r2) ? 2 : 1);
        }
        return e2;
      };
      var k = v, L = v;
      k.default = L;
      var O = (t2) => {
        if ("string" != typeof t2)
          throw new TypeError("Expected a string");
        return t2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      };
      var M = (t2) => t2[t2.length - 1];
      function R(t2, e2) {
        return e2 || (e2 = t2.slice(0)), Object.freeze(Object.defineProperties(t2, {
          raw: {
            value: Object.freeze(e2)
          }
        }));
      }
      var j = function(t2) {
        for (var e2 = -1, s2 = null == t2 ? 0 : t2.length, r2 = {}; ++e2 < s2; ) {
          var i2 = t2[e2];
          r2[i2[0]] = i2[1];
        }
        return r2;
      }, _ = void 0 !== _ ? _ : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
      function U() {
        throw new Error("setTimeout has not been defined");
      }
      function q() {
        throw new Error("clearTimeout has not been defined");
      }
      var V = U, H = q;
      function z(t2) {
        if (V === setTimeout)
          return setTimeout(t2, 0);
        if ((V === U || !V) && setTimeout)
          return V = setTimeout, setTimeout(t2, 0);
        try {
          return V(t2, 0);
        } catch (e2) {
          try {
            return V.call(null, t2, 0);
          } catch (e3) {
            return V.call(this, t2, 0);
          }
        }
      }
      "function" == typeof _.setTimeout && (V = setTimeout), "function" == typeof _.clearTimeout && (H = clearTimeout);
      var W, G = [], K = false, X = -1;
      function J() {
        K && W && (K = false, W.length ? G = W.concat(G) : X = -1, G.length && $());
      }
      function $() {
        if (!K) {
          var t2 = z(J);
          K = true;
          for (var e2 = G.length; e2; ) {
            for (W = G, G = []; ++X < e2; )
              W && W[X].run();
            X = -1, e2 = G.length;
          }
          W = null, K = false, function(t3) {
            if (H === clearTimeout)
              return clearTimeout(t3);
            if ((H === q || !H) && clearTimeout)
              return H = clearTimeout, clearTimeout(t3);
            try {
              H(t3);
            } catch (e3) {
              try {
                return H.call(null, t3);
              } catch (e4) {
                return H.call(this, t3);
              }
            }
          }(t2);
        }
      }
      function Y(t2, e2) {
        this.fun = t2, this.array = e2;
      }
      Y.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      function Q() {
      }
      var Z = Q, tt = Q, et = Q, st = Q, rt = Q, it = Q, at = Q;
      var nt = _.performance || {}, ot = nt.now || nt.mozNow || nt.msNow || nt.oNow || nt.webkitNow || function() {
        return new Date().getTime();
      };
      var ut = new Date();
      var ht = {
        nextTick: function(t2) {
          var e2 = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var s2 = 1; s2 < arguments.length; s2++)
              e2[s2 - 1] = arguments[s2];
          G.push(new Y(t2, e2)), 1 !== G.length || K || z($);
        },
        title: "browser",
        browser: true,
        env: {},
        argv: [],
        version: "",
        versions: {},
        on: Z,
        addListener: tt,
        once: et,
        off: st,
        removeListener: rt,
        removeAllListeners: it,
        emit: at,
        binding: function(t2) {
          throw new Error("process.binding is not supported");
        },
        cwd: function() {
          return "/";
        },
        chdir: function(t2) {
          throw new Error("process.chdir is not supported");
        },
        umask: function() {
          return 0;
        },
        hrtime: function(t2) {
          var e2 = 1e-3 * ot.call(nt), s2 = Math.floor(e2), r2 = Math.floor(e2 % 1 * 1e9);
          return t2 && (s2 -= t2[0], (r2 -= t2[1]) < 0 && (s2--, r2 += 1e9)), [s2, r2];
        },
        platform: "browser",
        release: {},
        config: {},
        uptime: function() {
          return (new Date() - ut) / 1e3;
        }
      };
      var ct = "object" == typeof ht && ht.env && ht.env.NODE_DEBUG && /\bsemver\b/i.test(ht.env.NODE_DEBUG) ? (...t2) => console.error("SEMVER", ...t2) : () => {
      };
      var pt = {
        SEMVER_SPEC_VERSION: "2.0.0",
        MAX_LENGTH: 256,
        MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
        MAX_SAFE_COMPONENT_LENGTH: 16
      }, lt = r(function(t2, e2) {
        const {
          MAX_SAFE_COMPONENT_LENGTH: s2
        } = pt, r2 = (e2 = t2.exports = {}).re = [], i2 = e2.src = [], a2 = e2.t = {};
        let n2 = 0;
        const o2 = (t3, e3, s3) => {
          const o3 = n2++;
          ct(o3, e3), a2[t3] = o3, i2[o3] = e3, r2[o3] = new RegExp(e3, s3 ? "g" : void 0);
        };
        o2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o2("MAINVERSION", "(".concat(i2[a2.NUMERICIDENTIFIER], ")\\.") + "(".concat(i2[a2.NUMERICIDENTIFIER], ")\\.") + "(".concat(i2[a2.NUMERICIDENTIFIER], ")")), o2("MAINVERSIONLOOSE", "(".concat(i2[a2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i2[a2.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(i2[a2.NUMERICIDENTIFIERLOOSE], ")")), o2("PRERELEASEIDENTIFIER", "(?:".concat(i2[a2.NUMERICIDENTIFIER], "|").concat(i2[a2.NONNUMERICIDENTIFIER], ")")), o2("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(i2[a2.NUMERICIDENTIFIERLOOSE], "|").concat(i2[a2.NONNUMERICIDENTIFIER], ")")), o2("PRERELEASE", "(?:-(".concat(i2[a2.PRERELEASEIDENTIFIER], "(?:\\.").concat(i2[a2.PRERELEASEIDENTIFIER], ")*))")), o2("PRERELEASELOOSE", "(?:-?(".concat(i2[a2.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(i2[a2.PRERELEASEIDENTIFIERLOOSE], ")*))")), o2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o2("BUILD", "(?:\\+(".concat(i2[a2.BUILDIDENTIFIER], "(?:\\.").concat(i2[a2.BUILDIDENTIFIER], ")*))")), o2("FULLPLAIN", "v?".concat(i2[a2.MAINVERSION]).concat(i2[a2.PRERELEASE], "?").concat(i2[a2.BUILD], "?")), o2("FULL", "^".concat(i2[a2.FULLPLAIN], "$")), o2("LOOSEPLAIN", "[v=\\s]*".concat(i2[a2.MAINVERSIONLOOSE]).concat(i2[a2.PRERELEASELOOSE], "?").concat(i2[a2.BUILD], "?")), o2("LOOSE", "^".concat(i2[a2.LOOSEPLAIN], "$")), o2("GTLT", "((?:<|>)?=?)"), o2("XRANGEIDENTIFIERLOOSE", "".concat(i2[a2.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), o2("XRANGEIDENTIFIER", "".concat(i2[a2.NUMERICIDENTIFIER], "|x|X|\\*")), o2("XRANGEPLAIN", "[v=\\s]*(".concat(i2[a2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i2[a2.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(i2[a2.XRANGEIDENTIFIER], ")") + "(?:".concat(i2[a2.PRERELEASE], ")?").concat(i2[a2.BUILD], "?") + ")?)?"), o2("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(i2[a2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i2[a2.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(i2[a2.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(i2[a2.PRERELEASELOOSE], ")?").concat(i2[a2.BUILD], "?") + ")?)?"), o2("XRANGE", "^".concat(i2[a2.GTLT], "\\s*").concat(i2[a2.XRANGEPLAIN], "$")), o2("XRANGELOOSE", "^".concat(i2[a2.GTLT], "\\s*").concat(i2[a2.XRANGEPLAINLOOSE], "$")), o2("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(s2, "})") + "(?:\\.(\\d{1,".concat(s2, "}))?") + "(?:\\.(\\d{1,".concat(s2, "}))?") + "(?:$|[^\\d])"), o2("COERCERTL", i2[a2.COERCE], true), o2("LONETILDE", "(?:~>?)"), o2("TILDETRIM", "(\\s*)".concat(i2[a2.LONETILDE], "\\s+"), true), e2.tildeTrimReplace = "$1~", o2("TILDE", "^".concat(i2[a2.LONETILDE]).concat(i2[a2.XRANGEPLAIN], "$")), o2("TILDELOOSE", "^".concat(i2[a2.LONETILDE]).concat(i2[a2.XRANGEPLAINLOOSE], "$")), o2("LONECARET", "(?:\\^)"), o2("CARETTRIM", "(\\s*)".concat(i2[a2.LONECARET], "\\s+"), true), e2.caretTrimReplace = "$1^", o2("CARET", "^".concat(i2[a2.LONECARET]).concat(i2[a2.XRANGEPLAIN], "$")), o2("CARETLOOSE", "^".concat(i2[a2.LONECARET]).concat(i2[a2.XRANGEPLAINLOOSE], "$")), o2("COMPARATORLOOSE", "^".concat(i2[a2.GTLT], "\\s*(").concat(i2[a2.LOOSEPLAIN], ")$|^$")), o2("COMPARATOR", "^".concat(i2[a2.GTLT], "\\s*(").concat(i2[a2.FULLPLAIN], ")$|^$")), o2("COMPARATORTRIM", "(\\s*)".concat(i2[a2.GTLT], "\\s*(").concat(i2[a2.LOOSEPLAIN], "|").concat(i2[a2.XRANGEPLAIN], ")"), true), e2.comparatorTrimReplace = "$1$2$3", o2("HYPHENRANGE", "^\\s*(".concat(i2[a2.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(i2[a2.XRANGEPLAIN], ")") + "\\s*$"), o2("HYPHENRANGELOOSE", "^\\s*(".concat(i2[a2.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(i2[a2.XRANGEPLAINLOOSE], ")") + "\\s*$"), o2("STAR", "(<|>)?=?\\s*\\*"), o2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), o2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
      });
      const dt = ["includePrerelease", "loose", "rtl"];
      var Dt = (t2) => t2 ? "object" != typeof t2 ? {
        loose: true
      } : dt.filter((e2) => t2[e2]).reduce((t3, e2) => (t3[e2] = true, t3), {}) : {};
      const mt = /^[0-9]+$/, ft = (t2, e2) => {
        const s2 = mt.test(t2), r2 = mt.test(e2);
        return s2 && r2 && (t2 = +t2, e2 = +e2), t2 === e2 ? 0 : s2 && !r2 ? -1 : r2 && !s2 ? 1 : t2 < e2 ? -1 : 1;
      };
      var yt = {
        compareIdentifiers: ft,
        rcompareIdentifiers: (t2, e2) => ft(e2, t2)
      };
      const {
        MAX_LENGTH: At,
        MAX_SAFE_INTEGER: Et
      } = pt, {
        re: Ct,
        t: xt
      } = lt, {
        compareIdentifiers: Ft
      } = yt;
      class gt {
        constructor(t2, e2) {
          if (e2 = Dt(e2), t2 instanceof gt) {
            if (t2.loose === !!e2.loose && t2.includePrerelease === !!e2.includePrerelease)
              return t2;
            t2 = t2.version;
          } else if ("string" != typeof t2)
            throw new TypeError("Invalid Version: ".concat(t2));
          if (t2.length > At)
            throw new TypeError("version is longer than ".concat(At, " characters"));
          ct("SemVer", t2, e2), this.options = e2, this.loose = !!e2.loose, this.includePrerelease = !!e2.includePrerelease;
          const s2 = t2.trim().match(e2.loose ? Ct[xt.LOOSE] : Ct[xt.FULL]);
          if (!s2)
            throw new TypeError("Invalid Version: ".concat(t2));
          if (this.raw = t2, this.major = +s2[1], this.minor = +s2[2], this.patch = +s2[3], this.major > Et || this.major < 0)
            throw new TypeError("Invalid major version");
          if (this.minor > Et || this.minor < 0)
            throw new TypeError("Invalid minor version");
          if (this.patch > Et || this.patch < 0)
            throw new TypeError("Invalid patch version");
          s2[4] ? this.prerelease = s2[4].split(".").map((t3) => {
            if (/^[0-9]+$/.test(t3)) {
              const e3 = +t3;
              if (e3 >= 0 && e3 < Et)
                return e3;
            }
            return t3;
          }) : this.prerelease = [], this.build = s2[5] ? s2[5].split(".") : [], this.format();
        }
        format() {
          return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
        }
        toString() {
          return this.version;
        }
        compare(t2) {
          if (ct("SemVer.compare", this.version, this.options, t2), !(t2 instanceof gt)) {
            if ("string" == typeof t2 && t2 === this.version)
              return 0;
            t2 = new gt(t2, this.options);
          }
          return t2.version === this.version ? 0 : this.compareMain(t2) || this.comparePre(t2);
        }
        compareMain(t2) {
          return t2 instanceof gt || (t2 = new gt(t2, this.options)), Ft(this.major, t2.major) || Ft(this.minor, t2.minor) || Ft(this.patch, t2.patch);
        }
        comparePre(t2) {
          if (t2 instanceof gt || (t2 = new gt(t2, this.options)), this.prerelease.length && !t2.prerelease.length)
            return -1;
          if (!this.prerelease.length && t2.prerelease.length)
            return 1;
          if (!this.prerelease.length && !t2.prerelease.length)
            return 0;
          let e2 = 0;
          do {
            const s2 = this.prerelease[e2], r2 = t2.prerelease[e2];
            if (ct("prerelease compare", e2, s2, r2), void 0 === s2 && void 0 === r2)
              return 0;
            if (void 0 === r2)
              return 1;
            if (void 0 === s2)
              return -1;
            if (s2 !== r2)
              return Ft(s2, r2);
          } while (++e2);
        }
        compareBuild(t2) {
          t2 instanceof gt || (t2 = new gt(t2, this.options));
          let e2 = 0;
          do {
            const s2 = this.build[e2], r2 = t2.build[e2];
            if (ct("prerelease compare", e2, s2, r2), void 0 === s2 && void 0 === r2)
              return 0;
            if (void 0 === r2)
              return 1;
            if (void 0 === s2)
              return -1;
            if (s2 !== r2)
              return Ft(s2, r2);
          } while (++e2);
        }
        inc(t2, e2) {
          switch (t2) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e2);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e2);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", e2), this.inc("pre", e2);
              break;
            case "prerelease":
              0 === this.prerelease.length && this.inc("patch", e2), this.inc("pre", e2);
              break;
            case "major":
              0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              0 === this.prerelease.length && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (0 === this.prerelease.length)
                this.prerelease = [0];
              else {
                let t3 = this.prerelease.length;
                for (; --t3 >= 0; )
                  "number" == typeof this.prerelease[t3] && (this.prerelease[t3]++, t3 = -2);
                -1 === t3 && this.prerelease.push(0);
              }
              e2 && (this.prerelease[0] === e2 ? isNaN(this.prerelease[1]) && (this.prerelease = [e2, 0]) : this.prerelease = [e2, 0]);
              break;
            default:
              throw new Error("invalid increment argument: ".concat(t2));
          }
          return this.format(), this.raw = this.version, this;
        }
      }
      var bt = gt;
      var Pt = (t2, e2, s2) => new bt(t2, s2).compare(new bt(e2, s2));
      var Tt = (t2, e2, s2) => Pt(t2, e2, s2) < 0;
      var wt, Bt, St, Nt, It, vt, kt = (t2, e2, s2) => Pt(t2, e2, s2) >= 0, Lt = "2.3.0", Ot = r(function(t2, e2) {
        function s2() {
          for (var t3 = [], e3 = 0; e3 < arguments.length; e3++)
            t3[e3] = arguments[e3];
        }
        function r2() {
          return "undefined" != typeof WeakMap ? /* @__PURE__ */ new WeakMap() : {
            add: s2,
            delete: s2,
            get: s2,
            set: s2,
            has: function(t3) {
              return false;
            }
          };
        }
        Object.defineProperty(e2, "__esModule", {
          value: true
        }), e2.outdent = void 0;
        var i2 = Object.prototype.hasOwnProperty, a2 = function(t3, e3) {
          return i2.call(t3, e3);
        };
        function n2(t3, e3) {
          for (var s3 in e3)
            a2(e3, s3) && (t3[s3] = e3[s3]);
          return t3;
        }
        var o2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, h2 = /^(?:[\r\n]|$)/, c2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
        function l2(t3, e3, s3) {
          var r3 = 0, i3 = t3[0].match(c2);
          i3 && (r3 = i3[1].length);
          var a3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
          e3 && (t3 = t3.slice(1));
          var n3 = s3.newline, h3 = s3.trimLeadingNewline, p3 = s3.trimTrailingNewline, l3 = "string" == typeof n3, d3 = t3.length;
          return t3.map(function(t4, e4) {
            return t4 = t4.replace(a3, "$1"), 0 === e4 && h3 && (t4 = t4.replace(o2, "")), e4 === d3 - 1 && p3 && (t4 = t4.replace(u2, "")), l3 && (t4 = t4.replace(/\r\n|\n|\r/g, function(t5) {
              return n3;
            })), t4;
          });
        }
        function d2(t3, e3) {
          for (var s3 = "", r3 = 0, i3 = t3.length; r3 < i3; r3++)
            s3 += t3[r3], r3 < i3 - 1 && (s3 += e3[r3]);
          return s3;
        }
        function D2(t3) {
          return a2(t3, "raw") && a2(t3, "length");
        }
        var m2 = function t3(e3) {
          var s3 = r2(), i3 = r2();
          return n2(function r3(a3) {
            for (var o3 = [], u3 = 1; u3 < arguments.length; u3++)
              o3[u3 - 1] = arguments[u3];
            if (D2(a3)) {
              var c3 = a3, f2 = (o3[0] === r3 || o3[0] === m2) && p2.test(c3[0]) && h2.test(c3[1]), y2 = f2 ? i3 : s3, A2 = y2.get(c3);
              if (A2 || (A2 = l2(c3, f2, e3), y2.set(c3, A2)), 0 === o3.length)
                return A2[0];
              var E2 = d2(A2, f2 ? o3.slice(1) : o3);
              return E2;
            }
            return t3(n2(n2({}, e3), a3 || {}));
          }, {
            string: function(t4) {
              return l2([t4], false, e3)[0];
            }
          });
        }({
          trimLeadingNewline: true,
          trimTrailingNewline: true
        });
        e2.outdent = m2, e2.default = m2;
        try {
          t2.exports = m2, Object.defineProperty(m2, "__esModule", {
            value: true
          }), m2.default = m2, m2.outdent = m2;
        } catch (t3) {
        }
      });
      const {
        outdent: Mt
      } = Ot, Rt = "Config", jt = "Editor", _t = "Other", Ut = "Global", qt = "Special", Vt = {
        cursorOffset: {
          since: "1.4.0",
          category: qt,
          type: "int",
          default: -1,
          range: {
            start: -1,
            end: Number.POSITIVE_INFINITY,
            step: 1
          },
          description: Mt(wt || (wt = R(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]))),
          cliCategory: jt
        },
        endOfLine: {
          since: "1.15.0",
          category: Ut,
          type: "choice",
          default: [{
            since: "1.15.0",
            value: "auto"
          }, {
            since: "2.0.0",
            value: "lf"
          }],
          description: "Which end of line characters to apply.",
          choices: [{
            value: "lf",
            description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
          }, {
            value: "crlf",
            description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
          }, {
            value: "cr",
            description: "Carriage Return character only (\\r), used very rarely"
          }, {
            value: "auto",
            description: Mt(Bt || (Bt = R(["\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "])))
          }]
        },
        filepath: {
          since: "1.4.0",
          category: qt,
          type: "path",
          description: "Specify the input filepath. This will be used to do parser inference.",
          cliName: "stdin-filepath",
          cliCategory: _t,
          cliDescription: "Path to the file to pretend that stdin comes from."
        },
        insertPragma: {
          since: "1.8.0",
          category: qt,
          type: "boolean",
          default: false,
          description: "Insert @format pragma into file's first docblock comment.",
          cliCategory: _t
        },
        parser: {
          since: "0.0.10",
          category: Ut,
          type: "choice",
          default: [{
            since: "0.0.10",
            value: "babylon"
          }, {
            since: "1.13.0",
            value: void 0
          }],
          description: "Which parser to use.",
          exception: (t2) => "string" == typeof t2 || "function" == typeof t2,
          choices: [{
            value: "flow",
            description: "Flow"
          }, {
            value: "babel",
            since: "1.16.0",
            description: "JavaScript"
          }, {
            value: "babel-flow",
            since: "1.16.0",
            description: "Flow"
          }, {
            value: "babel-ts",
            since: "2.0.0",
            description: "TypeScript"
          }, {
            value: "typescript",
            since: "1.4.0",
            description: "TypeScript"
          }, {
            value: "espree",
            since: "2.2.0",
            description: "JavaScript"
          }, {
            value: "meriyah",
            since: "2.2.0",
            description: "JavaScript"
          }, {
            value: "css",
            since: "1.7.1",
            description: "CSS"
          }, {
            value: "less",
            since: "1.7.1",
            description: "Less"
          }, {
            value: "scss",
            since: "1.7.1",
            description: "SCSS"
          }, {
            value: "json",
            since: "1.5.0",
            description: "JSON"
          }, {
            value: "json5",
            since: "1.13.0",
            description: "JSON5"
          }, {
            value: "json-stringify",
            since: "1.13.0",
            description: "JSON.stringify"
          }, {
            value: "graphql",
            since: "1.5.0",
            description: "GraphQL"
          }, {
            value: "markdown",
            since: "1.8.0",
            description: "Markdown"
          }, {
            value: "mdx",
            since: "1.15.0",
            description: "MDX"
          }, {
            value: "vue",
            since: "1.10.0",
            description: "Vue"
          }, {
            value: "yaml",
            since: "1.14.0",
            description: "YAML"
          }, {
            value: "glimmer",
            since: "2.3.0",
            description: "Ember / Handlebars"
          }, {
            value: "html",
            since: "1.15.0",
            description: "HTML"
          }, {
            value: "angular",
            since: "1.15.0",
            description: "Angular"
          }, {
            value: "lwc",
            since: "1.17.0",
            description: "Lightning Web Components"
          }]
        },
        plugins: {
          since: "1.10.0",
          type: "path",
          array: true,
          default: [{
            value: []
          }],
          category: Ut,
          description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
          exception: (t2) => "string" == typeof t2 || "object" == typeof t2,
          cliName: "plugin",
          cliCategory: Rt
        },
        pluginSearchDirs: {
          since: "1.13.0",
          type: "path",
          array: true,
          default: [{
            value: []
          }],
          category: Ut,
          description: Mt(St || (St = R(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]))),
          exception: (t2) => "string" == typeof t2 || "object" == typeof t2,
          cliName: "plugin-search-dir",
          cliCategory: Rt
        },
        printWidth: {
          since: "0.0.0",
          category: Ut,
          type: "int",
          default: 80,
          description: "The line length where Prettier will try wrap.",
          range: {
            start: 0,
            end: Number.POSITIVE_INFINITY,
            step: 1
          }
        },
        rangeEnd: {
          since: "1.4.0",
          category: qt,
          type: "int",
          default: Number.POSITIVE_INFINITY,
          range: {
            start: 0,
            end: Number.POSITIVE_INFINITY,
            step: 1
          },
          description: Mt(Nt || (Nt = R(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))),
          cliCategory: jt
        },
        rangeStart: {
          since: "1.4.0",
          category: qt,
          type: "int",
          default: 0,
          range: {
            start: 0,
            end: Number.POSITIVE_INFINITY,
            step: 1
          },
          description: Mt(It || (It = R(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]))),
          cliCategory: jt
        },
        requirePragma: {
          since: "1.7.0",
          category: qt,
          type: "boolean",
          default: false,
          description: Mt(vt || (vt = R(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]))),
          cliCategory: _t
        },
        tabWidth: {
          type: "int",
          category: Ut,
          default: 2,
          description: "Number of spaces per indentation level.",
          range: {
            start: 0,
            end: Number.POSITIVE_INFINITY,
            step: 1
          }
        },
        useTabs: {
          since: "1.0.0",
          category: Ut,
          type: "boolean",
          default: false,
          description: "Indent with tabs instead of spaces."
        },
        embeddedLanguageFormatting: {
          since: "2.1.0",
          category: Ut,
          type: "choice",
          default: [{
            since: "2.1.0",
            value: "auto"
          }],
          description: "Control how Prettier formats quoted code embedded in the file.",
          choices: [{
            value: "auto",
            description: "Format embedded code if Prettier can automatically identify it."
          }, {
            value: "off",
            description: "Never automatically format embedded code."
          }]
        }
      };
      const Ht = {
        compare: Pt,
        lt: Tt,
        gte: kt
      }, zt = Lt, Wt = {
        CATEGORY_CONFIG: Rt,
        CATEGORY_EDITOR: jt,
        CATEGORY_FORMAT: "Format",
        CATEGORY_OTHER: _t,
        CATEGORY_OUTPUT: "Output",
        CATEGORY_GLOBAL: Ut,
        CATEGORY_SPECIAL: qt,
        options: Vt
      }.options;
      var Gt = {
        getSupportInfo: function({
          plugins: t2 = [],
          showUnreleased: e2 = false,
          showDeprecated: s2 = false,
          showInternal: r2 = false
        } = {}) {
          const i2 = zt.split("-", 1)[0], a2 = t2.reduce((t3, e3) => [...t3, ...e3.languages || []], []).filter(h2), n2 = (o2 = Object.assign({}, ...t2.map(({
            options: t3
          }) => t3), Wt), u2 = "name", Object.entries(o2).map(([t3, e3]) => Object.assign({
            [u2]: t3
          }, e3))).filter((t3) => h2(t3) && c2(t3)).sort((t3, e3) => t3.name === e3.name ? 0 : t3.name < e3.name ? -1 : 1).map(function(t3) {
            if (r2)
              return t3;
            return function(t4, e3) {
              if (null == t4)
                return {};
              var s3, r3, i3 = {}, a3 = Object.keys(t4);
              for (r3 = 0; r3 < a3.length; r3++)
                s3 = a3[r3], e3.indexOf(s3) >= 0 || (i3[s3] = t4[s3]);
              return i3;
            }(t3, ["cliName", "cliCategory", "cliDescription"]);
          }).map((e3) => {
            e3 = Object.assign({}, e3), Array.isArray(e3.default) && (e3.default = 1 === e3.default.length ? e3.default[0].value : e3.default.filter(h2).sort((t3, e4) => Ht.compare(e4.since, t3.since))[0].value), Array.isArray(e3.choices) && (e3.choices = e3.choices.filter((t3) => h2(t3) && c2(t3)), "parser" === e3.name && function(t3, e4, s4) {
              const r3 = new Set(t3.choices.map((t4) => t4.value));
              for (const i3 of e4)
                if (i3.parsers) {
                  for (const e5 of i3.parsers)
                    if (!r3.has(e5)) {
                      r3.add(e5);
                      const a3 = s4.find((t4) => t4.parsers && t4.parsers[e5]);
                      let n3 = i3.name;
                      a3 && a3.name && (n3 += " (plugin: ".concat(a3.name, ")")), t3.choices.push({
                        value: e5,
                        description: n3
                      });
                    }
                }
            }(e3, a2, t2));
            const s3 = j(t2.filter((t3) => t3.defaultOptions && void 0 !== t3.defaultOptions[e3.name]).map((t3) => [t3.name, t3.defaultOptions[e3.name]]));
            return Object.assign({}, e3, {
              pluginDefaults: s3
            });
          });
          var o2, u2;
          return {
            languages: a2,
            options: n2
          };
          function h2(t3) {
            return e2 || !("since" in t3) || t3.since && Ht.gte(i2, t3.since);
          }
          function c2(t3) {
            return s2 || !("deprecated" in t3) || t3.deprecated && Ht.lt(i2, t3.deprecated);
          }
        }
      };
      const {
        getSupportInfo: Kt
      } = Gt, Xt = /[^\x20-\x7F]/;
      function Jt(t2) {
        return (e2, s2, r2) => {
          const i2 = r2 && r2.backwards;
          if (false === s2)
            return false;
          const {
            length: a2
          } = e2;
          let n2 = s2;
          for (; n2 >= 0 && n2 < a2; ) {
            const s3 = e2.charAt(n2);
            if (t2 instanceof RegExp) {
              if (!t2.test(s3))
                return n2;
            } else if (!t2.includes(s3))
              return n2;
            i2 ? n2-- : n2++;
          }
          return (-1 === n2 || n2 === a2) && n2;
        };
      }
      const $t = Jt(/\s/), Yt = Jt(" 	"), Qt = Jt(",; 	"), Zt = Jt(/[^\n\r]/);
      function te(t2, e2) {
        if (false === e2)
          return false;
        if ("/" === t2.charAt(e2) && "*" === t2.charAt(e2 + 1)) {
          for (let s2 = e2 + 2; s2 < t2.length; ++s2)
            if ("*" === t2.charAt(s2) && "/" === t2.charAt(s2 + 1))
              return s2 + 2;
        }
        return e2;
      }
      function ee(t2, e2) {
        return false !== e2 && ("/" === t2.charAt(e2) && "/" === t2.charAt(e2 + 1) ? Zt(t2, e2) : e2);
      }
      function se(t2, e2, s2) {
        const r2 = s2 && s2.backwards;
        if (false === e2)
          return false;
        const i2 = t2.charAt(e2);
        if (r2) {
          if ("\r" === t2.charAt(e2 - 1) && "\n" === i2)
            return e2 - 2;
          if ("\n" === i2 || "\r" === i2 || "\u2028" === i2 || "\u2029" === i2)
            return e2 - 1;
        } else {
          if ("\r" === i2 && "\n" === t2.charAt(e2 + 1))
            return e2 + 2;
          if ("\n" === i2 || "\r" === i2 || "\u2028" === i2 || "\u2029" === i2)
            return e2 + 1;
        }
        return e2;
      }
      function re(t2, e2, s2 = {}) {
        const r2 = Yt(t2, s2.backwards ? e2 - 1 : e2, s2);
        return r2 !== se(t2, r2, s2);
      }
      function ie(t2, e2) {
        let s2 = null, r2 = e2;
        for (; r2 !== s2; )
          s2 = r2, r2 = Qt(t2, r2), r2 = te(t2, r2), r2 = Yt(t2, r2);
        return r2 = ee(t2, r2), r2 = se(t2, r2), false !== r2 && re(t2, r2);
      }
      function ae(t2, e2) {
        let s2 = null, r2 = e2;
        for (; r2 !== s2; )
          s2 = r2, r2 = Yt(t2, r2), r2 = te(t2, r2), r2 = ee(t2, r2), r2 = se(t2, r2);
        return r2;
      }
      function ne(t2, e2, s2) {
        return ae(t2, s2(e2));
      }
      function oe(t2, e2, s2 = 0) {
        let r2 = 0;
        for (let i2 = s2; i2 < t2.length; ++i2)
          "	" === t2[i2] ? r2 = r2 + e2 - r2 % e2 : r2++;
        return r2;
      }
      function ue(t2, e2) {
        const s2 = t2.slice(1, -1), r2 = {
          quote: '"',
          regex: /"/g
        }, i2 = {
          quote: "'",
          regex: /'/g
        }, a2 = "'" === e2 ? i2 : r2, n2 = a2 === i2 ? r2 : i2;
        let o2 = a2.quote;
        if (s2.includes(a2.quote) || s2.includes(n2.quote)) {
          o2 = (s2.match(a2.regex) || []).length > (s2.match(n2.regex) || []).length ? n2.quote : a2.quote;
        }
        return o2;
      }
      function he(t2, e2, s2) {
        const r2 = '"' === e2 ? "'" : '"', i2 = t2.replace(/\\([\S\s])|(["'])/g, (t3, i3, a2) => i3 === r2 ? i3 : a2 === e2 ? "\\" + a2 : a2 || (s2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
        return e2 + i2 + e2;
      }
      function ce(t2, e2) {
        (t2.comments || (t2.comments = [])).push(e2), e2.printed = false, e2.nodeDescription = function(t3) {
          const e3 = t3.type || t3.kind || "(unknown type)";
          let s2 = String(t3.name || t3.id && ("object" == typeof t3.id ? t3.id.name : t3.id) || t3.key && ("object" == typeof t3.key ? t3.key.name : t3.key) || t3.value && ("object" == typeof t3.value ? "" : String(t3.value)) || t3.operator || "");
          s2.length > 20 && (s2 = s2.slice(0, 19) + "\u2026");
          return e3 + (s2 ? " " + s2 : "");
        }(t2);
      }
      var pe = {
        inferParserByLanguage: function(t2, e2) {
          const {
            languages: s2
          } = Kt({
            plugins: e2.plugins
          }), r2 = s2.find(({
            name: e3
          }) => e3.toLowerCase() === t2) || s2.find(({
            aliases: e3
          }) => Array.isArray(e3) && e3.includes(t2)) || s2.find(({
            extensions: e3
          }) => Array.isArray(e3) && e3.includes(".".concat(t2)));
          return r2 && r2.parsers[0];
        },
        replaceEndOfLineWith: function(t2, e2) {
          const s2 = [];
          for (const r2 of t2.split("\n"))
            s2.length > 0 && s2.push(e2), s2.push(r2);
          return s2;
        },
        getStringWidth: function(t2) {
          return t2 ? Xt.test(t2) ? k(t2) : t2.length : 0;
        },
        getMaxContinuousCount: function(t2, e2) {
          const s2 = t2.match(new RegExp("(".concat(O(e2), ")+"), "g"));
          return null === s2 ? 0 : s2.reduce((t3, s3) => Math.max(t3, s3.length / e2.length), 0);
        },
        getMinNotPresentContinuousCount: function(t2, e2) {
          const s2 = t2.match(new RegExp("(".concat(O(e2), ")+"), "g"));
          if (null === s2)
            return 0;
          const r2 = /* @__PURE__ */ new Map();
          let i2 = 0;
          for (const t3 of s2) {
            const s3 = t3.length / e2.length;
            r2.set(s3, true), s3 > i2 && (i2 = s3);
          }
          for (let t3 = 1; t3 < i2; t3++)
            if (!r2.get(t3))
              return t3;
          return i2 + 1;
        },
        getPenultimate: (t2) => t2[t2.length - 2],
        getLast: M,
        getNextNonSpaceNonCommentCharacterIndexWithStartIndex: ae,
        getNextNonSpaceNonCommentCharacterIndex: ne,
        getNextNonSpaceNonCommentCharacter: function(t2, e2, s2) {
          return t2.charAt(ne(t2, e2, s2));
        },
        skip: Jt,
        skipWhitespace: $t,
        skipSpaces: Yt,
        skipToLineEnd: Qt,
        skipEverythingButNewLine: Zt,
        skipInlineComment: te,
        skipTrailingComment: ee,
        skipNewline: se,
        isNextLineEmptyAfterIndex: ie,
        isNextLineEmpty: function(t2, e2, s2) {
          return ie(t2, s2(e2));
        },
        isPreviousLineEmpty: function(t2, e2, s2) {
          let r2 = s2(e2) - 1;
          return r2 = Yt(t2, r2, {
            backwards: true
          }), r2 = se(t2, r2, {
            backwards: true
          }), r2 = Yt(t2, r2, {
            backwards: true
          }), r2 !== se(t2, r2, {
            backwards: true
          });
        },
        hasNewline: re,
        hasNewlineInRange: function(t2, e2, s2) {
          for (let r2 = e2; r2 < s2; ++r2)
            if ("\n" === t2.charAt(r2))
              return true;
          return false;
        },
        hasSpaces: function(t2, e2, s2 = {}) {
          return Yt(t2, s2.backwards ? e2 - 1 : e2, s2) !== e2;
        },
        getAlignmentSize: oe,
        getIndentSize: function(t2, e2) {
          const s2 = t2.lastIndexOf("\n");
          return -1 === s2 ? 0 : oe(t2.slice(s2 + 1).match(/^[\t ]*/)[0], e2);
        },
        getPreferredQuote: ue,
        printString: function(t2, e2) {
          return he(t2.slice(1, -1), "json" === e2.parser || "json5" === e2.parser && "preserve" === e2.quoteProps && !e2.singleQuote ? '"' : e2.__isInHtmlAttribute ? "'" : ue(t2, e2.singleQuote ? "'" : '"'), !("css" === e2.parser || "less" === e2.parser || "scss" === e2.parser || e2.__embeddedInHtml));
        },
        printNumber: function(t2) {
          return t2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
        },
        makeString: he,
        addLeadingComment: function(t2, e2) {
          e2.leading = true, e2.trailing = false, ce(t2, e2);
        },
        addDanglingComment: function(t2, e2, s2) {
          e2.leading = false, e2.trailing = false, s2 && (e2.marker = s2), ce(t2, e2);
        },
        addTrailingComment: function(t2, e2) {
          e2.leading = false, e2.trailing = true, ce(t2, e2);
        },
        isFrontMatterNode: function(t2) {
          return t2 && "front-matter" === t2.type;
        },
        getShebang: function(t2) {
          if (!t2.startsWith("#!"))
            return "";
          const e2 = t2.indexOf("\n");
          return -1 === e2 ? t2 : t2.slice(0, e2);
        },
        isNonEmptyArray: function(t2) {
          return Array.isArray(t2) && t2.length > 0;
        },
        createGroupIdMapper: function(t2) {
          const e2 = /* @__PURE__ */ new WeakMap();
          return function(s2) {
            return e2.has(s2) || e2.set(s2, Symbol(t2)), e2.get(s2);
          };
        }
      };
      var le = function(t2, e2) {
        const s2 = new SyntaxError(t2 + " (" + e2.start.line + ":" + e2.start.column + ")");
        return s2.loc = e2, s2;
      };
      const {
        isNonEmptyArray: de
      } = pe;
      function De(t2, e2) {
        const {
          ignoreDecorators: s2
        } = e2 || {};
        if (!s2) {
          const e3 = t2.declaration && t2.declaration.decorators || t2.decorators;
          if (de(e3))
            return De(e3[0]);
        }
        return t2.range ? t2.range[0] : t2.start;
      }
      function me(t2) {
        return t2.range ? t2.range[1] : t2.end;
      }
      function fe(t2, e2) {
        return De(t2) === De(e2);
      }
      var ye = {
        locStart: De,
        locEnd: me,
        hasSameLocStart: fe,
        hasSameLoc: function(t2, e2) {
          return fe(t2, e2) && function(t3, e3) {
            return me(t3) === me(e3);
          }(t2, e2);
        }
      }, Ae = r(function(t2) {
        !function() {
          function e2(t3) {
            if (null == t3)
              return false;
            switch (t3.type) {
              case "BlockStatement":
              case "BreakStatement":
              case "ContinueStatement":
              case "DebuggerStatement":
              case "DoWhileStatement":
              case "EmptyStatement":
              case "ExpressionStatement":
              case "ForInStatement":
              case "ForStatement":
              case "IfStatement":
              case "LabeledStatement":
              case "ReturnStatement":
              case "SwitchStatement":
              case "ThrowStatement":
              case "TryStatement":
              case "VariableDeclaration":
              case "WhileStatement":
              case "WithStatement":
                return true;
            }
            return false;
          }
          function s2(t3) {
            switch (t3.type) {
              case "IfStatement":
                return null != t3.alternate ? t3.alternate : t3.consequent;
              case "LabeledStatement":
              case "ForStatement":
              case "ForInStatement":
              case "WhileStatement":
              case "WithStatement":
                return t3.body;
            }
            return null;
          }
          t2.exports = {
            isExpression: function(t3) {
              if (null == t3)
                return false;
              switch (t3.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }
              return false;
            },
            isStatement: e2,
            isIterationStatement: function(t3) {
              if (null == t3)
                return false;
              switch (t3.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }
              return false;
            },
            isSourceElement: function(t3) {
              return e2(t3) || null != t3 && "FunctionDeclaration" === t3.type;
            },
            isProblematicIfStatement: function(t3) {
              var e3;
              if ("IfStatement" !== t3.type)
                return false;
              if (null == t3.alternate)
                return false;
              e3 = t3.consequent;
              do {
                if ("IfStatement" === e3.type && null == e3.alternate)
                  return true;
                e3 = s2(e3);
              } while (e3);
              return false;
            },
            trailingStatement: s2
          };
        }();
      }), Ee = r(function(t2) {
        !function() {
          var e2, s2, r2, i2, a2, n2;
          function o2(t3) {
            return t3 <= 65535 ? String.fromCharCode(t3) : String.fromCharCode(Math.floor((t3 - 65536) / 1024) + 55296) + String.fromCharCode((t3 - 65536) % 1024 + 56320);
          }
          for (s2 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
          }, e2 = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
          }, r2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], i2 = new Array(128), n2 = 0; n2 < 128; ++n2)
            i2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || 36 === n2 || 95 === n2;
          for (a2 = new Array(128), n2 = 0; n2 < 128; ++n2)
            a2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 >= 48 && n2 <= 57 || 36 === n2 || 95 === n2;
          t2.exports = {
            isDecimalDigit: function(t3) {
              return 48 <= t3 && t3 <= 57;
            },
            isHexDigit: function(t3) {
              return 48 <= t3 && t3 <= 57 || 97 <= t3 && t3 <= 102 || 65 <= t3 && t3 <= 70;
            },
            isOctalDigit: function(t3) {
              return t3 >= 48 && t3 <= 55;
            },
            isWhiteSpace: function(t3) {
              return 32 === t3 || 9 === t3 || 11 === t3 || 12 === t3 || 160 === t3 || t3 >= 5760 && r2.indexOf(t3) >= 0;
            },
            isLineTerminator: function(t3) {
              return 10 === t3 || 13 === t3 || 8232 === t3 || 8233 === t3;
            },
            isIdentifierStartES5: function(t3) {
              return t3 < 128 ? i2[t3] : s2.NonAsciiIdentifierStart.test(o2(t3));
            },
            isIdentifierPartES5: function(t3) {
              return t3 < 128 ? a2[t3] : s2.NonAsciiIdentifierPart.test(o2(t3));
            },
            isIdentifierStartES6: function(t3) {
              return t3 < 128 ? i2[t3] : e2.NonAsciiIdentifierStart.test(o2(t3));
            },
            isIdentifierPartES6: function(t3) {
              return t3 < 128 ? a2[t3] : e2.NonAsciiIdentifierPart.test(o2(t3));
            }
          };
        }();
      }), Ce = r(function(t2) {
        !function() {
          var e2 = Ee;
          function s2(t3, e3) {
            return !(!e3 && "yield" === t3) && r2(t3, e3);
          }
          function r2(t3, e3) {
            if (e3 && function(t4) {
              switch (t4) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }(t3))
              return true;
            switch (t3.length) {
              case 2:
                return "if" === t3 || "in" === t3 || "do" === t3;
              case 3:
                return "var" === t3 || "for" === t3 || "new" === t3 || "try" === t3;
              case 4:
                return "this" === t3 || "else" === t3 || "case" === t3 || "void" === t3 || "with" === t3 || "enum" === t3;
              case 5:
                return "while" === t3 || "break" === t3 || "catch" === t3 || "throw" === t3 || "const" === t3 || "yield" === t3 || "class" === t3 || "super" === t3;
              case 6:
                return "return" === t3 || "typeof" === t3 || "delete" === t3 || "switch" === t3 || "export" === t3 || "import" === t3;
              case 7:
                return "default" === t3 || "finally" === t3 || "extends" === t3;
              case 8:
                return "function" === t3 || "continue" === t3 || "debugger" === t3;
              case 10:
                return "instanceof" === t3;
              default:
                return false;
            }
          }
          function i2(t3, e3) {
            return "null" === t3 || "true" === t3 || "false" === t3 || s2(t3, e3);
          }
          function a2(t3, e3) {
            return "null" === t3 || "true" === t3 || "false" === t3 || r2(t3, e3);
          }
          function n2(t3) {
            var s3, r3, i3;
            if (0 === t3.length)
              return false;
            if (i3 = t3.charCodeAt(0), !e2.isIdentifierStartES5(i3))
              return false;
            for (s3 = 1, r3 = t3.length; s3 < r3; ++s3)
              if (i3 = t3.charCodeAt(s3), !e2.isIdentifierPartES5(i3))
                return false;
            return true;
          }
          function o2(t3) {
            var s3, r3, i3, a3, n3;
            if (0 === t3.length)
              return false;
            for (n3 = e2.isIdentifierStartES6, s3 = 0, r3 = t3.length; s3 < r3; ++s3) {
              if (55296 <= (i3 = t3.charCodeAt(s3)) && i3 <= 56319) {
                if (++s3 >= r3)
                  return false;
                if (!(56320 <= (a3 = t3.charCodeAt(s3)) && a3 <= 57343))
                  return false;
                i3 = 1024 * (i3 - 55296) + (a3 - 56320) + 65536;
              }
              if (!n3(i3))
                return false;
              n3 = e2.isIdentifierPartES6;
            }
            return true;
          }
          t2.exports = {
            isKeywordES5: s2,
            isKeywordES6: r2,
            isReservedWordES5: i2,
            isReservedWordES6: a2,
            isRestrictedWord: function(t3) {
              return "eval" === t3 || "arguments" === t3;
            },
            isIdentifierNameES5: n2,
            isIdentifierNameES6: o2,
            isIdentifierES5: function(t3, e3) {
              return n2(t3) && !i2(t3, e3);
            },
            isIdentifierES6: function(t3, e3) {
              return o2(t3) && !a2(t3, e3);
            }
          };
        }();
      });
      const xe = r(function(t2, e2) {
        e2.ast = Ae, e2.code = Ee, e2.keyword = Ce;
      }).keyword.isIdentifierNameES5, {
        getLast: Fe,
        hasNewline: ge,
        skipWhitespace: be,
        isNonEmptyArray: Pe,
        isNextLineEmptyAfterIndex: Te
      } = pe, {
        locStart: we,
        locEnd: Be,
        hasSameLocStart: Se
      } = ye, Ne = "(?:(?=.)\\s)", Ie = new RegExp("^".concat(Ne, "*:")), ve = new RegExp("^".concat(Ne, "*::"));
      function ke(t2) {
        return "AssignmentExpression" === t2.type || "BinaryExpression" === t2.type || "LogicalExpression" === t2.type || "NGPipeExpression" === t2.type || "ConditionalExpression" === t2.type || Xe(t2) || Je(t2) || "SequenceExpression" === t2.type || "TaggedTemplateExpression" === t2.type || "BindExpression" === t2.type || "UpdateExpression" === t2.type && !t2.prefix || "TSAsExpression" === t2.type || "TSNonNullExpression" === t2.type;
      }
      function Le(t2) {
        return "Block" === t2.type || "CommentBlock" === t2.type || "MultiLine" === t2.type;
      }
      function Oe(t2) {
        return "Line" === t2.type || "CommentLine" === t2.type || "SingleLine" === t2.type || "HashbangComment" === t2.type || "HTMLOpen" === t2.type || "HTMLClose" === t2.type;
      }
      const Me = /* @__PURE__ */ new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
      function Re(t2) {
        return t2 && Me.has(t2.type);
      }
      function je(t2) {
        return "NumericLiteral" === t2.type || "Literal" === t2.type && "number" == typeof t2.value;
      }
      function _e(t2) {
        return "StringLiteral" === t2.type || "Literal" === t2.type && "string" == typeof t2.value;
      }
      function Ue(t2) {
        return "FunctionExpression" === t2.type || "ArrowFunctionExpression" === t2.type;
      }
      function qe(t2) {
        return Xe(t2) && "Identifier" === t2.callee.type && ("async" === t2.callee.name || "inject" === t2.callee.name || "fakeAsync" === t2.callee.name);
      }
      function Ve(t2) {
        return "JSXElement" === t2.type || "JSXFragment" === t2.type;
      }
      function He(t2) {
        return "get" === t2.kind || "set" === t2.kind;
      }
      function ze(t2) {
        return He(t2) || Se(t2, t2.value);
      }
      const We = /* @__PURE__ */ new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
      const Ge = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
      const Ke = /^(skip|[fx]?(it|describe|test))$/;
      function Xe(t2) {
        return t2 && ("CallExpression" === t2.type || "OptionalCallExpression" === t2.type);
      }
      function Je(t2) {
        return t2 && ("MemberExpression" === t2.type || "OptionalMemberExpression" === t2.type);
      }
      function $e(t2, e2) {
        return Ve(e2) ? hs(e2) : ls(e2, cs.Leading, (e3) => ge(t2, Be(e3)));
      }
      function Ye(t2) {
        return /^(\d+|\d+\.\d+)$/.test(t2);
      }
      function Qe(t2) {
        return t2.quasis.some((t3) => t3.value.raw.includes("\n"));
      }
      function Ze(t2) {
        return t2.extra ? t2.extra.raw : t2.raw;
      }
      const ts = {
        "==": true,
        "!=": true,
        "===": true,
        "!==": true
      }, es = {
        "*": true,
        "/": true,
        "%": true
      }, ss = {
        ">>": true,
        ">>>": true,
        "<<": true
      };
      const rs = {};
      for (const [t2, e2] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
        for (const s2 of e2)
          rs[s2] = t2;
      function is(t2) {
        return rs[t2];
      }
      const as = /* @__PURE__ */ new WeakMap();
      function ns(t2) {
        if (as.has(t2))
          return as.get(t2);
        const e2 = [];
        return t2.this && e2.push(t2.this), Array.isArray(t2.parameters) ? e2.push(...t2.parameters) : Array.isArray(t2.params) && e2.push(...t2.params), t2.rest && e2.push(t2.rest), as.set(t2, e2), e2;
      }
      const os = /* @__PURE__ */ new WeakMap();
      function us(t2) {
        return "prettier-ignore" === t2.value.trim() && !t2.unignore;
      }
      function hs(t2) {
        return t2 && (t2.prettierIgnore || ls(t2, cs.PrettierIgnore));
      }
      const cs = {
        Leading: 2,
        Trailing: 4,
        Dangling: 8,
        Block: 16,
        Line: 32,
        PrettierIgnore: 64,
        First: 128,
        Last: 256
      }, ps = (t2, e2) => {
        if ("function" == typeof t2 && (e2 = t2, t2 = 0), t2 || e2)
          return (s2, r2, i2) => !(t2 & cs.Leading && !s2.leading || t2 & cs.Trailing && !s2.trailing || t2 & cs.Dangling && (s2.leading || s2.trailing) || t2 & cs.Block && !Le(s2) || t2 & cs.Line && !Oe(s2) || t2 & cs.First && 0 !== r2 || t2 & cs.Last && r2 !== i2.length - 1 || t2 & cs.PrettierIgnore && !us(s2) || e2 && !e2(s2));
      };
      function ls(t2, e2, s2) {
        if (!t2 || !Pe(t2.comments))
          return false;
        const r2 = ps(e2, s2);
        return !r2 || t2.comments.some(r2);
      }
      function ds(t2, e2, s2) {
        if (!t2 || !Array.isArray(t2.comments))
          return [];
        const r2 = ps(e2, s2);
        return r2 ? t2.comments.filter(r2) : t2.comments;
      }
      function Ds(t2) {
        return Xe(t2) || "NewExpression" === t2.type || "ImportExpression" === t2.type;
      }
      var ms = {
        getFunctionParameters: ns,
        iterateFunctionParametersPath: function(t2, e2) {
          const s2 = t2.getValue();
          let r2 = 0;
          const i2 = (t3) => e2(t3, r2++);
          s2.this && t2.call(i2, "this"), Array.isArray(s2.parameters) ? t2.each(i2, "parameters") : Array.isArray(s2.params) && t2.each(i2, "params"), s2.rest && t2.call(i2, "rest");
        },
        getCallArguments: function(t2) {
          if (os.has(t2))
            return os.get(t2);
          const e2 = "ImportExpression" === t2.type ? [t2.source] : t2.arguments;
          return os.set(t2, e2), e2;
        },
        iterateCallArgumentsPath: function(t2, e2) {
          "ImportExpression" === t2.getValue().type ? t2.call((t3) => e2(t3, 0), "source") : t2.each(e2, "arguments");
        },
        hasRestParameter: function(t2) {
          if (t2.rest)
            return true;
          const e2 = ns(t2);
          return e2.length > 0 && "RestElement" === Fe(e2).type;
        },
        getLeftSidePathName: function(t2, e2) {
          if (e2.expressions)
            return ["expressions", 0];
          if (e2.left)
            return ["left"];
          if (e2.test)
            return ["test"];
          if (e2.object)
            return ["object"];
          if (e2.callee)
            return ["callee"];
          if (e2.tag)
            return ["tag"];
          if (e2.argument)
            return ["argument"];
          if (e2.expression)
            return ["expression"];
          throw new Error("Unexpected node has no left side.");
        },
        getParentExportDeclaration: function(t2) {
          const e2 = t2.getParentNode();
          return "declaration" === t2.getName() && Re(e2) ? e2 : null;
        },
        getTypeScriptMappedTypeModifier: function(t2, e2) {
          return "+" === t2 ? "+" + e2 : "-" === t2 ? "-" + e2 : e2;
        },
        hasFlowAnnotationComment: function(t2) {
          return t2 && Le(t2[0]) && ve.test(t2[0].value);
        },
        hasFlowShorthandAnnotationComment: function(t2) {
          return t2.extra && t2.extra.parenthesized && Pe(t2.trailingComments) && Le(t2.trailingComments[0]) && Ie.test(t2.trailingComments[0].value);
        },
        hasLeadingOwnLineComment: $e,
        hasNakedLeftSide: ke,
        hasNode: function t2(e2, s2) {
          if (!e2 || "object" != typeof e2)
            return false;
          if (Array.isArray(e2))
            return e2.some((e3) => t2(e3, s2));
          const r2 = s2(e2);
          return "boolean" == typeof r2 ? r2 : Object.values(e2).some((e3) => t2(e3, s2));
        },
        hasIgnoreComment: function(t2) {
          return hs(t2.getValue());
        },
        hasNodeIgnoreComment: hs,
        identity: function(t2) {
          return t2;
        },
        isBinaryish: function(t2) {
          return We.has(t2.type);
        },
        isBlockComment: Le,
        isCallLikeExpression: Ds,
        isLineComment: Oe,
        isPrettierIgnoreComment: us,
        isCallExpression: Xe,
        isMemberExpression: Je,
        isExportDeclaration: Re,
        isFlowAnnotationComment: function(t2, e2) {
          const s2 = we(e2), r2 = be(t2, Be(e2));
          return false !== r2 && "/*" === t2.slice(s2, s2 + 2) && "*/" === t2.slice(r2, r2 + 2);
        },
        isFunctionCompositionArgs: function(t2) {
          if (t2.length <= 1)
            return false;
          let e2 = 0;
          for (const s2 of t2)
            if (Ue(s2)) {
              if (e2 += 1, e2 > 1)
                return true;
            } else if (Xe(s2)) {
              for (const t3 of s2.arguments)
                if (Ue(t3))
                  return true;
            }
          return false;
        },
        isFunctionNotation: ze,
        isFunctionOrArrowExpression: Ue,
        isGetterOrSetter: He,
        isJestEachTemplateLiteral: function(t2, e2) {
          const s2 = /^[fx]?(describe|it|test)$/;
          return "TaggedTemplateExpression" === e2.type && e2.quasi === t2 && "MemberExpression" === e2.tag.type && "Identifier" === e2.tag.property.type && "each" === e2.tag.property.name && ("Identifier" === e2.tag.object.type && s2.test(e2.tag.object.name) || "MemberExpression" === e2.tag.object.type && "Identifier" === e2.tag.object.property.type && ("only" === e2.tag.object.property.name || "skip" === e2.tag.object.property.name) && "Identifier" === e2.tag.object.object.type && s2.test(e2.tag.object.object.name));
        },
        isJsxNode: Ve,
        isLiteral: function(t2) {
          return "BooleanLiteral" === t2.type || "DirectiveLiteral" === t2.type || "Literal" === t2.type || "NullLiteral" === t2.type || "NumericLiteral" === t2.type || "BigIntLiteral" === t2.type || "DecimalLiteral" === t2.type || "RegExpLiteral" === t2.type || "StringLiteral" === t2.type || "TemplateLiteral" === t2.type || "TSTypeLiteral" === t2.type || "JSXText" === t2.type;
        },
        isLongCurriedCallExpression: function(t2) {
          const e2 = t2.getValue(), s2 = t2.getParentNode();
          return Xe(e2) && Xe(s2) && s2.callee === e2 && e2.arguments.length > s2.arguments.length && s2.arguments.length > 0;
        },
        isSimpleCallArgument: function t2(e2, s2) {
          if (s2 >= 2)
            return false;
          const r2 = (e3) => t2(e3, s2 + 1), i2 = "Literal" === e2.type && "regex" in e2 && e2.regex.pattern || "RegExpLiteral" === e2.type && e2.pattern;
          return !(i2 && i2.length > 5) && ("Literal" === e2.type || "BigIntLiteral" === e2.type || "DecimalLiteral" === e2.type || "BooleanLiteral" === e2.type || "NullLiteral" === e2.type || "NumericLiteral" === e2.type || "RegExpLiteral" === e2.type || "StringLiteral" === e2.type || "Identifier" === e2.type || "ThisExpression" === e2.type || "Super" === e2.type || "PrivateName" === e2.type || "PrivateIdentifier" === e2.type || "ArgumentPlaceholder" === e2.type || "Import" === e2.type || ("TemplateLiteral" === e2.type ? e2.quasis.every((t3) => !t3.value.raw.includes("\n")) && e2.expressions.every(r2) : "ObjectExpression" === e2.type ? e2.properties.every((t3) => !t3.computed && (t3.shorthand || t3.value && r2(t3.value))) : "ArrayExpression" === e2.type ? e2.elements.every((t3) => null === t3 || r2(t3)) : "ImportExpression" === e2.type ? r2(e2.source) : Ds(e2) ? t2(e2.callee, s2) && e2.arguments.every(r2) : Je(e2) ? t2(e2.object, s2) && t2(e2.property, s2) : "UnaryExpression" !== e2.type || "!" !== e2.operator && "-" !== e2.operator ? "TSNonNullExpression" === e2.type && t2(e2.expression, s2) : t2(e2.argument, s2)));
        },
        isMemberish: function(t2) {
          return Je(t2) || "BindExpression" === t2.type && Boolean(t2.object);
        },
        isNumericLiteral: je,
        isSignedNumericLiteral: function(t2) {
          return "UnaryExpression" === t2.type && ("+" === t2.operator || "-" === t2.operator) && je(t2.argument);
        },
        isObjectType: function(t2) {
          return "ObjectTypeAnnotation" === t2.type || "TSTypeLiteral" === t2.type;
        },
        isObjectTypePropertyAFunction: function(t2) {
          return !("ObjectTypeProperty" !== t2.type && "ObjectTypeInternalSlot" !== t2.type || "FunctionTypeAnnotation" !== t2.value.type || t2.static || ze(t2));
        },
        isSimpleType: function(t2) {
          return !!t2 && (!("GenericTypeAnnotation" !== t2.type && "TSTypeReference" !== t2.type || t2.typeParameters) || !!Ge.has(t2.type));
        },
        isSimpleNumber: Ye,
        isSimpleTemplateLiteral: function(t2) {
          let e2 = "expressions";
          "TSTemplateLiteralType" === t2.type && (e2 = "types");
          const s2 = t2[e2];
          return 0 !== s2.length && s2.every((t3) => {
            if (ls(t3))
              return false;
            if ("Identifier" === t3.type || "ThisExpression" === t3.type)
              return true;
            if (Je(t3)) {
              let e3 = t3;
              for (; Je(e3); ) {
                if ("Identifier" !== e3.property.type && "Literal" !== e3.property.type && "StringLiteral" !== e3.property.type && "NumericLiteral" !== e3.property.type)
                  return false;
                if (e3 = e3.object, ls(e3))
                  return false;
              }
              return "Identifier" === e3.type || "ThisExpression" === e3.type;
            }
            return false;
          });
        },
        isStringLiteral: _e,
        isStringPropSafeToUnquote: function(t2, e2) {
          return "json" !== e2.parser && _e(t2.key) && Ze(t2.key).slice(1, -1) === t2.key.value && (xe(t2.key.value) && !(("typescript" === e2.parser || "babel-ts" === e2.parser) && "ClassProperty" === t2.type) || Ye(t2.key.value) && String(Number(t2.key.value)) === t2.key.value && ("babel" === e2.parser || "espree" === e2.parser || "meriyah" === e2.parser));
        },
        isTemplateOnItsOwnLine: function(t2, e2) {
          return ("TemplateLiteral" === t2.type && Qe(t2) || "TaggedTemplateExpression" === t2.type && Qe(t2.quasi)) && !ge(e2, we(t2), {
            backwards: true
          });
        },
        isTestCall: function t2(e2, s2) {
          if ("CallExpression" !== e2.type)
            return false;
          if (1 === e2.arguments.length) {
            if (qe(e2) && s2 && t2(s2))
              return Ue(e2.arguments[0]);
            if (function(t3) {
              return "Identifier" === t3.callee.type && /^(before|after)(Each|All)$/.test(t3.callee.name) && 1 === t3.arguments.length;
            }(e2))
              return qe(e2.arguments[0]);
          } else if ((2 === e2.arguments.length || 3 === e2.arguments.length) && ("Identifier" === e2.callee.type && Ke.test(e2.callee.name) || function(t3) {
            return Je(t3.callee) && "Identifier" === t3.callee.object.type && "Identifier" === t3.callee.property.type && Ke.test(t3.callee.object.name) && ("only" === t3.callee.property.name || "skip" === t3.callee.property.name);
          }(e2)) && (function(t3) {
            return "TemplateLiteral" === t3.type;
          }(e2.arguments[0]) || _e(e2.arguments[0])))
            return !(e2.arguments[2] && !je(e2.arguments[2])) && ((2 === e2.arguments.length ? Ue(e2.arguments[1]) : function(t3) {
              return "FunctionExpression" === t3.type || "ArrowFunctionExpression" === t3.type && "BlockStatement" === t3.body.type;
            }(e2.arguments[1]) && ns(e2.arguments[1]).length <= 1) || qe(e2.arguments[1]));
          return false;
        },
        isTheOnlyJsxElementInMarkdown: function(t2, e2) {
          if ("markdown" !== t2.parentParser && "mdx" !== t2.parentParser)
            return false;
          const s2 = e2.getNode();
          if (!s2.expression || !Ve(s2.expression))
            return false;
          const r2 = e2.getParentNode();
          return "Program" === r2.type && 1 === r2.body.length;
        },
        isTSXFile: function(t2) {
          return t2.filepath && /\.tsx$/i.test(t2.filepath);
        },
        isTypeAnnotationAFunction: function(t2) {
          return !("TypeAnnotation" !== t2.type && "TSTypeAnnotation" !== t2.type || "FunctionTypeAnnotation" !== t2.typeAnnotation.type || t2.static || Se(t2, t2.typeAnnotation));
        },
        isNextLineEmpty: (t2, {
          originalText: e2
        }) => Te(e2, Be(t2)),
        needsHardlineAfterDanglingComment: function(t2) {
          if (!ls(t2))
            return false;
          const e2 = Fe(ds(t2, cs.Dangling));
          return e2 && !Le(e2);
        },
        rawText: Ze,
        returnArgumentHasLeadingComment: function(t2, e2) {
          if ($e(t2.originalText, e2))
            return true;
          if (ke(e2)) {
            let r2, i2 = e2;
            for (; r2 = (s2 = i2).expressions ? s2.expressions[0] : s2.left || s2.test || s2.callee || s2.object || s2.tag || s2.argument || s2.expression; )
              if (i2 = r2, $e(t2.originalText, i2))
                return true;
          }
          var s2;
          return false;
        },
        shouldPrintComma: function(t2, e2 = "es5") {
          return "es5" === t2.trailingComma && "es5" === e2 || "all" === t2.trailingComma && ("all" === e2 || "es5" === e2);
        },
        isBitwiseOperator: function(t2) {
          return Boolean(ss[t2]) || "|" === t2 || "^" === t2 || "&" === t2;
        },
        shouldFlatten: function(t2, e2) {
          return is(e2) === is(t2) && "**" !== t2 && (!ts[t2] || !ts[e2]) && !("%" === e2 && es[t2] || "%" === t2 && es[e2]) && (e2 === t2 || !es[e2] || !es[t2]) && (!ss[t2] || !ss[e2]);
        },
        startsWithNoLookaheadToken: function t2(e2, s2) {
          switch ((e2 = function(t3) {
            for (; t3.left; )
              t3 = t3.left;
            return t3;
          }(e2)).type) {
            case "FunctionExpression":
            case "ClassExpression":
            case "DoExpression":
              return s2;
            case "ObjectExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
              return t2(e2.object, s2);
            case "TaggedTemplateExpression":
              return "FunctionExpression" !== e2.tag.type && t2(e2.tag, s2);
            case "CallExpression":
            case "OptionalCallExpression":
              return "FunctionExpression" !== e2.callee.type && t2(e2.callee, s2);
            case "ConditionalExpression":
              return t2(e2.test, s2);
            case "UpdateExpression":
              return !e2.prefix && t2(e2.argument, s2);
            case "BindExpression":
              return e2.object && t2(e2.object, s2);
            case "SequenceExpression":
              return t2(e2.expressions[0], s2);
            case "TSAsExpression":
            case "TSNonNullExpression":
              return t2(e2.expression, s2);
            default:
              return false;
          }
        },
        getPrecedence: is,
        hasComment: ls,
        getComments: ds,
        CommentCheckFlags: cs
      };
      const {
        getLast: fs,
        hasNewline: ys,
        getNextNonSpaceNonCommentCharacterIndexWithStartIndex: As,
        getNextNonSpaceNonCommentCharacter: Es,
        hasNewlineInRange: Cs,
        addLeadingComment: xs,
        addTrailingComment: Fs,
        addDanglingComment: gs,
        getNextNonSpaceNonCommentCharacterIndex: bs,
        isNonEmptyArray: Ps
      } = pe, {
        isBlockComment: Ts,
        getFunctionParameters: ws,
        isPrettierIgnoreComment: Bs,
        isJsxNode: Ss,
        hasFlowShorthandAnnotationComment: Ns,
        hasFlowAnnotationComment: Is,
        hasIgnoreComment: vs,
        isCallLikeExpression: ks,
        getCallArguments: Ls,
        isCallExpression: Os,
        isMemberExpression: Ms
      } = ms, {
        locStart: Rs,
        locEnd: js
      } = ye;
      function _s(t2, e2) {
        const s2 = (t2.body || t2.properties).find(({
          type: t3
        }) => "EmptyStatement" !== t3);
        s2 ? xs(s2, e2) : gs(t2, e2);
      }
      function Us(t2, e2) {
        "BlockStatement" === t2.type ? _s(t2, e2) : xs(t2, e2);
      }
      function qs({
        comment: t2,
        followingNode: e2
      }) {
        return !(!e2 || !fr(t2)) && (xs(e2, t2), true);
      }
      function Vs({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2,
        followingNode: r2,
        text: i2
      }) {
        if (!s2 || "IfStatement" !== s2.type || !r2)
          return false;
        return ")" === Es(i2, t2, js) ? (Fs(e2, t2), true) : e2 === s2.consequent && r2 === s2.alternate ? ("BlockStatement" === e2.type ? Fs(e2, t2) : gs(s2, t2), true) : "BlockStatement" === r2.type ? (_s(r2, t2), true) : "IfStatement" === r2.type ? (Us(r2.consequent, t2), true) : s2.consequent === r2 && (xs(r2, t2), true);
      }
      function Hs({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2,
        followingNode: r2,
        text: i2
      }) {
        if (!s2 || "WhileStatement" !== s2.type || !r2)
          return false;
        return ")" === Es(i2, t2, js) ? (Fs(e2, t2), true) : "BlockStatement" === r2.type ? (_s(r2, t2), true) : s2.body === r2 && (xs(r2, t2), true);
      }
      function zs({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2,
        followingNode: r2
      }) {
        return !(!s2 || "TryStatement" !== s2.type && "CatchClause" !== s2.type || !r2) && ("CatchClause" === s2.type && e2 ? (Fs(e2, t2), true) : "BlockStatement" === r2.type ? (_s(r2, t2), true) : "TryStatement" === r2.type ? (Us(r2.finalizer, t2), true) : "CatchClause" === r2.type && (Us(r2.body, t2), true));
      }
      function Ws({
        comment: t2,
        enclosingNode: e2,
        followingNode: s2
      }) {
        return !(!Ms(e2) || !s2 || "Identifier" !== s2.type) && (xs(e2, t2), true);
      }
      function Gs({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2,
        followingNode: r2,
        text: i2
      }) {
        const a2 = e2 && !Cs(i2, js(e2), Rs(t2));
        return !(e2 && a2 || !s2 || "ConditionalExpression" !== s2.type && "TSConditionalType" !== s2.type || !r2) && (xs(r2, t2), true);
      }
      function Ks({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2
      }) {
        return !(!s2 || "ObjectProperty" !== s2.type && "Property" !== s2.type || !s2.shorthand || s2.key !== e2 || "AssignmentPattern" !== s2.value.type) && (Fs(s2.value.left, t2), true);
      }
      function Xs({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2,
        followingNode: r2
      }) {
        if (s2 && ("ClassDeclaration" === s2.type || "ClassExpression" === s2.type || "DeclareClass" === s2.type || "DeclareInterface" === s2.type || "InterfaceDeclaration" === s2.type || "TSInterfaceDeclaration" === s2.type)) {
          if (Ps(s2.decorators) && (!r2 || "Decorator" !== r2.type))
            return Fs(fs(s2.decorators), t2), true;
          if (s2.body && r2 === s2.body)
            return _s(s2.body, t2), true;
          if (r2) {
            for (const i2 of ["implements", "extends", "mixins"])
              if (s2[i2] && r2 === s2[i2][0])
                return !e2 || e2 !== s2.id && e2 !== s2.typeParameters && e2 !== s2.superClass ? gs(s2, t2, i2) : Fs(e2, t2), true;
          }
        }
        return false;
      }
      function Js({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2,
        text: r2
      }) {
        return (s2 && e2 && ("Property" === s2.type || "TSDeclareMethod" === s2.type || "TSAbstractMethodDefinition" === s2.type) && "Identifier" === e2.type && s2.key === e2 && ":" !== Es(r2, e2, js) || !(!e2 || !s2 || "Decorator" !== e2.type || "ClassMethod" !== s2.type && "ClassProperty" !== s2.type && "PropertyDefinition" !== s2.type && "TSAbstractClassProperty" !== s2.type && "TSAbstractMethodDefinition" !== s2.type && "TSDeclareMethod" !== s2.type && "MethodDefinition" !== s2.type)) && (Fs(e2, t2), true);
      }
      function $s({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2,
        text: r2
      }) {
        return "(" === Es(r2, t2, js) && !(!e2 || !s2 || "FunctionDeclaration" !== s2.type && "FunctionExpression" !== s2.type && "ClassMethod" !== s2.type && "MethodDefinition" !== s2.type && "ObjectMethod" !== s2.type) && (Fs(e2, t2), true);
      }
      function Ys({
        comment: t2,
        enclosingNode: e2,
        text: s2
      }) {
        if (!e2 || "ArrowFunctionExpression" !== e2.type)
          return false;
        const r2 = bs(s2, t2, js);
        return false !== r2 && "=>" === s2.slice(r2, r2 + 2) && (gs(e2, t2), true);
      }
      function Qs({
        comment: t2,
        enclosingNode: e2,
        text: s2
      }) {
        return ")" === Es(s2, t2, js) && (e2 && (mr(e2) && 0 === ws(e2).length || ks(e2) && 0 === Ls(e2).length) ? (gs(e2, t2), true) : !(!e2 || "MethodDefinition" !== e2.type && "TSAbstractMethodDefinition" !== e2.type || 0 !== ws(e2.value).length) && (gs(e2.value, t2), true));
      }
      function Zs({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2,
        followingNode: r2,
        text: i2
      }) {
        if (e2 && "FunctionTypeParam" === e2.type && s2 && "FunctionTypeAnnotation" === s2.type && r2 && "FunctionTypeParam" !== r2.type)
          return Fs(e2, t2), true;
        if (e2 && ("Identifier" === e2.type || "AssignmentPattern" === e2.type) && s2 && mr(s2) && ")" === Es(i2, t2, js))
          return Fs(e2, t2), true;
        if (s2 && "FunctionDeclaration" === s2.type && r2 && "BlockStatement" === r2.type) {
          const e3 = (() => {
            const t3 = ws(s2);
            if (t3.length > 0)
              return As(i2, js(fs(t3)));
            const e4 = As(i2, js(s2.id));
            return false !== e4 && As(i2, e4 + 1);
          })();
          if (Rs(t2) > e3)
            return _s(r2, t2), true;
        }
        return false;
      }
      function tr({
        comment: t2,
        enclosingNode: e2
      }) {
        return !(!e2 || "ImportSpecifier" !== e2.type) && (xs(e2, t2), true);
      }
      function er({
        comment: t2,
        enclosingNode: e2
      }) {
        return !(!e2 || "LabeledStatement" !== e2.type) && (xs(e2, t2), true);
      }
      function sr({
        comment: t2,
        enclosingNode: e2
      }) {
        return !(!e2 || "ContinueStatement" !== e2.type && "BreakStatement" !== e2.type || e2.label) && (Fs(e2, t2), true);
      }
      function rr({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2
      }) {
        return !!(Os(s2) && e2 && s2.callee === e2 && s2.arguments.length > 0) && (xs(s2.arguments[0], t2), true);
      }
      function ir({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2,
        followingNode: r2
      }) {
        return !s2 || "UnionTypeAnnotation" !== s2.type && "TSUnionType" !== s2.type ? (r2 && ("UnionTypeAnnotation" === r2.type || "TSUnionType" === r2.type) && Bs(t2) && (r2.types[0].prettierIgnore = true, t2.unignore = true), false) : (Bs(t2) && (r2.prettierIgnore = true, t2.unignore = true), !!e2 && (Fs(e2, t2), true));
      }
      function ar({
        comment: t2,
        enclosingNode: e2
      }) {
        return !(!e2 || "Property" !== e2.type && "ObjectProperty" !== e2.type) && (xs(e2, t2), true);
      }
      function nr({
        comment: t2,
        enclosingNode: e2,
        followingNode: s2,
        ast: r2,
        isLastComment: i2
      }) {
        return r2 && r2.body && 0 === r2.body.length ? (i2 ? gs(r2, t2) : xs(r2, t2), true) : e2 && "Program" === e2.type && 0 === e2.body.length && e2.directives && 0 === e2.directives.length ? (i2 ? gs(e2, t2) : xs(e2, t2), true) : !(!s2 || "Program" !== s2.type || 0 !== s2.body.length || !e2 || "ModuleExpression" !== e2.type) && (gs(s2, t2), true);
      }
      function or({
        comment: t2,
        enclosingNode: e2
      }) {
        return !(!e2 || "ForInStatement" !== e2.type && "ForOfStatement" !== e2.type) && (xs(e2, t2), true);
      }
      function ur({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2,
        text: r2
      }) {
        return !!(e2 && "ImportSpecifier" === e2.type && s2 && "ImportDeclaration" === s2.type && ys(r2, js(t2))) && (Fs(e2, t2), true);
      }
      function hr({
        comment: t2,
        enclosingNode: e2
      }) {
        return !(!e2 || "AssignmentPattern" !== e2.type) && (xs(e2, t2), true);
      }
      function cr({
        comment: t2,
        enclosingNode: e2
      }) {
        return !(!e2 || "TypeAlias" !== e2.type) && (xs(e2, t2), true);
      }
      function pr({
        comment: t2,
        enclosingNode: e2,
        followingNode: s2
      }) {
        return !(!e2 || "VariableDeclarator" !== e2.type && "AssignmentExpression" !== e2.type || !s2 || "ObjectExpression" !== s2.type && "ArrayExpression" !== s2.type && "TemplateLiteral" !== s2.type && "TaggedTemplateExpression" !== s2.type && !Ts(t2)) && (xs(s2, t2), true);
      }
      function lr({
        comment: t2,
        enclosingNode: e2,
        followingNode: s2,
        text: r2
      }) {
        return !(s2 || !e2 || "TSMethodSignature" !== e2.type && "TSDeclareFunction" !== e2.type && "TSAbstractMethodDefinition" !== e2.type || ";" !== Es(r2, t2, js)) && (Fs(e2, t2), true);
      }
      function dr({
        comment: t2,
        enclosingNode: e2,
        followingNode: s2
      }) {
        if (Bs(t2) && e2 && "TSMappedType" === e2.type && s2 && "TSTypeParameter" === s2.type && s2.constraint)
          return e2.prettierIgnore = true, t2.unignore = true, true;
      }
      function Dr({
        comment: t2,
        precedingNode: e2,
        enclosingNode: s2,
        followingNode: r2
      }) {
        return !(!s2 || "TSMappedType" !== s2.type) && (r2 && "TSTypeParameter" === r2.type && r2.name ? (xs(r2.name, t2), true) : !(!e2 || "TSTypeParameter" !== e2.type || !e2.constraint) && (Fs(e2.constraint, t2), true));
      }
      function mr(t2) {
        return "ArrowFunctionExpression" === t2.type || "FunctionExpression" === t2.type || "FunctionDeclaration" === t2.type || "ObjectMethod" === t2.type || "ClassMethod" === t2.type || "TSDeclareFunction" === t2.type || "TSCallSignatureDeclaration" === t2.type || "TSConstructSignatureDeclaration" === t2.type || "TSMethodSignature" === t2.type || "TSConstructorType" === t2.type || "TSFunctionType" === t2.type || "TSDeclareMethod" === t2.type;
      }
      function fr(t2) {
        return Ts(t2) && "*" === t2.value[0] && /@type\b/.test(t2.value);
      }
      var yr = {
        handleOwnLineComment: function(t2) {
          return [dr, Zs, Ws, Vs, Hs, zs, Xs, tr, or, ir, nr, ur, hr, Js, er].some((e2) => e2(t2));
        },
        handleEndOfLineComment: function(t2) {
          return [qs, Zs, Gs, tr, Vs, Hs, zs, Xs, er, rr, ar, nr, cr, pr].some((e2) => e2(t2));
        },
        handleRemainingComment: function(t2) {
          return [dr, Vs, Hs, Ks, Qs, Js, nr, Ys, $s, Dr, sr, lr].some((e2) => e2(t2));
        },
        isTypeCastComment: fr,
        getCommentChildNodes: function(t2, e2) {
          if (("typescript" === e2.parser || "flow" === e2.parser || "espree" === e2.parser || "meriyah" === e2.parser) && "MethodDefinition" === t2.type && t2.value && "FunctionExpression" === t2.value.type && 0 === ws(t2.value).length && !t2.value.returnType && !Ps(t2.value.typeParameters) && t2.value.body)
            return [...t2.decorators || [], t2.key, t2.value.body];
        },
        willPrintOwnComments: function(t2) {
          const e2 = t2.getValue(), s2 = t2.getParentNode();
          return (e2 && (Ss(e2) || Ns(e2) || Os(s2) && (Is(e2.leadingComments) || Is(e2.trailingComments))) || s2 && ("JSXSpreadAttribute" === s2.type || "JSXSpreadChild" === s2.type || "UnionTypeAnnotation" === s2.type || "TSUnionType" === s2.type || ("ClassDeclaration" === s2.type || "ClassExpression" === s2.type) && s2.superClass === e2)) && (!vs(t2) || "UnionTypeAnnotation" === s2.type || "TSUnionType" === s2.type);
        }
      };
      const {
        getLast: Ar,
        getNextNonSpaceNonCommentCharacter: Er
      } = pe, {
        locStart: Cr,
        locEnd: xr
      } = ye, {
        isTypeCastComment: Fr
      } = yr;
      function gr(t2) {
        return "CallExpression" === t2.type ? (t2.type = "OptionalCallExpression", t2.callee = gr(t2.callee)) : "MemberExpression" === t2.type ? (t2.type = "OptionalMemberExpression", t2.object = gr(t2.object)) : "TSNonNullExpression" === t2.type && (t2.expression = gr(t2.expression)), t2;
      }
      function br(t2, e2) {
        let s2;
        if (Array.isArray(t2))
          s2 = t2.entries();
        else {
          if (!t2 || "object" != typeof t2 || "string" != typeof t2.type)
            return t2;
          s2 = Object.entries(t2);
        }
        for (const [r2, i2] of s2)
          t2[r2] = br(i2, e2);
        return Array.isArray(t2) ? t2 : e2(t2) || t2;
      }
      function Pr(t2) {
        return "LogicalExpression" === t2.type && "LogicalExpression" === t2.right.type && t2.operator === t2.right.operator;
      }
      function Tr(t2) {
        return Pr(t2) ? Tr({
          type: "LogicalExpression",
          operator: t2.operator,
          left: Tr({
            type: "LogicalExpression",
            operator: t2.operator,
            left: t2.left,
            right: t2.right.left,
            range: [Cr(t2.left), xr(t2.right.left)]
          }),
          right: t2.right.right,
          range: [Cr(t2), xr(t2)]
        }) : t2;
      }
      var wr, Br = function(t2, e2) {
        if ("typescript" === e2.parser && e2.originalText.includes("@")) {
          const {
            esTreeNodeToTSNodeMap: s2,
            tsNodeToESTreeNodeMap: r2
          } = e2.tsParseResult;
          t2 = br(t2, (t3) => {
            const e3 = s2.get(t3);
            if (!e3)
              return;
            const i2 = e3.decorators;
            if (!Array.isArray(i2))
              return;
            const a2 = r2.get(e3);
            if (a2 !== t3)
              return;
            const n2 = a2.decorators;
            if (!Array.isArray(n2) || n2.length !== i2.length || i2.some((t4) => {
              const e4 = r2.get(t4);
              return !e4 || !n2.includes(e4);
            })) {
              const {
                start: t4,
                end: e4
              } = a2.loc;
              throw le("Leading decorators must be attached to a class declaration", {
                start: {
                  line: t4.line,
                  column: t4.column + 1
                },
                end: {
                  line: e4.line,
                  column: e4.column + 1
                }
              });
            }
          });
        }
        if ("typescript" !== e2.parser && "flow" !== e2.parser && "espree" !== e2.parser && "meriyah" !== e2.parser) {
          const e3 = /* @__PURE__ */ new Set();
          t2 = br(t2, (t3) => {
            t3.leadingComments && t3.leadingComments.some(Fr) && e3.add(Cr(t3));
          }), t2 = br(t2, (t3) => {
            if ("ParenthesizedExpression" === t3.type) {
              const {
                expression: s2
              } = t3;
              if ("TypeCastExpression" === s2.type)
                return s2.range = t3.range, s2;
              const r2 = Cr(t3);
              if (!e3.has(r2))
                return s2.extra = Object.assign({}, s2.extra, {
                  parenthesized: true
                }), s2;
            }
          });
        }
        return t2 = br(t2, (t3) => {
          switch (t3.type) {
            case "ChainExpression":
              return gr(t3.expression);
            case "LogicalExpression":
              if (Pr(t3))
                return Tr(t3);
              break;
            case "VariableDeclaration": {
              const s2 = Ar(t3.declarations);
              s2 && s2.init && function(t4, s3) {
                if (";" === e2.originalText[xr(s3)])
                  return;
                t4.range = [Cr(t4), xr(s3)];
              }(t3, s2);
              break;
            }
            case "TSParenthesizedType":
              return t3.typeAnnotation.range = [Cr(t3), xr(t3)], t3.typeAnnotation;
            case "TSTypeParameter":
              if ("string" == typeof t3.name) {
                const e3 = Cr(t3);
                t3.name = {
                  type: "Identifier",
                  name: t3.name,
                  range: [e3, e3 + t3.name.length]
                };
              }
              break;
            case "SequenceExpression": {
              const e3 = Ar(t3.expressions);
              t3.range = [Cr(t3), Math.min(xr(e3), xr(t3))];
              break;
            }
            case "ClassProperty":
              t3.key && "TSPrivateIdentifier" === t3.key.type && "?" === Er(e2.originalText, t3.key, xr) && (t3.optional = true);
          }
        });
      };
      function Sr() {
        if (void 0 === wr) {
          var t2 = new ArrayBuffer(2), e2 = new Uint8Array(t2), s2 = new Uint16Array(t2);
          if (e2[0] = 1, e2[1] = 2, 258 === s2[0])
            wr = "BE";
          else {
            if (513 !== s2[0])
              throw new Error("unable to figure out endianess");
            wr = "LE";
          }
        }
        return wr;
      }
      function Nr() {
        return void 0 !== _.location ? _.location.hostname : "";
      }
      function Ir() {
        return [];
      }
      function vr() {
        return 0;
      }
      function kr() {
        return Number.MAX_VALUE;
      }
      function Lr() {
        return Number.MAX_VALUE;
      }
      function Or() {
        return [];
      }
      function Mr() {
        return "Browser";
      }
      function Rr() {
        return void 0 !== _.navigator ? _.navigator.appVersion : "";
      }
      function jr() {
      }
      function _r() {
      }
      function Ur() {
        return "javascript";
      }
      function qr() {
        return "browser";
      }
      function Vr() {
        return "/tmp";
      }
      var Hr = Vr, zr = {
        EOL: "\n",
        arch: Ur,
        platform: qr,
        tmpdir: Hr,
        tmpDir: Vr,
        networkInterfaces: jr,
        getNetworkInterfaces: _r,
        release: Rr,
        type: Mr,
        cpus: Or,
        totalmem: Lr,
        freemem: kr,
        uptime: vr,
        loadavg: Ir,
        hostname: Nr,
        endianness: Sr
      }, Wr = Object.freeze({
        __proto__: null,
        endianness: Sr,
        hostname: Nr,
        loadavg: Ir,
        uptime: vr,
        freemem: kr,
        totalmem: Lr,
        cpus: Or,
        type: Mr,
        release: Rr,
        networkInterfaces: jr,
        getNetworkInterfaces: _r,
        arch: Ur,
        platform: qr,
        tmpDir: Vr,
        tmpdir: Hr,
        EOL: "\n",
        default: zr
      });
      const Gr = (t2) => {
        if ("string" != typeof t2)
          throw new TypeError("Expected a string");
        const e2 = t2.match(/(?:\r?\n)/g) || [];
        if (0 === e2.length)
          return;
        const s2 = e2.filter((t3) => "\r\n" === t3).length;
        return s2 > e2.length - s2 ? "\r\n" : "\n";
      };
      var Kr = Gr;
      Kr.graceful = (t2) => "string" == typeof t2 && Gr(t2) || "\n";
      var Xr = s(Wr), Jr = function(t2) {
        const e2 = t2.match(ii);
        return e2 ? e2[0].trimLeft() : "";
      }, $r = function(t2) {
        const e2 = t2.match(ii);
        return e2 && e2[0] ? t2.substring(e2[0].length) : t2;
      }, Yr = function(t2) {
        return pi(t2).pragmas;
      }, Qr = pi, Zr = function({
        comments: t2 = "",
        pragmas: e2 = {}
      }) {
        const s2 = (0, ei().default)(t2) || ti().EOL, r2 = " *", i2 = Object.keys(e2), a2 = i2.map((t3) => li(t3, e2[t3])).reduce((t3, e3) => t3.concat(e3), []).map((t3) => " * " + t3 + s2).join("");
        if (!t2) {
          if (0 === i2.length)
            return "";
          if (1 === i2.length && !Array.isArray(e2[i2[0]])) {
            const t3 = e2[i2[0]];
            return "".concat("/**", " ").concat(li(i2[0], t3)[0]).concat(" */");
          }
        }
        const n2 = t2.split(s2).map((t3) => "".concat(r2, " ").concat(t3)).join(s2) + s2;
        return "/**" + s2 + (t2 ? n2 : "") + (t2 && i2.length ? r2 + s2 : "") + a2 + " */";
      };
      function ti() {
        const t2 = Xr;
        return ti = function() {
          return t2;
        }, t2;
      }
      function ei() {
        const t2 = (e2 = Kr) && e2.__esModule ? e2 : {
          default: e2
        };
        var e2;
        return ei = function() {
          return t2;
        }, t2;
      }
      const si = /\*\/$/, ri = /^\/\*\*/, ii = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, ai = /(^|\s+)\/\/([^\r\n]*)/g, ni = /^(\r?\n)+/, oi = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, ui = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, hi = /(\r?\n|^) *\* ?/g, ci = [];
      function pi(t2) {
        const e2 = (0, ei().default)(t2) || ti().EOL;
        t2 = t2.replace(ri, "").replace(si, "").replace(hi, "$1");
        let s2 = "";
        for (; s2 !== t2; )
          s2 = t2, t2 = t2.replace(oi, "".concat(e2, "$1 $2").concat(e2));
        t2 = t2.replace(ni, "").trimRight();
        const r2 = /* @__PURE__ */ Object.create(null), i2 = t2.replace(ui, "").replace(ni, "").trimRight();
        let a2;
        for (; a2 = ui.exec(t2); ) {
          const t3 = a2[2].replace(ai, "");
          "string" == typeof r2[a2[1]] || Array.isArray(r2[a2[1]]) ? r2[a2[1]] = ci.concat(r2[a2[1]], t3) : r2[a2[1]] = t3;
        }
        return {
          comments: i2,
          pragmas: r2
        };
      }
      function li(t2, e2) {
        return ci.concat(e2).map((e3) => "@".concat(t2, " ").concat(e3).trim());
      }
      var di = Object.defineProperty({
        extract: Jr,
        strip: $r,
        parse: Yr,
        parseWithComments: Qr,
        print: Zr
      }, "__esModule", {
        value: true
      });
      var Di = {
        guessEndOfLine: function(t2) {
          const e2 = t2.indexOf("\r");
          return e2 >= 0 ? "\n" === t2.charAt(e2 + 1) ? "crlf" : "cr" : "lf";
        },
        convertEndOfLineToChars: function(t2) {
          switch (t2) {
            case "cr":
              return "\r";
            case "crlf":
              return "\r\n";
            default:
              return "\n";
          }
        },
        countEndOfLineChars: function(t2, e2) {
          let s2;
          if ("\n" === e2)
            s2 = /\n/g;
          else if ("\r" === e2)
            s2 = /\r/g;
          else {
            if ("\r\n" !== e2)
              throw new Error('Unexpected "eol" '.concat(JSON.stringify(e2), "."));
            s2 = /\r\n/g;
          }
          const r2 = t2.match(s2);
          return r2 ? r2.length : 0;
        },
        normalizeEndOfLine: function(t2) {
          return t2.replace(/\r\n?/g, "\n");
        }
      };
      const {
        parseWithComments: mi,
        strip: fi,
        extract: yi,
        print: Ai
      } = di, {
        getShebang: Ei
      } = pe, {
        normalizeEndOfLine: Ci
      } = Di;
      function xi(t2) {
        const e2 = Ei(t2);
        e2 && (t2 = t2.slice(e2.length + 1));
        const s2 = yi(t2), {
          pragmas: r2,
          comments: i2
        } = mi(s2);
        return {
          shebang: e2,
          text: t2,
          pragmas: r2,
          comments: i2
        };
      }
      var Fi = {
        hasPragma: function(t2) {
          const e2 = Object.keys(xi(t2).pragmas);
          return e2.includes("prettier") || e2.includes("format");
        },
        insertPragma: function(t2) {
          const {
            shebang: e2,
            text: s2,
            pragmas: r2,
            comments: i2
          } = xi(t2), a2 = fi(s2), n2 = Ai({
            pragmas: Object.assign({
              format: ""
            }, r2),
            comments: i2.trimStart()
          });
          return (e2 ? "".concat(e2, "\n") : "") + Ci(n2) + (a2.startsWith("\n") ? "\n" : "\n\n") + a2;
        }
      };
      const {
        hasPragma: gi
      } = Fi, {
        locStart: bi,
        locEnd: Pi
      } = ye;
      var Ti = function(t2) {
        return t2 = "function" == typeof t2 ? {
          parse: t2
        } : t2, Object.assign({
          astFormat: "estree",
          hasPragma: gi,
          locStart: bi,
          locEnd: Pi
        }, t2);
      };
      var wi = function(t2) {
        const {
          message: e2,
          loc: s2
        } = t2;
        return le(e2.replace(/ \(.*\)/, ""), {
          start: {
            line: s2 ? s2.line : 0,
            column: s2 ? s2.column + 1 : 0
          }
        });
      };
      const Bi = true, Si = true, Ni = true, Ii = true;
      class vi {
        constructor(t2, e2 = {}) {
          this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.updateContext = void 0, this.label = t2, this.keyword = e2.keyword, this.beforeExpr = !!e2.beforeExpr, this.startsExpr = !!e2.startsExpr, this.rightAssociative = !!e2.rightAssociative, this.isLoop = !!e2.isLoop, this.isAssign = !!e2.isAssign, this.prefix = !!e2.prefix, this.postfix = !!e2.postfix, this.binop = null != e2.binop ? e2.binop : null, this.updateContext = null;
        }
      }
      const ki = /* @__PURE__ */ new Map();
      function Li(t2, e2 = {}) {
        e2.keyword = t2;
        const s2 = new vi(t2, e2);
        return ki.set(t2, s2), s2;
      }
      function Oi(t2, e2) {
        return new vi(t2, {
          beforeExpr: Bi,
          binop: e2
        });
      }
      const Mi = {
        num: new vi("num", {
          startsExpr: Si
        }),
        bigint: new vi("bigint", {
          startsExpr: Si
        }),
        decimal: new vi("decimal", {
          startsExpr: Si
        }),
        regexp: new vi("regexp", {
          startsExpr: Si
        }),
        string: new vi("string", {
          startsExpr: Si
        }),
        name: new vi("name", {
          startsExpr: Si
        }),
        eof: new vi("eof"),
        bracketL: new vi("[", {
          beforeExpr: Bi,
          startsExpr: Si
        }),
        bracketHashL: new vi("#[", {
          beforeExpr: Bi,
          startsExpr: Si
        }),
        bracketBarL: new vi("[|", {
          beforeExpr: Bi,
          startsExpr: Si
        }),
        bracketR: new vi("]"),
        bracketBarR: new vi("|]"),
        braceL: new vi("{", {
          beforeExpr: Bi,
          startsExpr: Si
        }),
        braceBarL: new vi("{|", {
          beforeExpr: Bi,
          startsExpr: Si
        }),
        braceHashL: new vi("#{", {
          beforeExpr: Bi,
          startsExpr: Si
        }),
        braceR: new vi("}"),
        braceBarR: new vi("|}"),
        parenL: new vi("(", {
          beforeExpr: Bi,
          startsExpr: Si
        }),
        parenR: new vi(")"),
        comma: new vi(",", {
          beforeExpr: Bi
        }),
        semi: new vi(";", {
          beforeExpr: Bi
        }),
        colon: new vi(":", {
          beforeExpr: Bi
        }),
        doubleColon: new vi("::", {
          beforeExpr: Bi
        }),
        dot: new vi("."),
        question: new vi("?", {
          beforeExpr: Bi
        }),
        questionDot: new vi("?."),
        arrow: new vi("=>", {
          beforeExpr: Bi
        }),
        template: new vi("template"),
        ellipsis: new vi("...", {
          beforeExpr: Bi
        }),
        backQuote: new vi("`", {
          startsExpr: Si
        }),
        dollarBraceL: new vi("${", {
          beforeExpr: Bi,
          startsExpr: Si
        }),
        at: new vi("@"),
        hash: new vi("#", {
          startsExpr: Si
        }),
        interpreterDirective: new vi("#!..."),
        eq: new vi("=", {
          beforeExpr: Bi,
          isAssign: true
        }),
        assign: new vi("_=", {
          beforeExpr: Bi,
          isAssign: true
        }),
        incDec: new vi("++/--", {
          prefix: Ii,
          postfix: true,
          startsExpr: Si
        }),
        bang: new vi("!", {
          beforeExpr: Bi,
          prefix: Ii,
          startsExpr: Si
        }),
        tilde: new vi("~", {
          beforeExpr: Bi,
          prefix: Ii,
          startsExpr: Si
        }),
        pipeline: Oi("|>", 0),
        nullishCoalescing: Oi("??", 1),
        logicalOR: Oi("||", 1),
        logicalAND: Oi("&&", 2),
        bitwiseOR: Oi("|", 3),
        bitwiseXOR: Oi("^", 4),
        bitwiseAND: Oi("&", 5),
        equality: Oi("==/!=/===/!==", 6),
        relational: Oi("</>/<=/>=", 7),
        bitShift: Oi("<</>>/>>>", 8),
        plusMin: new vi("+/-", {
          beforeExpr: Bi,
          binop: 9,
          prefix: Ii,
          startsExpr: Si
        }),
        modulo: new vi("%", {
          beforeExpr: Bi,
          binop: 10,
          startsExpr: Si
        }),
        star: new vi("*", {
          binop: 10
        }),
        slash: Oi("/", 10),
        exponent: new vi("**", {
          beforeExpr: Bi,
          binop: 11,
          rightAssociative: true
        }),
        _break: Li("break"),
        _case: Li("case", {
          beforeExpr: Bi
        }),
        _catch: Li("catch"),
        _continue: Li("continue"),
        _debugger: Li("debugger"),
        _default: Li("default", {
          beforeExpr: Bi
        }),
        _do: Li("do", {
          isLoop: Ni,
          beforeExpr: Bi
        }),
        _else: Li("else", {
          beforeExpr: Bi
        }),
        _finally: Li("finally"),
        _for: Li("for", {
          isLoop: Ni
        }),
        _function: Li("function", {
          startsExpr: Si
        }),
        _if: Li("if"),
        _return: Li("return", {
          beforeExpr: Bi
        }),
        _switch: Li("switch"),
        _throw: Li("throw", {
          beforeExpr: Bi,
          prefix: Ii,
          startsExpr: Si
        }),
        _try: Li("try"),
        _var: Li("var"),
        _const: Li("const"),
        _while: Li("while", {
          isLoop: Ni
        }),
        _with: Li("with"),
        _new: Li("new", {
          beforeExpr: Bi,
          startsExpr: Si
        }),
        _this: Li("this", {
          startsExpr: Si
        }),
        _super: Li("super", {
          startsExpr: Si
        }),
        _class: Li("class", {
          startsExpr: Si
        }),
        _extends: Li("extends", {
          beforeExpr: Bi
        }),
        _export: Li("export"),
        _import: Li("import", {
          startsExpr: Si
        }),
        _null: Li("null", {
          startsExpr: Si
        }),
        _true: Li("true", {
          startsExpr: Si
        }),
        _false: Li("false", {
          startsExpr: Si
        }),
        _in: Li("in", {
          beforeExpr: Bi,
          binop: 7
        }),
        _instanceof: Li("instanceof", {
          beforeExpr: Bi,
          binop: 7
        }),
        _typeof: Li("typeof", {
          beforeExpr: Bi,
          prefix: Ii,
          startsExpr: Si
        }),
        _void: Li("void", {
          beforeExpr: Bi,
          prefix: Ii,
          startsExpr: Si
        }),
        _delete: Li("delete", {
          beforeExpr: Bi,
          prefix: Ii,
          startsExpr: Si
        })
      }, Ri = /\r\n?|[\n\u2028\u2029]/, ji = new RegExp(Ri.source, "g");
      function _i(t2) {
        switch (t2) {
          case 10:
          case 13:
          case 8232:
          case 8233:
            return true;
          default:
            return false;
        }
      }
      const Ui = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      function qi(t2) {
        switch (t2) {
          case 9:
          case 11:
          case 12:
          case 32:
          case 160:
          case 5760:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }
      class Vi {
        constructor(t2, e2) {
          this.line = void 0, this.column = void 0, this.line = t2, this.column = e2;
        }
      }
      class Hi {
        constructor(t2, e2) {
          this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t2, this.end = e2;
        }
      }
      function zi(t2) {
        return t2[t2.length - 1];
      }
      const Wi = Object.freeze({
        SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
        SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      }), Gi = Xi({
        AccessorIsGenerator: "A %0ter cannot be a generator.",
        ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
        AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
        AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
        AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
        AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
        AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
        AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
        BadGetterArity: "A 'get' accesor must not have any formal parameters.",
        BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
        BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
        ConstructorClassField: "Classes may not have a field named 'constructor'.",
        ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
        ConstructorIsAccessor: "Class constructor may not be an accessor.",
        ConstructorIsAsync: "Constructor can't be an async function.",
        ConstructorIsGenerator: "Constructor can't be a generator.",
        DeclarationMissingInitializer: "'%0' require an initialization value.",
        DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
        DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
        DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
        DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
        DecoratorStaticBlock: "Decorators can't be used with a static block.",
        DeletePrivateField: "Deleting a private field is not allowed.",
        DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
        DuplicateConstructor: "Duplicate constructor in the same class.",
        DuplicateDefaultExport: "Only one default export allowed per module.",
        DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
        DuplicateProto: "Redefinition of __proto__ property.",
        DuplicateRegExpFlags: "Duplicate regular expression flag.",
        ElementAfterRest: "Rest element must be last element.",
        EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
        ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
        ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
        ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
        ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
        ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
        GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
        IllegalBreakContinue: "Unsyntactic %0.",
        IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
        IllegalReturn: "'return' outside of function.",
        ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
        ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
        ImportCallArity: "`import()` requires exactly %0.",
        ImportCallNotNewExpression: "Cannot use new with import(...).",
        ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
        InvalidBigIntLiteral: "Invalid BigIntLiteral.",
        InvalidCodePoint: "Code point out of bounds.",
        InvalidDecimal: "Invalid decimal.",
        InvalidDigit: "Expected number in radix %0.",
        InvalidEscapeSequence: "Bad character escape sequence.",
        InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
        InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
        InvalidIdentifier: "Invalid identifier %0.",
        InvalidLhs: "Invalid left-hand side in %0.",
        InvalidLhsBinding: "Binding invalid left-hand side in %0.",
        InvalidNumber: "Invalid number.",
        InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
        InvalidOrUnexpectedToken: "Unexpected character '%0'.",
        InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
        InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
        InvalidPropertyBindingPattern: "Binding member expression.",
        InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
        InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
        LabelRedeclaration: "Label '%0' is already declared.",
        LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
        LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
        MalformedRegExpFlags: "Invalid regular expression flag.",
        MissingClassName: "A class name is required.",
        MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
        MissingSemicolon: "Missing semicolon.",
        MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
        MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
        ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
        ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
        ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
        ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
        ModuleExportUndefined: "Export '%0' is not defined.",
        MultipleDefaultsInSwitch: "Multiple default clauses.",
        NewlineAfterThrow: "Illegal newline after throw.",
        NoCatchOrFinally: "Missing catch or finally clause.",
        NumberIdentifier: "Identifier directly after number.",
        NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
        ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
        OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
        OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
        OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
        ParamDupe: "Argument name clash.",
        PatternHasAccessor: "Object pattern can't contain getter or setter.",
        PatternHasMethod: "Object pattern can't contain methods.",
        PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
        PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
        PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
        PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
        PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
        PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
        PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
        PrivateNameRedeclaration: "Duplicate private name #%0.",
        RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        RecordNoProto: "'__proto__' is not allowed in Record expressions.",
        RestTrailingComma: "Unexpected trailing comma after rest element.",
        SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
        StaticPrototype: "Classes may not have static property named prototype.",
        StrictDelete: "Deleting local variable in strict mode.",
        StrictEvalArguments: "Assigning to '%0' in strict mode.",
        StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
        StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
        StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
        StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
        StrictWith: "'with' in strict mode.",
        SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
        SuperPrivateField: "Private fields can't be accessed on super.",
        TrailingDecorator: "Decorators must be attached to a class element.",
        TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
        TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
        UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
        UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
        UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
        UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
        UnexpectedKeyword: "Unexpected keyword '%0'.",
        UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
        UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
        UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
        UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
        UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
        UnexpectedReservedWord: "Unexpected reserved word '%0'.",
        UnexpectedSuper: "'super' is only allowed in object methods and classes.",
        UnexpectedToken: "Unexpected token '%0'.",
        UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
        UnsupportedBind: "Binding should be performed on object property.",
        UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
        UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
        UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
        UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
        UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
        UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
        UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
        UnterminatedComment: "Unterminated comment.",
        UnterminatedRegExp: "Unterminated regular expression.",
        UnterminatedString: "Unterminated string constant.",
        UnterminatedTemplate: "Unterminated template.",
        VarRedeclaration: "Identifier '%0' has already been declared.",
        YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
        YieldInParameter: "Yield expression is not allowed in formal parameters.",
        ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
      }, Wi.SyntaxError), Ki = Xi({
        ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`,
        ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`
      }, Wi.SourceTypeModuleError);
      function Xi(t2, e2) {
        const s2 = {};
        return Object.keys(t2).forEach((r2) => {
          s2[r2] = Object.freeze({
            code: e2,
            reasonCode: r2,
            template: t2[r2]
          });
        }), Object.freeze(s2);
      }
      class Ji {
        constructor(t2, e2, s2, r2) {
          this.token = void 0, this.isExpr = void 0, this.preserveSpace = void 0, this.override = void 0, this.token = t2, this.isExpr = !!e2, this.preserveSpace = !!s2, this.override = r2;
        }
      }
      const $i = {
        braceStatement: new Ji("{", false),
        braceExpression: new Ji("{", true),
        recordExpression: new Ji("#{", true),
        templateQuasi: new Ji("${", false),
        parenStatement: new Ji("(", false),
        parenExpression: new Ji("(", true),
        template: new Ji("`", true, true, (t2) => t2.readTmplToken()),
        functionExpression: new Ji("function", true),
        functionStatement: new Ji("function", false)
      };
      Mi.parenR.updateContext = Mi.braceR.updateContext = function() {
        if (1 === this.state.context.length)
          return void (this.state.exprAllowed = true);
        let t2 = this.state.context.pop();
        t2 === $i.braceStatement && "function" === this.curContext().token && (t2 = this.state.context.pop()), this.state.exprAllowed = !t2.isExpr;
      }, Mi.name.updateContext = function(t2) {
        let e2 = false;
        t2 !== Mi.dot && ("of" !== this.state.value || this.state.exprAllowed || t2 === Mi._function || t2 === Mi._class || (e2 = true)), this.state.exprAllowed = e2, this.state.isIterator && (this.state.isIterator = false);
      }, Mi.braceL.updateContext = function(t2) {
        this.state.context.push(this.braceIsBlock(t2) ? $i.braceStatement : $i.braceExpression), this.state.exprAllowed = true;
      }, Mi.dollarBraceL.updateContext = function() {
        this.state.context.push($i.templateQuasi), this.state.exprAllowed = true;
      }, Mi.parenL.updateContext = function(t2) {
        const e2 = t2 === Mi._if || t2 === Mi._for || t2 === Mi._with || t2 === Mi._while;
        this.state.context.push(e2 ? $i.parenStatement : $i.parenExpression), this.state.exprAllowed = true;
      }, Mi.incDec.updateContext = function() {
      }, Mi._function.updateContext = Mi._class.updateContext = function(t2) {
        !t2.beforeExpr || t2 === Mi.semi || t2 === Mi._else || t2 === Mi._return && this.hasPrecedingLineBreak() || (t2 === Mi.colon || t2 === Mi.braceL) && this.curContext() === $i.b_stat ? this.state.context.push($i.functionStatement) : this.state.context.push($i.functionExpression), this.state.exprAllowed = false;
      }, Mi.backQuote.updateContext = function() {
        this.curContext() === $i.template ? this.state.context.pop() : this.state.context.push($i.template), this.state.exprAllowed = false;
      }, Mi.braceHashL.updateContext = function() {
        this.state.context.push($i.recordExpression), this.state.exprAllowed = true;
      };
      let Yi = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Qi = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      const Zi = new RegExp("[" + Yi + "]"), ta = new RegExp("[" + Yi + Qi + "]");
      Yi = Qi = null;
      const ea = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], sa = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function ra(t2, e2) {
        let s2 = 65536;
        for (let r2 = 0, i2 = e2.length; r2 < i2; r2 += 2) {
          if (s2 += e2[r2], s2 > t2)
            return false;
          if (s2 += e2[r2 + 1], s2 >= t2)
            return true;
        }
        return false;
      }
      function ia(t2) {
        return t2 < 65 ? 36 === t2 : t2 <= 90 || (t2 < 97 ? 95 === t2 : t2 <= 122 || (t2 <= 65535 ? t2 >= 170 && Zi.test(String.fromCharCode(t2)) : ra(t2, ea)));
      }
      function aa(t2) {
        return t2 < 48 ? 36 === t2 : t2 < 58 || !(t2 < 65) && (t2 <= 90 || (t2 < 97 ? 95 === t2 : t2 <= 122 || (t2 <= 65535 ? t2 >= 170 && ta.test(String.fromCharCode(t2)) : ra(t2, ea) || ra(t2, sa))));
      }
      const na = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], oa = ["eval", "arguments"], ua = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), ha = new Set(na), ca = new Set(oa);
      function pa(t2, e2) {
        return e2 && "await" === t2 || "enum" === t2;
      }
      function la(t2, e2) {
        return pa(t2, e2) || ha.has(t2);
      }
      function da(t2) {
        return ca.has(t2);
      }
      function Da(t2, e2) {
        return la(t2, e2) || da(t2);
      }
      function ma(t2) {
        return ua.has(t2);
      }
      const fa = /^in(stanceof)?$/;
      const ya = 256, Aa = 128, Ea = 1024, Ca = 2048;
      class xa {
        constructor(t2) {
          this.flags = void 0, this.var = [], this.lexical = [], this.functions = [], this.flags = t2;
        }
      }
      class Fa {
        constructor(t2, e2) {
          this.scopeStack = [], this.undefinedExports = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.raise = t2, this.inModule = e2;
        }
        get inFunction() {
          return (2 & this.currentVarScope().flags) > 0;
        }
        get allowSuper() {
          return (16 & this.currentThisScope().flags) > 0;
        }
        get allowDirectSuper() {
          return (32 & this.currentThisScope().flags) > 0;
        }
        get inClass() {
          return (64 & this.currentThisScope().flags) > 0;
        }
        get inStaticBlock() {
          return (128 & this.currentThisScope().flags) > 0;
        }
        get inNonArrowFunction() {
          return (2 & this.currentThisScope().flags) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(t2) {
          return new xa(t2);
        }
        enter(t2) {
          this.scopeStack.push(this.createScope(t2));
        }
        exit() {
          this.scopeStack.pop();
        }
        treatFunctionsAsVarInScope(t2) {
          return !!(2 & t2.flags || !this.inModule && 1 & t2.flags);
        }
        declareName(t2, e2, s2) {
          let r2 = this.currentScope();
          if (8 & e2 || 16 & e2)
            this.checkRedeclarationInScope(r2, t2, e2, s2), 16 & e2 ? r2.functions.push(t2) : r2.lexical.push(t2), 8 & e2 && this.maybeExportDefined(r2, t2);
          else if (4 & e2)
            for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (r2 = this.scopeStack[i2], this.checkRedeclarationInScope(r2, t2, e2, s2), r2.var.push(t2), this.maybeExportDefined(r2, t2), !(259 & r2.flags)); --i2)
              ;
          this.inModule && 1 & r2.flags && this.undefinedExports.delete(t2);
        }
        maybeExportDefined(t2, e2) {
          this.inModule && 1 & t2.flags && this.undefinedExports.delete(e2);
        }
        checkRedeclarationInScope(t2, e2, s2, r2) {
          this.isRedeclaredInScope(t2, e2, s2) && this.raise(r2, Gi.VarRedeclaration, e2);
        }
        isRedeclaredInScope(t2, e2, s2) {
          return !!(1 & s2) && (8 & s2 ? t2.lexical.indexOf(e2) > -1 || t2.functions.indexOf(e2) > -1 || t2.var.indexOf(e2) > -1 : 16 & s2 ? t2.lexical.indexOf(e2) > -1 || !this.treatFunctionsAsVarInScope(t2) && t2.var.indexOf(e2) > -1 : t2.lexical.indexOf(e2) > -1 && !(8 & t2.flags && t2.lexical[0] === e2) || !this.treatFunctionsAsVarInScope(t2) && t2.functions.indexOf(e2) > -1);
        }
        checkLocalExport(t2) {
          -1 === this.scopeStack[0].lexical.indexOf(t2.name) && -1 === this.scopeStack[0].var.indexOf(t2.name) && -1 === this.scopeStack[0].functions.indexOf(t2.name) && this.undefinedExports.set(t2.name, t2.start);
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScope() {
          for (let t2 = this.scopeStack.length - 1; ; t2--) {
            const e2 = this.scopeStack[t2];
            if (259 & e2.flags)
              return e2;
          }
        }
        currentThisScope() {
          for (let t2 = this.scopeStack.length - 1; ; t2--) {
            const e2 = this.scopeStack[t2];
            if ((259 & e2.flags || 64 & e2.flags) && !(4 & e2.flags))
              return e2;
          }
        }
      }
      class ga extends xa {
        constructor(...t2) {
          super(...t2), this.declareFunctions = [];
        }
      }
      class ba extends Fa {
        createScope(t2) {
          return new ga(t2);
        }
        declareName(t2, e2, s2) {
          const r2 = this.currentScope();
          if (e2 & Ca)
            return this.checkRedeclarationInScope(r2, t2, e2, s2), this.maybeExportDefined(r2, t2), void r2.declareFunctions.push(t2);
          super.declareName(...arguments);
        }
        isRedeclaredInScope(t2, e2, s2) {
          return !!super.isRedeclaredInScope(...arguments) || !!(s2 & Ca) && !t2.declareFunctions.includes(e2) && (t2.lexical.includes(e2) || t2.functions.includes(e2));
        }
        checkLocalExport(t2) {
          -1 === this.scopeStack[0].declareFunctions.indexOf(t2.name) && super.checkLocalExport(t2);
        }
      }
      const Pa = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Ta = Xi({
        AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
        AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
        AssignReservedType: "Cannot overwrite reserved type %0.",
        DeclareClassElement: "The `declare` modifier can only appear on class fields.",
        DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
        DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
        EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
        EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
        EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
        EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
        EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
        EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
        EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
        EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
        EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
        EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
        EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
        GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
        ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
        InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
        InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
        InexactVariance: "Explicit inexact syntax cannot have variance.",
        InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
        MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
        NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
        NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
        OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
        SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
        SpreadVariance: "Spread properties cannot have variance.",
        ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
        ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
        ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
        ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
        ThisParamNoDefault: "The `this` parameter may not have a default value.",
        TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
        UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
        UnexpectedReservedType: "Unexpected reserved type %0.",
        UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
        UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
        UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
        UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
        UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
        UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
        UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
        UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
        UnterminatedFlowComment: "Unterminated flow-comment."
      }, Wi.SyntaxError);
      function wa(t2) {
        return "type" === t2.importKind || "typeof" === t2.importKind;
      }
      function Ba(t2) {
        return (t2.type === Mi.name || !!t2.type.keyword) && "from" !== t2.value;
      }
      const Sa = {
        const: "declare export var",
        let: "declare export var",
        type: "export type",
        interface: "export interface"
      };
      const Na = /\*?\s*@((?:no)?flow)\b/;
      const Ia = {
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02C6",
        tilde: "\u02DC",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        oline: "\u203E",
        frasl: "\u2044",
        euro: "\u20AC",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        int: "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666"
      }, va = /^[\da-fA-F]+$/, ka = /^\d+$/, La = Xi({
        AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
        MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
        MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
        UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
        UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
        UnterminatedJsxContent: "Unterminated JSX contents.",
        UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
      }, Wi.SyntaxError);
      function Oa(t2) {
        return !!t2 && ("JSXOpeningFragment" === t2.type || "JSXClosingFragment" === t2.type);
      }
      function Ma(t2) {
        if ("JSXIdentifier" === t2.type)
          return t2.name;
        if ("JSXNamespacedName" === t2.type)
          return t2.namespace.name + ":" + t2.name.name;
        if ("JSXMemberExpression" === t2.type)
          return Ma(t2.object) + "." + Ma(t2.property);
        throw new Error("Node had unexpected type: " + t2.type);
      }
      $i.j_oTag = new Ji("<tag", false), $i.j_cTag = new Ji("</tag", false), $i.j_expr = new Ji("<tag>...</tag>", true, true), Mi.jsxName = new vi("jsxName"), Mi.jsxText = new vi("jsxText", {
        beforeExpr: true
      }), Mi.jsxTagStart = new vi("jsxTagStart", {
        startsExpr: true
      }), Mi.jsxTagEnd = new vi("jsxTagEnd"), Mi.jsxTagStart.updateContext = function() {
        this.state.context.push($i.j_expr), this.state.context.push($i.j_oTag), this.state.exprAllowed = false;
      }, Mi.jsxTagEnd.updateContext = function(t2) {
        const e2 = this.state.context.pop();
        e2 === $i.j_oTag && t2 === Mi.slash || e2 === $i.j_cTag ? (this.state.context.pop(), this.state.exprAllowed = this.curContext() === $i.j_expr) : this.state.exprAllowed = true;
      };
      class Ra extends xa {
        constructor(...t2) {
          super(...t2), this.types = [], this.enums = [], this.constEnums = [], this.classes = [], this.exportOnlyBindings = [];
        }
      }
      class ja extends Fa {
        createScope(t2) {
          return new Ra(t2);
        }
        declareName(t2, e2, s2) {
          const r2 = this.currentScope();
          if (e2 & Ea)
            return this.maybeExportDefined(r2, t2), void r2.exportOnlyBindings.push(t2);
          super.declareName(...arguments), 2 & e2 && (1 & e2 || (this.checkRedeclarationInScope(r2, t2, e2, s2), this.maybeExportDefined(r2, t2)), r2.types.push(t2)), 256 & e2 && r2.enums.push(t2), 512 & e2 && r2.constEnums.push(t2), e2 & Aa && r2.classes.push(t2);
        }
        isRedeclaredInScope(t2, e2, s2) {
          if (t2.enums.indexOf(e2) > -1) {
            if (256 & s2) {
              return !!(512 & s2) !== t2.constEnums.indexOf(e2) > -1;
            }
            return true;
          }
          return s2 & Aa && t2.classes.indexOf(e2) > -1 ? t2.lexical.indexOf(e2) > -1 && !!(1 & s2) : !!(2 & s2 && t2.types.indexOf(e2) > -1) || super.isRedeclaredInScope(...arguments);
        }
        checkLocalExport(t2) {
          -1 === this.scopeStack[0].types.indexOf(t2.name) && -1 === this.scopeStack[0].exportOnlyBindings.indexOf(t2.name) && super.checkLocalExport(t2);
        }
      }
      class _a {
        constructor() {
          this.stacks = [];
        }
        enter(t2) {
          this.stacks.push(t2);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (2 & this.currentFlags()) > 0;
        }
        get hasYield() {
          return (1 & this.currentFlags()) > 0;
        }
        get hasReturn() {
          return (4 & this.currentFlags()) > 0;
        }
        get hasIn() {
          return (8 & this.currentFlags()) > 0;
        }
      }
      function Ua(t2, e2) {
        return (t2 ? 2 : 0) | (e2 ? 1 : 0);
      }
      function qa(t2) {
        if (null == t2)
          throw new Error("Unexpected ".concat(t2, " value."));
        return t2;
      }
      function Va(t2) {
        if (!t2)
          throw new Error("Assert fail");
      }
      const Ha = Xi({
        AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
        AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
        AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
        ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
        ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
        ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
        DeclareAccessor: "'declare' is not allowed in %0ters.",
        DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
        DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
        DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
        DuplicateModifier: "Duplicate modifier: '%0'.",
        EmptyHeritageClauseType: "'%0' list cannot be empty.",
        EmptyTypeArguments: "Type argument list cannot be empty.",
        EmptyTypeParameters: "Type parameter list cannot be empty.",
        ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
        ImportAliasHasImportType: "An import alias can not use 'import type'.",
        IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
        IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
        IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
        IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
        IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
        IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
        InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
        InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
        InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
        MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
        NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
        NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
        OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
        OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
        PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
        PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
        PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
        ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
        SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
        SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
        SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
        StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
        TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
        UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
        UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
        UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
        UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
        UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
        UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
        UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
      }, Wi.SyntaxError);
      function za(t2) {
        return "private" === t2 || "public" === t2 || "protected" === t2;
      }
      Mi.placeholder = new vi("%%", {
        startsExpr: true
      });
      const Wa = Xi({
        ClassNameIsRequired: "A class name is required."
      }, Wi.SyntaxError);
      function Ga(t2, e2) {
        return t2.some((t3) => Array.isArray(t3) ? t3[0] === e2 : t3 === e2);
      }
      function Ka(t2, e2, s2) {
        const r2 = t2.find((t3) => Array.isArray(t3) ? t3[0] === e2 : t3 === e2);
        return r2 && Array.isArray(r2) ? r2[1][s2] : null;
      }
      const Xa = ["minimal", "smart", "fsharp"], Ja = ["hash", "bar"];
      const $a = {
        estree: (t2) => class extends t2 {
          estreeParseRegExpLiteral({
            pattern: t3,
            flags: e2
          }) {
            let s2 = null;
            try {
              s2 = new RegExp(t3, e2);
            } catch (t4) {
            }
            const r2 = this.estreeParseLiteral(s2);
            return r2.regex = {
              pattern: t3,
              flags: e2
            }, r2;
          }
          estreeParseBigIntLiteral(t3) {
            let e2;
            try {
              e2 = BigInt(t3);
            } catch (t4) {
              e2 = null;
            }
            const s2 = this.estreeParseLiteral(e2);
            return s2.bigint = String(s2.value || t3), s2;
          }
          estreeParseDecimalLiteral(t3) {
            const e2 = this.estreeParseLiteral(null);
            return e2.decimal = String(e2.value || t3), e2;
          }
          estreeParseLiteral(t3) {
            return this.parseLiteral(t3, "Literal");
          }
          directiveToStmt(t3) {
            const e2 = t3.value, s2 = this.startNodeAt(t3.start, t3.loc.start), r2 = this.startNodeAt(e2.start, e2.loc.start);
            return r2.value = e2.extra.expressionValue, r2.raw = e2.extra.raw, s2.expression = this.finishNodeAt(r2, "Literal", e2.end, e2.loc.end), s2.directive = e2.extra.raw.slice(1, -1), this.finishNodeAt(s2, "ExpressionStatement", t3.end, t3.loc.end);
          }
          initFunction(t3, e2) {
            super.initFunction(t3, e2), t3.expression = false;
          }
          checkDeclaration(t3) {
            null != t3 && this.isObjectProperty(t3) ? this.checkDeclaration(t3.value) : super.checkDeclaration(t3);
          }
          getObjectOrClassMethodParams(t3) {
            return t3.value.params;
          }
          isValidDirective(t3) {
            var e2;
            return "ExpressionStatement" === t3.type && "Literal" === t3.expression.type && "string" == typeof t3.expression.value && !(null != (e2 = t3.expression.extra) && e2.parenthesized);
          }
          stmtToDirective(t3) {
            const e2 = super.stmtToDirective(t3), s2 = t3.expression.value;
            return this.addExtra(e2.value, "expressionValue", s2), e2;
          }
          parseBlockBody(t3, ...e2) {
            super.parseBlockBody(t3, ...e2);
            const s2 = t3.directives.map((t4) => this.directiveToStmt(t4));
            t3.body = s2.concat(t3.body), delete t3.directives;
          }
          pushClassMethod(t3, e2, s2, r2, i2, a2) {
            this.parseMethod(e2, s2, r2, i2, a2, "ClassMethod", true), e2.typeParameters && (e2.value.typeParameters = e2.typeParameters, delete e2.typeParameters), t3.body.push(e2);
          }
          parseExprAtom(t3) {
            switch (this.state.type) {
              case Mi.num:
              case Mi.string:
                return this.estreeParseLiteral(this.state.value);
              case Mi.regexp:
                return this.estreeParseRegExpLiteral(this.state.value);
              case Mi.bigint:
                return this.estreeParseBigIntLiteral(this.state.value);
              case Mi.decimal:
                return this.estreeParseDecimalLiteral(this.state.value);
              case Mi._null:
                return this.estreeParseLiteral(null);
              case Mi._true:
                return this.estreeParseLiteral(true);
              case Mi._false:
                return this.estreeParseLiteral(false);
              default:
                return super.parseExprAtom(t3);
            }
          }
          parseMaybePrivateName(...t3) {
            const e2 = super.parseMaybePrivateName(...t3);
            return "PrivateName" === e2.type && this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e2) : e2;
          }
          convertPrivateNameToPrivateIdentifier(t3) {
            const e2 = super.getPrivateNameSV(t3);
            return delete (t3 = t3).id, t3.name = e2, t3.type = "PrivateIdentifier", t3;
          }
          isPrivateName(t3) {
            return this.getPluginOption("estree", "classFeatures") ? "PrivateIdentifier" === t3.type : super.isPrivateName(t3);
          }
          getPrivateNameSV(t3) {
            return this.getPluginOption("estree", "classFeatures") ? t3.name : super.getPrivateNameSV(t3);
          }
          parseLiteral(t3, e2, s2, r2) {
            const i2 = super.parseLiteral(t3, e2, s2, r2);
            return i2.raw = i2.extra.raw, delete i2.extra, i2;
          }
          parseFunctionBody(t3, e2, s2 = false) {
            super.parseFunctionBody(t3, e2, s2), t3.expression = "BlockStatement" !== t3.body.type;
          }
          parseMethod(t3, e2, s2, r2, i2, a2, n2 = false) {
            let o2 = this.startNode();
            return o2.kind = t3.kind, o2 = super.parseMethod(o2, e2, s2, r2, i2, a2, n2), o2.type = "FunctionExpression", delete o2.kind, t3.value = o2, "ClassPrivateMethod" === a2 && (t3.computed = false), a2 = "MethodDefinition", this.finishNode(t3, a2);
          }
          parseClassProperty(...t3) {
            const e2 = super.parseClassProperty(...t3);
            return this.getPluginOption("estree", "classFeatures") && (e2.type = "PropertyDefinition"), e2;
          }
          parseClassPrivateProperty(...t3) {
            const e2 = super.parseClassPrivateProperty(...t3);
            return this.getPluginOption("estree", "classFeatures") && (e2.type = "PropertyDefinition", e2.computed = false), e2;
          }
          parseObjectMethod(t3, e2, s2, r2, i2) {
            const a2 = super.parseObjectMethod(t3, e2, s2, r2, i2);
            return a2 && (a2.type = "Property", "method" === a2.kind && (a2.kind = "init"), a2.shorthand = false), a2;
          }
          parseObjectProperty(t3, e2, s2, r2, i2) {
            const a2 = super.parseObjectProperty(t3, e2, s2, r2, i2);
            return a2 && (a2.kind = "init", a2.type = "Property"), a2;
          }
          toAssignable(t3, e2 = false) {
            return null != t3 && this.isObjectProperty(t3) ? (this.toAssignable(t3.value, e2), t3) : super.toAssignable(t3, e2);
          }
          toAssignableObjectExpressionProp(t3, ...e2) {
            "get" === t3.kind || "set" === t3.kind ? this.raise(t3.key.start, Gi.PatternHasAccessor) : t3.method ? this.raise(t3.key.start, Gi.PatternHasMethod) : super.toAssignableObjectExpressionProp(t3, ...e2);
          }
          finishCallExpression(t3, e2) {
            return super.finishCallExpression(t3, e2), "Import" === t3.callee.type && (t3.type = "ImportExpression", t3.source = t3.arguments[0], delete t3.arguments, delete t3.callee), t3;
          }
          toReferencedArguments(t3) {
            "ImportExpression" !== t3.type && super.toReferencedArguments(t3);
          }
          parseExport(t3) {
            switch (super.parseExport(t3), t3.type) {
              case "ExportAllDeclaration":
                t3.exported = null;
                break;
              case "ExportNamedDeclaration":
                1 === t3.specifiers.length && "ExportNamespaceSpecifier" === t3.specifiers[0].type && (t3.type = "ExportAllDeclaration", t3.exported = t3.specifiers[0].exported, delete t3.specifiers);
            }
            return t3;
          }
          parseSubscript(t3, e2, s2, r2, i2) {
            const a2 = super.parseSubscript(t3, e2, s2, r2, i2);
            if (i2.optionalChainMember) {
              if ("OptionalMemberExpression" !== a2.type && "OptionalCallExpression" !== a2.type || (a2.type = a2.type.substring(8)), i2.stop) {
                const t4 = this.startNodeAtNode(a2);
                return t4.expression = a2, this.finishNode(t4, "ChainExpression");
              }
            } else
              "MemberExpression" !== a2.type && "CallExpression" !== a2.type || (a2.optional = false);
            return a2;
          }
          hasPropertyAsPrivateName(t3) {
            return "ChainExpression" === t3.type && (t3 = t3.expression), super.hasPropertyAsPrivateName(t3);
          }
          isOptionalChain(t3) {
            return "ChainExpression" === t3.type;
          }
          isObjectProperty(t3) {
            return "Property" === t3.type && "init" === t3.kind && !t3.method;
          }
          isObjectMethod(t3) {
            return t3.method || "get" === t3.kind || "set" === t3.kind;
          }
        },
        jsx: (t2) => class extends t2 {
          jsxReadToken() {
            let t3 = "", e2 = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(this.state.start, La.UnterminatedJsxContent);
              const s2 = this.input.charCodeAt(this.state.pos);
              switch (s2) {
                case 60:
                case 123:
                  return this.state.pos === this.state.start ? 60 === s2 && this.state.exprAllowed ? (++this.state.pos, this.finishToken(Mi.jsxTagStart)) : super.getTokenFromCode(s2) : (t3 += this.input.slice(e2, this.state.pos), this.finishToken(Mi.jsxText, t3));
                case 38:
                  t3 += this.input.slice(e2, this.state.pos), t3 += this.jsxReadEntity(), e2 = this.state.pos;
                  break;
                case 62:
                case 125:
                default:
                  _i(s2) ? (t3 += this.input.slice(e2, this.state.pos), t3 += this.jsxReadNewLine(true), e2 = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(t3) {
            const e2 = this.input.charCodeAt(this.state.pos);
            let s2;
            return ++this.state.pos, 13 === e2 && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, s2 = t3 ? "\n" : "\r\n") : s2 = String.fromCharCode(e2), ++this.state.curLine, this.state.lineStart = this.state.pos, s2;
          }
          jsxReadString(t3) {
            let e2 = "", s2 = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(this.state.start, Gi.UnterminatedString);
              const r2 = this.input.charCodeAt(this.state.pos);
              if (r2 === t3)
                break;
              38 === r2 ? (e2 += this.input.slice(s2, this.state.pos), e2 += this.jsxReadEntity(), s2 = this.state.pos) : _i(r2) ? (e2 += this.input.slice(s2, this.state.pos), e2 += this.jsxReadNewLine(false), s2 = this.state.pos) : ++this.state.pos;
            }
            return e2 += this.input.slice(s2, this.state.pos++), this.finishToken(Mi.string, e2);
          }
          jsxReadEntity() {
            let t3, e2 = "", s2 = 0, r2 = this.input[this.state.pos];
            const i2 = ++this.state.pos;
            for (; this.state.pos < this.length && s2++ < 10; ) {
              if (r2 = this.input[this.state.pos++], ";" === r2) {
                "#" === e2[0] ? "x" === e2[1] ? (e2 = e2.substr(2), va.test(e2) && (t3 = String.fromCodePoint(parseInt(e2, 16)))) : (e2 = e2.substr(1), ka.test(e2) && (t3 = String.fromCodePoint(parseInt(e2, 10)))) : t3 = Ia[e2];
                break;
              }
              e2 += r2;
            }
            return t3 || (this.state.pos = i2, "&");
          }
          jsxReadWord() {
            let t3;
            const e2 = this.state.pos;
            do {
              t3 = this.input.charCodeAt(++this.state.pos);
            } while (aa(t3) || 45 === t3);
            return this.finishToken(Mi.jsxName, this.input.slice(e2, this.state.pos));
          }
          jsxParseIdentifier() {
            const t3 = this.startNode();
            return this.match(Mi.jsxName) ? t3.name = this.state.value : this.state.type.keyword ? t3.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(t3, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const t3 = this.state.start, e2 = this.state.startLoc, s2 = this.jsxParseIdentifier();
            if (!this.eat(Mi.colon))
              return s2;
            const r2 = this.startNodeAt(t3, e2);
            return r2.namespace = s2, r2.name = this.jsxParseIdentifier(), this.finishNode(r2, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const t3 = this.state.start, e2 = this.state.startLoc;
            let s2 = this.jsxParseNamespacedName();
            if ("JSXNamespacedName" === s2.type)
              return s2;
            for (; this.eat(Mi.dot); ) {
              const r2 = this.startNodeAt(t3, e2);
              r2.object = s2, r2.property = this.jsxParseIdentifier(), s2 = this.finishNode(r2, "JSXMemberExpression");
            }
            return s2;
          }
          jsxParseAttributeValue() {
            let t3;
            switch (this.state.type) {
              case Mi.braceL:
                return t3 = this.startNode(), this.next(), t3 = this.jsxParseExpressionContainer(t3), "JSXEmptyExpression" === t3.expression.type && this.raise(t3.start, La.AttributeIsEmpty), t3;
              case Mi.jsxTagStart:
              case Mi.string:
                return this.parseExprAtom();
              default:
                throw this.raise(this.state.start, La.UnsupportedJsxValue);
            }
          }
          jsxParseEmptyExpression() {
            const t3 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
            return this.finishNodeAt(t3, "JSXEmptyExpression", this.state.start, this.state.startLoc);
          }
          jsxParseSpreadChild(t3) {
            return this.next(), t3.expression = this.parseExpression(), this.expect(Mi.braceR), this.finishNode(t3, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(t3) {
            if (this.match(Mi.braceR))
              t3.expression = this.jsxParseEmptyExpression();
            else {
              const e2 = this.parseExpression();
              t3.expression = e2;
            }
            return this.expect(Mi.braceR), this.finishNode(t3, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const t3 = this.startNode();
            return this.eat(Mi.braceL) ? (this.expect(Mi.ellipsis), t3.argument = this.parseMaybeAssignAllowIn(), this.expect(Mi.braceR), this.finishNode(t3, "JSXSpreadAttribute")) : (t3.name = this.jsxParseNamespacedName(), t3.value = this.eat(Mi.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(t3, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(t3, e2) {
            const s2 = this.startNodeAt(t3, e2);
            return this.match(Mi.jsxTagEnd) ? (this.expect(Mi.jsxTagEnd), this.finishNode(s2, "JSXOpeningFragment")) : (s2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s2));
          }
          jsxParseOpeningElementAfterName(t3) {
            const e2 = [];
            for (; !this.match(Mi.slash) && !this.match(Mi.jsxTagEnd); )
              e2.push(this.jsxParseAttribute());
            return t3.attributes = e2, t3.selfClosing = this.eat(Mi.slash), this.expect(Mi.jsxTagEnd), this.finishNode(t3, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(t3, e2) {
            const s2 = this.startNodeAt(t3, e2);
            return this.match(Mi.jsxTagEnd) ? (this.expect(Mi.jsxTagEnd), this.finishNode(s2, "JSXClosingFragment")) : (s2.name = this.jsxParseElementName(), this.expect(Mi.jsxTagEnd), this.finishNode(s2, "JSXClosingElement"));
          }
          jsxParseElementAt(t3, e2) {
            const s2 = this.startNodeAt(t3, e2), r2 = [], i2 = this.jsxParseOpeningElementAt(t3, e2);
            let a2 = null;
            if (!i2.selfClosing) {
              t:
                for (; ; )
                  switch (this.state.type) {
                    case Mi.jsxTagStart:
                      if (t3 = this.state.start, e2 = this.state.startLoc, this.next(), this.eat(Mi.slash)) {
                        a2 = this.jsxParseClosingElementAt(t3, e2);
                        break t;
                      }
                      r2.push(this.jsxParseElementAt(t3, e2));
                      break;
                    case Mi.jsxText:
                      r2.push(this.parseExprAtom());
                      break;
                    case Mi.braceL: {
                      const t4 = this.startNode();
                      this.next(), this.match(Mi.ellipsis) ? r2.push(this.jsxParseSpreadChild(t4)) : r2.push(this.jsxParseExpressionContainer(t4));
                      break;
                    }
                    default:
                      throw this.unexpected();
                  }
              Oa(i2) && !Oa(a2) ? this.raise(a2.start, La.MissingClosingTagFragment) : !Oa(i2) && Oa(a2) ? this.raise(a2.start, La.MissingClosingTagElement, Ma(i2.name)) : Oa(i2) || Oa(a2) || Ma(a2.name) !== Ma(i2.name) && this.raise(a2.start, La.MissingClosingTagElement, Ma(i2.name));
            }
            if (Oa(i2) ? (s2.openingFragment = i2, s2.closingFragment = a2) : (s2.openingElement = i2, s2.closingElement = a2), s2.children = r2, this.isRelational("<"))
              throw this.raise(this.state.start, La.UnwrappedAdjacentJSXElements);
            return Oa(i2) ? this.finishNode(s2, "JSXFragment") : this.finishNode(s2, "JSXElement");
          }
          jsxParseElement() {
            const t3 = this.state.start, e2 = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(t3, e2);
          }
          parseExprAtom(t3) {
            return this.match(Mi.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(Mi.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && 33 !== this.input.charCodeAt(this.state.pos) ? (this.finishToken(Mi.jsxTagStart), this.jsxParseElement()) : super.parseExprAtom(t3);
          }
          getTokenFromCode(t3) {
            if (this.state.inPropertyName)
              return super.getTokenFromCode(t3);
            const e2 = this.curContext();
            if (e2 === $i.j_expr)
              return this.jsxReadToken();
            if (e2 === $i.j_oTag || e2 === $i.j_cTag) {
              if (ia(t3))
                return this.jsxReadWord();
              if (62 === t3)
                return ++this.state.pos, this.finishToken(Mi.jsxTagEnd);
              if ((34 === t3 || 39 === t3) && e2 === $i.j_oTag)
                return this.jsxReadString(t3);
            }
            return 60 === t3 && this.state.exprAllowed && 33 !== this.input.charCodeAt(this.state.pos + 1) ? (++this.state.pos, this.finishToken(Mi.jsxTagStart)) : super.getTokenFromCode(t3);
          }
          updateContext(t3) {
            if (this.match(Mi.braceL)) {
              const e2 = this.curContext();
              e2 === $i.j_oTag ? this.state.context.push($i.braceExpression) : e2 === $i.j_expr ? this.state.context.push($i.templateQuasi) : super.updateContext(t3), this.state.exprAllowed = true;
            } else {
              if (!this.match(Mi.slash) || t3 !== Mi.jsxTagStart)
                return super.updateContext(t3);
              this.state.context.length -= 2, this.state.context.push($i.j_cTag), this.state.exprAllowed = false;
            }
          }
        },
        flow: (t2) => class extends t2 {
          constructor(...t3) {
            super(...t3), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return ba;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(t3, e2) {
            return t3 !== Mi.string && t3 !== Mi.semi && t3 !== Mi.interpreterDirective && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(t3, e2);
          }
          addComment(t3) {
            if (void 0 === this.flowPragma) {
              const e2 = Na.exec(t3.value);
              if (e2) {
                if ("flow" === e2[1])
                  this.flowPragma = "flow";
                else {
                  if ("noflow" !== e2[1])
                    throw new Error("Unexpected flow pragma");
                  this.flowPragma = "noflow";
                }
              } else
                ;
            }
            return super.addComment(t3);
          }
          flowParseTypeInitialiser(t3) {
            const e2 = this.state.inType;
            this.state.inType = true, this.expect(t3 || Mi.colon);
            const s2 = this.flowParseType();
            return this.state.inType = e2, s2;
          }
          flowParsePredicate() {
            const t3 = this.startNode(), e2 = this.state.start;
            return this.next(), this.expectContextual("checks"), this.state.lastTokStart > e2 + 1 && this.raise(e2, Ta.UnexpectedSpaceBetweenModuloChecks), this.eat(Mi.parenL) ? (t3.value = this.parseExpression(), this.expect(Mi.parenR), this.finishNode(t3, "DeclaredPredicate")) : this.finishNode(t3, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            const t3 = this.state.inType;
            this.state.inType = true, this.expect(Mi.colon);
            let e2 = null, s2 = null;
            return this.match(Mi.modulo) ? (this.state.inType = t3, s2 = this.flowParsePredicate()) : (e2 = this.flowParseType(), this.state.inType = t3, this.match(Mi.modulo) && (s2 = this.flowParsePredicate())), [e2, s2];
          }
          flowParseDeclareClass(t3) {
            return this.next(), this.flowParseInterfaceish(t3, true), this.finishNode(t3, "DeclareClass");
          }
          flowParseDeclareFunction(t3) {
            this.next();
            const e2 = t3.id = this.parseIdentifier(), s2 = this.startNode(), r2 = this.startNode();
            this.isRelational("<") ? s2.typeParameters = this.flowParseTypeParameterDeclaration() : s2.typeParameters = null, this.expect(Mi.parenL);
            const i2 = this.flowParseFunctionTypeParams();
            return s2.params = i2.params, s2.rest = i2.rest, s2.this = i2._this, this.expect(Mi.parenR), [s2.returnType, t3.predicate] = this.flowParseTypeAndPredicateInitialiser(), r2.typeAnnotation = this.finishNode(s2, "FunctionTypeAnnotation"), e2.typeAnnotation = this.finishNode(r2, "TypeAnnotation"), this.resetEndLocation(e2), this.semicolon(), this.scope.declareName(t3.id.name, 2048, t3.id.start), this.finishNode(t3, "DeclareFunction");
          }
          flowParseDeclare(t3, e2) {
            if (this.match(Mi._class))
              return this.flowParseDeclareClass(t3);
            if (this.match(Mi._function))
              return this.flowParseDeclareFunction(t3);
            if (this.match(Mi._var))
              return this.flowParseDeclareVariable(t3);
            if (this.eatContextual("module"))
              return this.match(Mi.dot) ? this.flowParseDeclareModuleExports(t3) : (e2 && this.raise(this.state.lastTokStart, Ta.NestedDeclareModule), this.flowParseDeclareModule(t3));
            if (this.isContextual("type"))
              return this.flowParseDeclareTypeAlias(t3);
            if (this.isContextual("opaque"))
              return this.flowParseDeclareOpaqueType(t3);
            if (this.isContextual("interface"))
              return this.flowParseDeclareInterface(t3);
            if (this.match(Mi._export))
              return this.flowParseDeclareExportDeclaration(t3, e2);
            throw this.unexpected();
          }
          flowParseDeclareVariable(t3) {
            return this.next(), t3.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(t3.id.name, 5, t3.id.start), this.semicolon(), this.finishNode(t3, "DeclareVariable");
          }
          flowParseDeclareModule(t3) {
            this.scope.enter(0), this.match(Mi.string) ? t3.id = this.parseExprAtom() : t3.id = this.parseIdentifier();
            const e2 = t3.body = this.startNode(), s2 = e2.body = [];
            for (this.expect(Mi.braceL); !this.match(Mi.braceR); ) {
              let t4 = this.startNode();
              this.match(Mi._import) ? (this.next(), this.isContextual("type") || this.match(Mi._typeof) || this.raise(this.state.lastTokStart, Ta.InvalidNonTypeImportInDeclareModule), this.parseImport(t4)) : (this.expectContextual("declare", Ta.UnsupportedStatementInDeclareModule), t4 = this.flowParseDeclare(t4, true)), s2.push(t4);
            }
            this.scope.exit(), this.expect(Mi.braceR), this.finishNode(e2, "BlockStatement");
            let r2 = null, i2 = false;
            return s2.forEach((t4) => {
              !function(t5) {
                return "DeclareExportAllDeclaration" === t5.type || "DeclareExportDeclaration" === t5.type && (!t5.declaration || "TypeAlias" !== t5.declaration.type && "InterfaceDeclaration" !== t5.declaration.type);
              }(t4) ? "DeclareModuleExports" === t4.type && (i2 && this.raise(t4.start, Ta.DuplicateDeclareModuleExports), "ES" === r2 && this.raise(t4.start, Ta.AmbiguousDeclareModuleKind), r2 = "CommonJS", i2 = true) : ("CommonJS" === r2 && this.raise(t4.start, Ta.AmbiguousDeclareModuleKind), r2 = "ES");
            }), t3.kind = r2 || "CommonJS", this.finishNode(t3, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(t3, e2) {
            if (this.expect(Mi._export), this.eat(Mi._default))
              return this.match(Mi._function) || this.match(Mi._class) ? t3.declaration = this.flowParseDeclare(this.startNode()) : (t3.declaration = this.flowParseType(), this.semicolon()), t3.default = true, this.finishNode(t3, "DeclareExportDeclaration");
            if (this.match(Mi._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !e2) {
              const t4 = this.state.value, e3 = Sa[t4];
              throw this.raise(this.state.start, Ta.UnsupportedDeclareExportKind, t4, e3);
            }
            if (this.match(Mi._var) || this.match(Mi._function) || this.match(Mi._class) || this.isContextual("opaque"))
              return t3.declaration = this.flowParseDeclare(this.startNode()), t3.default = false, this.finishNode(t3, "DeclareExportDeclaration");
            if (this.match(Mi.star) || this.match(Mi.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque"))
              return "ExportNamedDeclaration" === (t3 = this.parseExport(t3)).type && (t3.type = "ExportDeclaration", t3.default = false, delete t3.exportKind), t3.type = "Declare" + t3.type, t3;
            throw this.unexpected();
          }
          flowParseDeclareModuleExports(t3) {
            return this.next(), this.expectContextual("exports"), t3.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(t3, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(t3) {
            return this.next(), this.flowParseTypeAlias(t3), t3.type = "DeclareTypeAlias", t3;
          }
          flowParseDeclareOpaqueType(t3) {
            return this.next(), this.flowParseOpaqueType(t3, true), t3.type = "DeclareOpaqueType", t3;
          }
          flowParseDeclareInterface(t3) {
            return this.next(), this.flowParseInterfaceish(t3), this.finishNode(t3, "DeclareInterface");
          }
          flowParseInterfaceish(t3, e2 = false) {
            if (t3.id = this.flowParseRestrictedIdentifier(!e2, true), this.scope.declareName(t3.id.name, e2 ? 17 : 9, t3.id.start), this.isRelational("<") ? t3.typeParameters = this.flowParseTypeParameterDeclaration() : t3.typeParameters = null, t3.extends = [], t3.implements = [], t3.mixins = [], this.eat(Mi._extends))
              do {
                t3.extends.push(this.flowParseInterfaceExtends());
              } while (!e2 && this.eat(Mi.comma));
            if (this.isContextual("mixins")) {
              this.next();
              do {
                t3.mixins.push(this.flowParseInterfaceExtends());
              } while (this.eat(Mi.comma));
            }
            if (this.isContextual("implements")) {
              this.next();
              do {
                t3.implements.push(this.flowParseInterfaceExtends());
              } while (this.eat(Mi.comma));
            }
            t3.body = this.flowParseObjectType({
              allowStatic: e2,
              allowExact: false,
              allowSpread: false,
              allowProto: e2,
              allowInexact: false
            });
          }
          flowParseInterfaceExtends() {
            const t3 = this.startNode();
            return t3.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? t3.typeParameters = this.flowParseTypeParameterInstantiation() : t3.typeParameters = null, this.finishNode(t3, "InterfaceExtends");
          }
          flowParseInterface(t3) {
            return this.flowParseInterfaceish(t3), this.finishNode(t3, "InterfaceDeclaration");
          }
          checkNotUnderscore(t3) {
            "_" === t3 && this.raise(this.state.start, Ta.UnexpectedReservedUnderscore);
          }
          checkReservedType(t3, e2, s2) {
            Pa.has(t3) && this.raise(e2, s2 ? Ta.AssignReservedType : Ta.UnexpectedReservedType, t3);
          }
          flowParseRestrictedIdentifier(t3, e2) {
            return this.checkReservedType(this.state.value, this.state.start, e2), this.parseIdentifier(t3);
          }
          flowParseTypeAlias(t3) {
            return t3.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(t3.id.name, 9, t3.id.start), this.isRelational("<") ? t3.typeParameters = this.flowParseTypeParameterDeclaration() : t3.typeParameters = null, t3.right = this.flowParseTypeInitialiser(Mi.eq), this.semicolon(), this.finishNode(t3, "TypeAlias");
          }
          flowParseOpaqueType(t3, e2) {
            return this.expectContextual("type"), t3.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(t3.id.name, 9, t3.id.start), this.isRelational("<") ? t3.typeParameters = this.flowParseTypeParameterDeclaration() : t3.typeParameters = null, t3.supertype = null, this.match(Mi.colon) && (t3.supertype = this.flowParseTypeInitialiser(Mi.colon)), t3.impltype = null, e2 || (t3.impltype = this.flowParseTypeInitialiser(Mi.eq)), this.semicolon(), this.finishNode(t3, "OpaqueType");
          }
          flowParseTypeParameter(t3 = false) {
            const e2 = this.state.start, s2 = this.startNode(), r2 = this.flowParseVariance(), i2 = this.flowParseTypeAnnotatableIdentifier();
            return s2.name = i2.name, s2.variance = r2, s2.bound = i2.typeAnnotation, this.match(Mi.eq) ? (this.eat(Mi.eq), s2.default = this.flowParseType()) : t3 && this.raise(e2, Ta.MissingTypeParamDefault), this.finishNode(s2, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const t3 = this.state.inType, e2 = this.startNode();
            e2.params = [], this.state.inType = true, this.isRelational("<") || this.match(Mi.jsxTagStart) ? this.next() : this.unexpected();
            let s2 = false;
            do {
              const t4 = this.flowParseTypeParameter(s2);
              e2.params.push(t4), t4.default && (s2 = true), this.isRelational(">") || this.expect(Mi.comma);
            } while (!this.isRelational(">"));
            return this.expectRelational(">"), this.state.inType = t3, this.finishNode(e2, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            const t3 = this.startNode(), e2 = this.state.inType;
            t3.params = [], this.state.inType = true, this.expectRelational("<");
            const s2 = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = false; !this.isRelational(">"); )
              t3.params.push(this.flowParseType()), this.isRelational(">") || this.expect(Mi.comma);
            return this.state.noAnonFunctionType = s2, this.expectRelational(">"), this.state.inType = e2, this.finishNode(t3, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const t3 = this.startNode(), e2 = this.state.inType;
            for (t3.params = [], this.state.inType = true, this.expectRelational("<"); !this.isRelational(">"); )
              t3.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(">") || this.expect(Mi.comma);
            return this.expectRelational(">"), this.state.inType = e2, this.finishNode(t3, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const t3 = this.startNode();
            if (this.expectContextual("interface"), t3.extends = [], this.eat(Mi._extends))
              do {
                t3.extends.push(this.flowParseInterfaceExtends());
              } while (this.eat(Mi.comma));
            return t3.body = this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: false,
              allowProto: false,
              allowInexact: false
            }), this.finishNode(t3, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(Mi.num) || this.match(Mi.string) ? this.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(t3, e2, s2) {
            return t3.static = e2, this.lookahead().type === Mi.colon ? (t3.id = this.flowParseObjectPropertyKey(), t3.key = this.flowParseTypeInitialiser()) : (t3.id = null, t3.key = this.flowParseType()), this.expect(Mi.bracketR), t3.value = this.flowParseTypeInitialiser(), t3.variance = s2, this.finishNode(t3, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(t3, e2) {
            return t3.static = e2, t3.id = this.flowParseObjectPropertyKey(), this.expect(Mi.bracketR), this.expect(Mi.bracketR), this.isRelational("<") || this.match(Mi.parenL) ? (t3.method = true, t3.optional = false, t3.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t3.start, t3.loc.start))) : (t3.method = false, this.eat(Mi.question) && (t3.optional = true), t3.value = this.flowParseTypeInitialiser()), this.finishNode(t3, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(t3) {
            for (t3.params = [], t3.rest = null, t3.typeParameters = null, t3.this = null, this.isRelational("<") && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(Mi.parenL), this.match(Mi._this) && (t3.this = this.flowParseFunctionTypeParam(true), t3.this.name = null, this.match(Mi.parenR) || this.expect(Mi.comma)); !this.match(Mi.parenR) && !this.match(Mi.ellipsis); )
              t3.params.push(this.flowParseFunctionTypeParam(false)), this.match(Mi.parenR) || this.expect(Mi.comma);
            return this.eat(Mi.ellipsis) && (t3.rest = this.flowParseFunctionTypeParam(false)), this.expect(Mi.parenR), t3.returnType = this.flowParseTypeInitialiser(), this.finishNode(t3, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(t3, e2) {
            const s2 = this.startNode();
            return t3.static = e2, t3.value = this.flowParseObjectTypeMethodish(s2), this.finishNode(t3, "ObjectTypeCallProperty");
          }
          flowParseObjectType({
            allowStatic: t3,
            allowExact: e2,
            allowSpread: s2,
            allowProto: r2,
            allowInexact: i2
          }) {
            const a2 = this.state.inType;
            this.state.inType = true;
            const n2 = this.startNode();
            let o2, u2;
            n2.callProperties = [], n2.properties = [], n2.indexers = [], n2.internalSlots = [];
            let h2 = false;
            for (e2 && this.match(Mi.braceBarL) ? (this.expect(Mi.braceBarL), o2 = Mi.braceBarR, u2 = true) : (this.expect(Mi.braceL), o2 = Mi.braceR, u2 = false), n2.exact = u2; !this.match(o2); ) {
              let e3 = false, a3 = null, o3 = null;
              const c3 = this.startNode();
              if (r2 && this.isContextual("proto")) {
                const e4 = this.lookahead();
                e4.type !== Mi.colon && e4.type !== Mi.question && (this.next(), a3 = this.state.start, t3 = false);
              }
              if (t3 && this.isContextual("static")) {
                const t4 = this.lookahead();
                t4.type !== Mi.colon && t4.type !== Mi.question && (this.next(), e3 = true);
              }
              const p2 = this.flowParseVariance();
              if (this.eat(Mi.bracketL))
                null != a3 && this.unexpected(a3), this.eat(Mi.bracketL) ? (p2 && this.unexpected(p2.start), n2.internalSlots.push(this.flowParseObjectTypeInternalSlot(c3, e3))) : n2.indexers.push(this.flowParseObjectTypeIndexer(c3, e3, p2));
              else if (this.match(Mi.parenL) || this.isRelational("<"))
                null != a3 && this.unexpected(a3), p2 && this.unexpected(p2.start), n2.callProperties.push(this.flowParseObjectTypeCallProperty(c3, e3));
              else {
                let t4 = "init";
                if (this.isContextual("get") || this.isContextual("set")) {
                  const e4 = this.lookahead();
                  e4.type !== Mi.name && e4.type !== Mi.string && e4.type !== Mi.num || (t4 = this.state.value, this.next());
                }
                const r3 = this.flowParseObjectTypeProperty(c3, e3, a3, p2, t4, s2, null != i2 ? i2 : !u2);
                null === r3 ? (h2 = true, o3 = this.state.lastTokStart) : n2.properties.push(r3);
              }
              this.flowObjectTypeSemicolon(), !o3 || this.match(Mi.braceR) || this.match(Mi.braceBarR) || this.raise(o3, Ta.UnexpectedExplicitInexactInObject);
            }
            this.expect(o2), s2 && (n2.inexact = h2);
            const c2 = this.finishNode(n2, "ObjectTypeAnnotation");
            return this.state.inType = a2, c2;
          }
          flowParseObjectTypeProperty(t3, e2, s2, r2, i2, a2, n2) {
            if (this.eat(Mi.ellipsis)) {
              return this.match(Mi.comma) || this.match(Mi.semi) || this.match(Mi.braceR) || this.match(Mi.braceBarR) ? (a2 ? n2 || this.raise(this.state.lastTokStart, Ta.InexactInsideExact) : this.raise(this.state.lastTokStart, Ta.InexactInsideNonObject), r2 && this.raise(r2.start, Ta.InexactVariance), null) : (a2 || this.raise(this.state.lastTokStart, Ta.UnexpectedSpreadType), null != s2 && this.unexpected(s2), r2 && this.raise(r2.start, Ta.SpreadVariance), t3.argument = this.flowParseType(), this.finishNode(t3, "ObjectTypeSpreadProperty"));
            }
            {
              t3.key = this.flowParseObjectPropertyKey(), t3.static = e2, t3.proto = null != s2, t3.kind = i2;
              let n3 = false;
              return this.isRelational("<") || this.match(Mi.parenL) ? (t3.method = true, null != s2 && this.unexpected(s2), r2 && this.unexpected(r2.start), t3.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t3.start, t3.loc.start)), "get" !== i2 && "set" !== i2 || this.flowCheckGetterSetterParams(t3), !a2 && "constructor" === t3.key.name && t3.value.this && this.raise(t3.value.this.start, Ta.ThisParamBannedInConstructor)) : ("init" !== i2 && this.unexpected(), t3.method = false, this.eat(Mi.question) && (n3 = true), t3.value = this.flowParseTypeInitialiser(), t3.variance = r2), t3.optional = n3, this.finishNode(t3, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(t3) {
            const e2 = "get" === t3.kind ? 0 : 1, s2 = t3.start, r2 = t3.value.params.length + (t3.value.rest ? 1 : 0);
            t3.value.this && this.raise(t3.value.this.start, "get" === t3.kind ? Ta.GetterMayNotHaveThisParam : Ta.SetterMayNotHaveThisParam), r2 !== e2 && ("get" === t3.kind ? this.raise(s2, Gi.BadGetterArity) : this.raise(s2, Gi.BadSetterArity)), "set" === t3.kind && t3.value.rest && this.raise(s2, Gi.BadSetterRestParameter);
          }
          flowObjectTypeSemicolon() {
            this.eat(Mi.semi) || this.eat(Mi.comma) || this.match(Mi.braceR) || this.match(Mi.braceBarR) || this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(t3, e2, s2) {
            t3 = t3 || this.state.start, e2 = e2 || this.state.startLoc;
            let r2 = s2 || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(Mi.dot); ) {
              const s3 = this.startNodeAt(t3, e2);
              s3.qualification = r2, s3.id = this.flowParseRestrictedIdentifier(true), r2 = this.finishNode(s3, "QualifiedTypeIdentifier");
            }
            return r2;
          }
          flowParseGenericType(t3, e2, s2) {
            const r2 = this.startNodeAt(t3, e2);
            return r2.typeParameters = null, r2.id = this.flowParseQualifiedTypeIdentifier(t3, e2, s2), this.isRelational("<") && (r2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r2, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const t3 = this.startNode();
            return this.expect(Mi._typeof), t3.argument = this.flowParsePrimaryType(), this.finishNode(t3, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const t3 = this.startNode();
            for (t3.types = [], this.expect(Mi.bracketL); this.state.pos < this.length && !this.match(Mi.bracketR) && (t3.types.push(this.flowParseType()), !this.match(Mi.bracketR)); )
              this.expect(Mi.comma);
            return this.expect(Mi.bracketR), this.finishNode(t3, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(t3) {
            let e2 = null, s2 = false, r2 = null;
            const i2 = this.startNode(), a2 = this.lookahead(), n2 = this.state.type === Mi._this;
            return a2.type === Mi.colon || a2.type === Mi.question ? (n2 && !t3 && this.raise(i2.start, Ta.ThisParamMustBeFirst), e2 = this.parseIdentifier(n2), this.eat(Mi.question) && (s2 = true, n2 && this.raise(i2.start, Ta.ThisParamMayNotBeOptional)), r2 = this.flowParseTypeInitialiser()) : r2 = this.flowParseType(), i2.name = e2, i2.optional = s2, i2.typeAnnotation = r2, this.finishNode(i2, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(t3) {
            const e2 = this.startNodeAt(t3.start, t3.loc.start);
            return e2.name = null, e2.optional = false, e2.typeAnnotation = t3, this.finishNode(e2, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(t3 = []) {
            let e2 = null, s2 = null;
            for (this.match(Mi._this) && (s2 = this.flowParseFunctionTypeParam(true), s2.name = null, this.match(Mi.parenR) || this.expect(Mi.comma)); !this.match(Mi.parenR) && !this.match(Mi.ellipsis); )
              t3.push(this.flowParseFunctionTypeParam(false)), this.match(Mi.parenR) || this.expect(Mi.comma);
            return this.eat(Mi.ellipsis) && (e2 = this.flowParseFunctionTypeParam(false)), {
              params: t3,
              rest: e2,
              _this: s2
            };
          }
          flowIdentToTypeAnnotation(t3, e2, s2, r2) {
            switch (r2.name) {
              case "any":
                return this.finishNode(s2, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(s2, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(s2, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(s2, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(s2, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(s2, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(s2, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(r2.name), this.flowParseGenericType(t3, e2, r2);
            }
          }
          flowParsePrimaryType() {
            const t3 = this.state.start, e2 = this.state.startLoc, s2 = this.startNode();
            let r2, i2, a2 = false;
            const n2 = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case Mi.name:
                return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(t3, e2, s2, this.parseIdentifier());
              case Mi.braceL:
                return this.flowParseObjectType({
                  allowStatic: false,
                  allowExact: false,
                  allowSpread: true,
                  allowProto: false,
                  allowInexact: true
                });
              case Mi.braceBarL:
                return this.flowParseObjectType({
                  allowStatic: false,
                  allowExact: true,
                  allowSpread: true,
                  allowProto: false,
                  allowInexact: false
                });
              case Mi.bracketL:
                return this.state.noAnonFunctionType = false, i2 = this.flowParseTupleType(), this.state.noAnonFunctionType = n2, i2;
              case Mi.relational:
                if ("<" === this.state.value)
                  return s2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(Mi.parenL), r2 = this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(Mi.parenR), this.expect(Mi.arrow), s2.returnType = this.flowParseType(), this.finishNode(s2, "FunctionTypeAnnotation");
                break;
              case Mi.parenL:
                if (this.next(), !this.match(Mi.parenR) && !this.match(Mi.ellipsis))
                  if (this.match(Mi.name) || this.match(Mi._this)) {
                    const t4 = this.lookahead().type;
                    a2 = t4 !== Mi.question && t4 !== Mi.colon;
                  } else
                    a2 = true;
                if (a2) {
                  if (this.state.noAnonFunctionType = false, i2 = this.flowParseType(), this.state.noAnonFunctionType = n2, this.state.noAnonFunctionType || !(this.match(Mi.comma) || this.match(Mi.parenR) && this.lookahead().type === Mi.arrow))
                    return this.expect(Mi.parenR), i2;
                  this.eat(Mi.comma);
                }
                return r2 = i2 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(i2)]) : this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(Mi.parenR), this.expect(Mi.arrow), s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
              case Mi.string:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case Mi._true:
              case Mi._false:
                return s2.value = this.match(Mi._true), this.next(), this.finishNode(s2, "BooleanLiteralTypeAnnotation");
              case Mi.plusMin:
                if ("-" === this.state.value) {
                  if (this.next(), this.match(Mi.num))
                    return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", s2.start, s2.loc.start);
                  if (this.match(Mi.bigint))
                    return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", s2.start, s2.loc.start);
                  throw this.raise(this.state.start, Ta.UnexpectedSubtractionOperand);
                }
                throw this.unexpected();
              case Mi.num:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case Mi.bigint:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case Mi._void:
                return this.next(), this.finishNode(s2, "VoidTypeAnnotation");
              case Mi._null:
                return this.next(), this.finishNode(s2, "NullLiteralTypeAnnotation");
              case Mi._this:
                return this.next(), this.finishNode(s2, "ThisTypeAnnotation");
              case Mi.star:
                return this.next(), this.finishNode(s2, "ExistsTypeAnnotation");
              default:
                if ("typeof" === this.state.type.keyword)
                  return this.flowParseTypeofType();
                if (this.state.type.keyword) {
                  const t4 = this.state.type.label;
                  return this.next(), super.createIdentifier(s2, t4);
                }
            }
            throw this.unexpected();
          }
          flowParsePostfixType() {
            const t3 = this.state.start, e2 = this.state.startLoc;
            let s2 = this.flowParsePrimaryType(), r2 = false;
            for (; (this.match(Mi.bracketL) || this.match(Mi.questionDot)) && !this.canInsertSemicolon(); ) {
              const i2 = this.startNodeAt(t3, e2), a2 = this.eat(Mi.questionDot);
              r2 = r2 || a2, this.expect(Mi.bracketL), !a2 && this.match(Mi.bracketR) ? (i2.elementType = s2, this.next(), s2 = this.finishNode(i2, "ArrayTypeAnnotation")) : (i2.objectType = s2, i2.indexType = this.flowParseType(), this.expect(Mi.bracketR), r2 ? (i2.optional = a2, s2 = this.finishNode(i2, "OptionalIndexedAccessType")) : s2 = this.finishNode(i2, "IndexedAccessType"));
            }
            return s2;
          }
          flowParsePrefixType() {
            const t3 = this.startNode();
            return this.eat(Mi.question) ? (t3.typeAnnotation = this.flowParsePrefixType(), this.finishNode(t3, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            const t3 = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(Mi.arrow)) {
              const e2 = this.startNodeAt(t3.start, t3.loc.start);
              return e2.params = [this.reinterpretTypeAsFunctionTypeParam(t3)], e2.rest = null, e2.this = null, e2.returnType = this.flowParseType(), e2.typeParameters = null, this.finishNode(e2, "FunctionTypeAnnotation");
            }
            return t3;
          }
          flowParseIntersectionType() {
            const t3 = this.startNode();
            this.eat(Mi.bitwiseAND);
            const e2 = this.flowParseAnonFunctionWithoutParens();
            for (t3.types = [e2]; this.eat(Mi.bitwiseAND); )
              t3.types.push(this.flowParseAnonFunctionWithoutParens());
            return 1 === t3.types.length ? e2 : this.finishNode(t3, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const t3 = this.startNode();
            this.eat(Mi.bitwiseOR);
            const e2 = this.flowParseIntersectionType();
            for (t3.types = [e2]; this.eat(Mi.bitwiseOR); )
              t3.types.push(this.flowParseIntersectionType());
            return 1 === t3.types.length ? e2 : this.finishNode(t3, "UnionTypeAnnotation");
          }
          flowParseType() {
            const t3 = this.state.inType;
            this.state.inType = true;
            const e2 = this.flowParseUnionType();
            return this.state.inType = t3, this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType, e2;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === Mi.name && "_" === this.state.value) {
              const t3 = this.state.start, e2 = this.state.startLoc, s2 = this.parseIdentifier();
              return this.flowParseGenericType(t3, e2, s2);
            }
            return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            const t3 = this.startNode();
            return t3.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(t3, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(t3) {
            const e2 = t3 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(Mi.colon) && (e2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e2)), e2;
          }
          typeCastToParameter(t3) {
            return t3.expression.typeAnnotation = t3.typeAnnotation, this.resetEndLocation(t3.expression, t3.typeAnnotation.end, t3.typeAnnotation.loc.end), t3.expression;
          }
          flowParseVariance() {
            let t3 = null;
            return this.match(Mi.plusMin) && (t3 = this.startNode(), "+" === this.state.value ? t3.kind = "plus" : t3.kind = "minus", this.next(), this.finishNode(t3, "Variance")), t3;
          }
          parseFunctionBody(t3, e2, s2 = false) {
            return e2 ? this.forwardNoArrowParamsConversionAt(t3, () => super.parseFunctionBody(t3, true, s2)) : super.parseFunctionBody(t3, false, s2);
          }
          parseFunctionBodyAndFinish(t3, e2, s2 = false) {
            if (this.match(Mi.colon)) {
              const e3 = this.startNode();
              [e3.typeAnnotation, t3.predicate] = this.flowParseTypeAndPredicateInitialiser(), t3.returnType = e3.typeAnnotation ? this.finishNode(e3, "TypeAnnotation") : null;
            }
            super.parseFunctionBodyAndFinish(t3, e2, s2);
          }
          parseStatement(t3, e2) {
            if (this.state.strict && this.match(Mi.name) && "interface" === this.state.value) {
              const t4 = this.lookahead();
              if (t4.type === Mi.name || ma(t4.value)) {
                const t5 = this.startNode();
                return this.next(), this.flowParseInterface(t5);
              }
            } else if (this.shouldParseEnums() && this.isContextual("enum")) {
              const t4 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(t4);
            }
            const s2 = super.parseStatement(t3, e2);
            return void 0 !== this.flowPragma || this.isValidDirective(s2) || (this.flowPragma = null), s2;
          }
          parseExpressionStatement(t3, e2) {
            if ("Identifier" === e2.type) {
              if ("declare" === e2.name) {
                if (this.match(Mi._class) || this.match(Mi.name) || this.match(Mi._function) || this.match(Mi._var) || this.match(Mi._export))
                  return this.flowParseDeclare(t3);
              } else if (this.match(Mi.name)) {
                if ("interface" === e2.name)
                  return this.flowParseInterface(t3);
                if ("type" === e2.name)
                  return this.flowParseTypeAlias(t3);
                if ("opaque" === e2.name)
                  return this.flowParseOpaqueType(t3, false);
              }
            }
            return super.parseExpressionStatement(t3, e2);
          }
          shouldParseExportDeclaration() {
            return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            return (!this.match(Mi.name) || !("type" === this.state.value || "interface" === this.state.value || "opaque" === this.state.value || this.shouldParseEnums() && "enum" === this.state.value)) && super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual("enum")) {
              const t3 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(t3);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(t3, e2, s2, r2) {
            if (!this.match(Mi.question))
              return t3;
            if (r2) {
              const i3 = this.tryParse(() => super.parseConditional(t3, e2, s2));
              return i3.node ? (i3.error && (this.state = i3.failState), i3.node) : (r2.start = i3.error.pos || this.state.start, t3);
            }
            this.expect(Mi.question);
            const i2 = this.state.clone(), a2 = this.state.noArrowAt, n2 = this.startNodeAt(e2, s2);
            let {
              consequent: o2,
              failed: u2
            } = this.tryParseConditionalConsequent(), [h2, c2] = this.getArrowLikeExpressions(o2);
            if (u2 || c2.length > 0) {
              const t4 = [...a2];
              if (c2.length > 0) {
                this.state = i2, this.state.noArrowAt = t4;
                for (let e3 = 0; e3 < c2.length; e3++)
                  t4.push(c2[e3].start);
                ({
                  consequent: o2,
                  failed: u2
                } = this.tryParseConditionalConsequent()), [h2, c2] = this.getArrowLikeExpressions(o2);
              }
              u2 && h2.length > 1 && this.raise(i2.start, Ta.AmbiguousConditionalArrow), u2 && 1 === h2.length && (this.state = i2, this.state.noArrowAt = t4.concat(h2[0].start), {
                consequent: o2,
                failed: u2
              } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(o2, true), this.state.noArrowAt = a2, this.expect(Mi.colon), n2.test = t3, n2.consequent = o2, n2.alternate = this.forwardNoArrowParamsConversionAt(n2, () => this.parseMaybeAssign(void 0, void 0, void 0)), this.finishNode(n2, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const t3 = this.parseMaybeAssignAllowIn(), e2 = !this.match(Mi.colon);
            return this.state.noArrowParamsConversionAt.pop(), {
              consequent: t3,
              failed: e2
            };
          }
          getArrowLikeExpressions(t3, e2) {
            const s2 = [t3], r2 = [];
            for (; 0 !== s2.length; ) {
              const t4 = s2.pop();
              "ArrowFunctionExpression" === t4.type ? (t4.typeParameters || !t4.returnType ? this.finishArrowValidation(t4) : r2.push(t4), s2.push(t4.body)) : "ConditionalExpression" === t4.type && (s2.push(t4.consequent), s2.push(t4.alternate));
            }
            return e2 ? (r2.forEach((t4) => this.finishArrowValidation(t4)), [r2, []]) : function(t4, e3) {
              const s3 = [], r3 = [];
              for (let i2 = 0; i2 < t4.length; i2++)
                (e3(t4[i2], i2, t4) ? s3 : r3).push(t4[i2]);
              return [s3, r3];
            }(r2, (t4) => t4.params.every((t5) => this.isAssignable(t5, true)));
          }
          finishArrowValidation(t3) {
            var e2;
            this.toAssignableList(t3.params, null == (e2 = t3.extra) ? void 0 : e2.trailingComma, false), this.scope.enter(6), super.checkParams(t3, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(t3, e2) {
            let s2;
            return -1 !== this.state.noArrowParamsConversionAt.indexOf(t3.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), s2 = e2(), this.state.noArrowParamsConversionAt.pop()) : s2 = e2(), s2;
          }
          parseParenItem(t3, e2, s2) {
            if (t3 = super.parseParenItem(t3, e2, s2), this.eat(Mi.question) && (t3.optional = true, this.resetEndLocation(t3)), this.match(Mi.colon)) {
              const r2 = this.startNodeAt(e2, s2);
              return r2.expression = t3, r2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r2, "TypeCastExpression");
            }
            return t3;
          }
          assertModuleNodeAllowed(t3) {
            "ImportDeclaration" === t3.type && ("type" === t3.importKind || "typeof" === t3.importKind) || "ExportNamedDeclaration" === t3.type && "type" === t3.exportKind || "ExportAllDeclaration" === t3.type && "type" === t3.exportKind || super.assertModuleNodeAllowed(t3);
          }
          parseExport(t3) {
            const e2 = super.parseExport(t3);
            return "ExportNamedDeclaration" !== e2.type && "ExportAllDeclaration" !== e2.type || (e2.exportKind = e2.exportKind || "value"), e2;
          }
          parseExportDeclaration(t3) {
            if (this.isContextual("type")) {
              t3.exportKind = "type";
              const e2 = this.startNode();
              return this.next(), this.match(Mi.braceL) ? (t3.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(t3), null) : this.flowParseTypeAlias(e2);
            }
            if (this.isContextual("opaque")) {
              t3.exportKind = "type";
              const e2 = this.startNode();
              return this.next(), this.flowParseOpaqueType(e2, false);
            }
            if (this.isContextual("interface")) {
              t3.exportKind = "type";
              const e2 = this.startNode();
              return this.next(), this.flowParseInterface(e2);
            }
            if (this.shouldParseEnums() && this.isContextual("enum")) {
              t3.exportKind = "value";
              const e2 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(e2);
            }
            return super.parseExportDeclaration(t3);
          }
          eatExportStar(t3) {
            return !!super.eatExportStar(...arguments) || !(!this.isContextual("type") || this.lookahead().type !== Mi.star) && (t3.exportKind = "type", this.next(), this.next(), true);
          }
          maybeParseExportNamespaceSpecifier(t3) {
            const e2 = this.state.start, s2 = super.maybeParseExportNamespaceSpecifier(t3);
            return s2 && "type" === t3.exportKind && this.unexpected(e2), s2;
          }
          parseClassId(t3, e2, s2) {
            super.parseClassId(t3, e2, s2), this.isRelational("<") && (t3.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(t3, e2, s2) {
            const r2 = this.state.start;
            if (this.isContextual("declare")) {
              if (this.parseClassMemberFromModifier(t3, e2))
                return;
              e2.declare = true;
            }
            super.parseClassMember(t3, e2, s2), e2.declare && ("ClassProperty" !== e2.type && "ClassPrivateProperty" !== e2.type && "PropertyDefinition" !== e2.type ? this.raise(r2, Ta.DeclareClassElement) : e2.value && this.raise(e2.value.start, Ta.DeclareClassFieldInitializer));
          }
          getTokenFromCode(t3) {
            const e2 = this.input.charCodeAt(this.state.pos + 1);
            return 123 === t3 && 124 === e2 ? this.finishOp(Mi.braceBarL, 2) : !this.state.inType || 62 !== t3 && 60 !== t3 ? this.state.inType && 63 === t3 ? 46 === e2 ? this.finishOp(Mi.questionDot, 2) : this.finishOp(Mi.question, 1) : function(t4, e3) {
              return 64 === t4 && 64 === e3;
            }(t3, e2) ? (this.state.isIterator = true, super.readWord()) : super.getTokenFromCode(t3) : this.finishOp(Mi.relational, 1);
          }
          isAssignable(t3, e2) {
            switch (t3.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
                return true;
              case "ObjectExpression": {
                const e3 = t3.properties.length - 1;
                return t3.properties.every((t4, s2) => "ObjectMethod" !== t4.type && (s2 === e3 || "SpreadElement" === t4.type) && this.isAssignable(t4));
              }
              case "ObjectProperty":
                return this.isAssignable(t3.value);
              case "SpreadElement":
                return this.isAssignable(t3.argument);
              case "ArrayExpression":
                return t3.elements.every((t4) => this.isAssignable(t4));
              case "AssignmentExpression":
                return "=" === t3.operator;
              case "ParenthesizedExpression":
              case "TypeCastExpression":
                return this.isAssignable(t3.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !e2;
              default:
                return false;
            }
          }
          toAssignable(t3, e2 = false) {
            return "TypeCastExpression" === t3.type ? super.toAssignable(this.typeCastToParameter(t3), e2) : super.toAssignable(t3, e2);
          }
          toAssignableList(t3, e2, s2) {
            for (let e3 = 0; e3 < t3.length; e3++) {
              const s3 = t3[e3];
              "TypeCastExpression" === (null == s3 ? void 0 : s3.type) && (t3[e3] = this.typeCastToParameter(s3));
            }
            return super.toAssignableList(t3, e2, s2);
          }
          toReferencedList(t3, e2) {
            for (let r2 = 0; r2 < t3.length; r2++) {
              var s2;
              const i2 = t3[r2];
              !i2 || "TypeCastExpression" !== i2.type || null != (s2 = i2.extra) && s2.parenthesized || !(t3.length > 1) && e2 || this.raise(i2.typeAnnotation.start, Ta.TypeCastInPattern);
            }
            return t3;
          }
          parseArrayLike(t3, e2, s2, r2) {
            const i2 = super.parseArrayLike(t3, e2, s2, r2);
            return e2 && !this.state.maybeInArrowParameters && this.toReferencedList(i2.elements), i2;
          }
          checkLVal(t3, ...e2) {
            if ("TypeCastExpression" !== t3.type)
              return super.checkLVal(t3, ...e2);
          }
          parseClassProperty(t3) {
            return this.match(Mi.colon) && (t3.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(t3);
          }
          parseClassPrivateProperty(t3) {
            return this.match(Mi.colon) && (t3.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(t3);
          }
          isClassMethod() {
            return this.isRelational("<") || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(Mi.colon) || super.isClassProperty();
          }
          isNonstaticConstructor(t3) {
            return !this.match(Mi.colon) && super.isNonstaticConstructor(t3);
          }
          pushClassMethod(t3, e2, s2, r2, i2, a2) {
            if (e2.variance && this.unexpected(e2.variance.start), delete e2.variance, this.isRelational("<") && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(t3, e2, s2, r2, i2, a2), e2.params && i2) {
              const t4 = e2.params;
              t4.length > 0 && this.isThisParam(t4[0]) && this.raise(e2.start, Ta.ThisParamBannedInConstructor);
            } else if ("MethodDefinition" === e2.type && i2 && e2.value.params) {
              const t4 = e2.value.params;
              t4.length > 0 && this.isThisParam(t4[0]) && this.raise(e2.start, Ta.ThisParamBannedInConstructor);
            }
          }
          pushClassPrivateMethod(t3, e2, s2, r2) {
            e2.variance && this.unexpected(e2.variance.start), delete e2.variance, this.isRelational("<") && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(t3, e2, s2, r2);
          }
          parseClassSuper(t3) {
            if (super.parseClassSuper(t3), t3.superClass && this.isRelational("<") && (t3.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual("implements")) {
              this.next();
              const e2 = t3.implements = [];
              do {
                const t4 = this.startNode();
                t4.id = this.flowParseRestrictedIdentifier(true), this.isRelational("<") ? t4.typeParameters = this.flowParseTypeParameterInstantiation() : t4.typeParameters = null, e2.push(this.finishNode(t4, "ClassImplements"));
              } while (this.eat(Mi.comma));
            }
          }
          checkGetterSetterParams(t3) {
            super.checkGetterSetterParams(t3);
            const e2 = this.getObjectOrClassMethodParams(t3);
            if (e2.length > 0) {
              const s2 = e2[0];
              this.isThisParam(s2) && "get" === t3.kind ? this.raise(s2.start, Ta.GetterMayNotHaveThisParam) : this.isThisParam(s2) && this.raise(s2.start, Ta.SetterMayNotHaveThisParam);
            }
          }
          parsePropertyName(t3, e2) {
            const s2 = this.flowParseVariance(), r2 = super.parsePropertyName(t3, e2);
            return t3.variance = s2, r2;
          }
          parseObjPropValue(t3, e2, s2, r2, i2, a2, n2, o2) {
            let u2;
            t3.variance && this.unexpected(t3.variance.start), delete t3.variance, this.isRelational("<") && !n2 && (u2 = this.flowParseTypeParameterDeclaration(), this.match(Mi.parenL) || this.unexpected()), super.parseObjPropValue(t3, e2, s2, r2, i2, a2, n2, o2), u2 && ((t3.value || t3).typeParameters = u2);
          }
          parseAssignableListItemTypes(t3) {
            return this.eat(Mi.question) && ("Identifier" !== t3.type && this.raise(t3.start, Ta.OptionalBindingPattern), this.isThisParam(t3) && this.raise(t3.start, Ta.ThisParamMayNotBeOptional), t3.optional = true), this.match(Mi.colon) ? t3.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(t3) && this.raise(t3.start, Ta.ThisParamAnnotationRequired), this.match(Mi.eq) && this.isThisParam(t3) && this.raise(t3.start, Ta.ThisParamNoDefault), this.resetEndLocation(t3), t3;
          }
          parseMaybeDefault(t3, e2, s2) {
            const r2 = super.parseMaybeDefault(t3, e2, s2);
            return "AssignmentPattern" === r2.type && r2.typeAnnotation && r2.right.start < r2.typeAnnotation.start && this.raise(r2.typeAnnotation.start, Ta.TypeBeforeInitializer), r2;
          }
          shouldParseDefaultImport(t3) {
            return wa(t3) ? Ba(this.state) : super.shouldParseDefaultImport(t3);
          }
          parseImportSpecifierLocal(t3, e2, s2, r2) {
            e2.local = wa(t3) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), this.checkLVal(e2.local, r2, 9), t3.specifiers.push(this.finishNode(e2, s2));
          }
          maybeParseDefaultImportSpecifier(t3) {
            t3.importKind = "value";
            let e2 = null;
            if (this.match(Mi._typeof) ? e2 = "typeof" : this.isContextual("type") && (e2 = "type"), e2) {
              const s2 = this.lookahead();
              "type" === e2 && s2.type === Mi.star && this.unexpected(s2.start), (Ba(s2) || s2.type === Mi.braceL || s2.type === Mi.star) && (this.next(), t3.importKind = e2);
            }
            return super.maybeParseDefaultImportSpecifier(t3);
          }
          parseImportSpecifier(t3) {
            const e2 = this.startNode(), s2 = this.state.start, r2 = this.parseModuleExportName();
            let i2 = null;
            "Identifier" === r2.type && ("type" === r2.name ? i2 = "type" : "typeof" === r2.name && (i2 = "typeof"));
            let a2 = false;
            if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
              const t4 = this.parseIdentifier(true);
              null === i2 || this.match(Mi.name) || this.state.type.keyword ? (e2.imported = r2, e2.importKind = null, e2.local = this.parseIdentifier()) : (e2.imported = t4, e2.importKind = i2, e2.local = t4.__clone());
            } else if (null !== i2 && (this.match(Mi.name) || this.state.type.keyword))
              e2.imported = this.parseIdentifier(true), e2.importKind = i2, this.eatContextual("as") ? e2.local = this.parseIdentifier() : (a2 = true, e2.local = e2.imported.__clone());
            else {
              if ("StringLiteral" === r2.type)
                throw this.raise(e2.start, Gi.ImportBindingIsString, r2.value);
              a2 = true, e2.imported = r2, e2.importKind = null, e2.local = e2.imported.__clone();
            }
            const n2 = wa(t3), o2 = wa(e2);
            n2 && o2 && this.raise(s2, Ta.ImportTypeShorthandOnlyInPureImport), (n2 || o2) && this.checkReservedType(e2.local.name, e2.local.start, true), !a2 || n2 || o2 || this.checkReservedWord(e2.local.name, e2.start, true, true), this.checkLVal(e2.local, "import specifier", 9), t3.specifiers.push(this.finishNode(e2, "ImportSpecifier"));
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case Mi._this:
                return this.parseIdentifier(true);
              default:
                return super.parseBindingAtom();
            }
          }
          parseFunctionParams(t3, e2) {
            const s2 = t3.kind;
            "get" !== s2 && "set" !== s2 && this.isRelational("<") && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(t3, e2);
          }
          parseVarId(t3, e2) {
            super.parseVarId(t3, e2), this.match(Mi.colon) && (t3.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t3.id));
          }
          parseAsyncArrowFromCallExpression(t3, e2) {
            if (this.match(Mi.colon)) {
              const e3 = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, t3.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = e3;
            }
            return super.parseAsyncArrowFromCallExpression(t3, e2);
          }
          shouldParseAsyncArrow() {
            return this.match(Mi.colon) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(t3, e2, s2) {
            var r2;
            let i2, a2 = null;
            if (this.hasPlugin("jsx") && (this.match(Mi.jsxTagStart) || this.isRelational("<"))) {
              if (a2 = this.state.clone(), i2 = this.tryParse(() => super.parseMaybeAssign(t3, e2, s2), a2), !i2.error)
                return i2.node;
              const {
                context: r3
              } = this.state;
              r3[r3.length - 1] === $i.j_oTag ? r3.length -= 2 : r3[r3.length - 1] === $i.j_expr && (r3.length -= 1);
            }
            if (null != (r2 = i2) && r2.error || this.isRelational("<")) {
              var n2, o2;
              let r3;
              a2 = a2 || this.state.clone();
              const u2 = this.tryParse((i3) => {
                var a3;
                r3 = this.flowParseTypeParameterDeclaration();
                const n3 = this.forwardNoArrowParamsConversionAt(r3, () => {
                  const i4 = super.parseMaybeAssign(t3, e2, s2);
                  return this.resetStartLocationFromNode(i4, r3), i4;
                });
                "ArrowFunctionExpression" !== n3.type && null != (a3 = n3.extra) && a3.parenthesized && i3();
                const o3 = this.maybeUnwrapTypeCastExpression(n3);
                return o3.typeParameters = r3, this.resetStartLocationFromNode(o3, r3), n3;
              }, a2);
              let h2 = null;
              if (u2.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(u2.node).type) {
                if (!u2.error && !u2.aborted)
                  return u2.node.async && this.raise(r3.start, Ta.UnexpectedTypeParameterBeforeAsyncArrowFunction), u2.node;
                h2 = u2.node;
              }
              if (null != (n2 = i2) && n2.node)
                return this.state = i2.failState, i2.node;
              if (h2)
                return this.state = u2.failState, h2;
              if (null != (o2 = i2) && o2.thrown)
                throw i2.error;
              if (u2.thrown)
                throw u2.error;
              throw this.raise(r3.start, Ta.UnexpectedTokenAfterTypeParameter);
            }
            return super.parseMaybeAssign(t3, e2, s2);
          }
          parseArrow(t3) {
            if (this.match(Mi.colon)) {
              const e2 = this.tryParse(() => {
                const e3 = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                const s2 = this.startNode();
                return [s2.typeAnnotation, t3.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = e3, this.canInsertSemicolon() && this.unexpected(), this.match(Mi.arrow) || this.unexpected(), s2;
              });
              if (e2.thrown)
                return null;
              e2.error && (this.state = e2.failState), t3.returnType = e2.node.typeAnnotation ? this.finishNode(e2.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(t3);
          }
          shouldParseArrow() {
            return this.match(Mi.colon) || super.shouldParseArrow();
          }
          setArrowFunctionParameters(t3, e2) {
            -1 !== this.state.noArrowParamsConversionAt.indexOf(t3.start) ? t3.params = e2 : super.setArrowFunctionParameters(t3, e2);
          }
          checkParams(t3, e2, s2) {
            if (!s2 || -1 === this.state.noArrowParamsConversionAt.indexOf(t3.start)) {
              for (let e3 = 0; e3 < t3.params.length; e3++)
                this.isThisParam(t3.params[e3]) && e3 > 0 && this.raise(t3.params[e3].start, Ta.ThisParamMustBeFirst);
              return super.checkParams(...arguments);
            }
          }
          parseParenAndDistinguishExpression(t3) {
            return super.parseParenAndDistinguishExpression(t3 && -1 === this.state.noArrowAt.indexOf(this.state.start));
          }
          parseSubscripts(t3, e2, s2, r2) {
            if ("Identifier" === t3.type && "async" === t3.name && -1 !== this.state.noArrowAt.indexOf(e2)) {
              this.next();
              const r3 = this.startNodeAt(e2, s2);
              r3.callee = t3, r3.arguments = this.parseCallExpressionArguments(Mi.parenR, false), t3 = this.finishNode(r3, "CallExpression");
            } else if ("Identifier" === t3.type && "async" === t3.name && this.isRelational("<")) {
              const i2 = this.state.clone(), a2 = this.tryParse((t4) => this.parseAsyncArrowWithTypeParameters(e2, s2) || t4(), i2);
              if (!a2.error && !a2.aborted)
                return a2.node;
              const n2 = this.tryParse(() => super.parseSubscripts(t3, e2, s2, r2), i2);
              if (n2.node && !n2.error)
                return n2.node;
              if (a2.node)
                return this.state = a2.failState, a2.node;
              if (n2.node)
                return this.state = n2.failState, n2.node;
              throw a2.error || n2.error;
            }
            return super.parseSubscripts(t3, e2, s2, r2);
          }
          parseSubscript(t3, e2, s2, r2, i2) {
            if (this.match(Mi.questionDot) && this.isLookaheadToken_lt()) {
              if (i2.optionalChainMember = true, r2)
                return i2.stop = true, t3;
              this.next();
              const a2 = this.startNodeAt(e2, s2);
              return a2.callee = t3, a2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(Mi.parenL), a2.arguments = this.parseCallExpressionArguments(Mi.parenR, false), a2.optional = true, this.finishCallExpression(a2, true);
            }
            if (!r2 && this.shouldParseTypes() && this.isRelational("<")) {
              const r3 = this.startNodeAt(e2, s2);
              r3.callee = t3;
              const a2 = this.tryParse(() => (r3.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(Mi.parenL), r3.arguments = this.parseCallExpressionArguments(Mi.parenR, false), i2.optionalChainMember && (r3.optional = false), this.finishCallExpression(r3, i2.optionalChainMember)));
              if (a2.node)
                return a2.error && (this.state = a2.failState), a2.node;
            }
            return super.parseSubscript(t3, e2, s2, r2, i2);
          }
          parseNewArguments(t3) {
            let e2 = null;
            this.shouldParseTypes() && this.isRelational("<") && (e2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), t3.typeArguments = e2, super.parseNewArguments(t3);
          }
          parseAsyncArrowWithTypeParameters(t3, e2) {
            const s2 = this.startNodeAt(t3, e2);
            if (this.parseFunctionParams(s2), this.parseArrow(s2))
              return this.parseArrowExpression(s2, void 0, true);
          }
          readToken_mult_modulo(t3) {
            const e2 = this.input.charCodeAt(this.state.pos + 1);
            if (42 === t3 && 47 === e2 && this.state.hasFlowComment)
              return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
            super.readToken_mult_modulo(t3);
          }
          readToken_pipe_amp(t3) {
            const e2 = this.input.charCodeAt(this.state.pos + 1);
            124 !== t3 || 125 !== e2 ? super.readToken_pipe_amp(t3) : this.finishOp(Mi.braceBarR, 2);
          }
          parseTopLevel(t3, e2) {
            const s2 = super.parseTopLevel(t3, e2);
            return this.state.hasFlowComment && this.raise(this.state.pos, Ta.UnterminatedFlowComment), s2;
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment())
              return this.state.hasFlowComment && this.unexpected(null, Ta.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = true);
            if (this.state.hasFlowComment) {
              const t3 = this.input.indexOf("*-/", this.state.pos += 2);
              if (-1 === t3)
                throw this.raise(this.state.pos - 2, Gi.UnterminatedComment);
              this.state.pos = t3 + 3;
            } else
              super.skipBlockComment();
          }
          skipFlowComment() {
            const {
              pos: t3
            } = this.state;
            let e2 = 2;
            for (; [32, 9].includes(this.input.charCodeAt(t3 + e2)); )
              e2++;
            const s2 = this.input.charCodeAt(e2 + t3), r2 = this.input.charCodeAt(e2 + t3 + 1);
            return 58 === s2 && 58 === r2 ? e2 + 2 : "flow-include" === this.input.slice(e2 + t3, e2 + t3 + 12) ? e2 + 12 : 58 === s2 && 58 !== r2 && e2;
          }
          hasFlowCommentCompletion() {
            if (-1 === this.input.indexOf("*/", this.state.pos))
              throw this.raise(this.state.pos, Gi.UnterminatedComment);
          }
          flowEnumErrorBooleanMemberNotInitialized(t3, {
            enumName: e2,
            memberName: s2
          }) {
            this.raise(t3, Ta.EnumBooleanMemberNotInitialized, s2, e2);
          }
          flowEnumErrorInvalidMemberName(t3, {
            enumName: e2,
            memberName: s2
          }) {
            const r2 = s2[0].toUpperCase() + s2.slice(1);
            this.raise(t3, Ta.EnumInvalidMemberName, s2, r2, e2);
          }
          flowEnumErrorDuplicateMemberName(t3, {
            enumName: e2,
            memberName: s2
          }) {
            this.raise(t3, Ta.EnumDuplicateMemberName, s2, e2);
          }
          flowEnumErrorInconsistentMemberValues(t3, {
            enumName: e2
          }) {
            this.raise(t3, Ta.EnumInconsistentMemberValues, e2);
          }
          flowEnumErrorInvalidExplicitType(t3, {
            enumName: e2,
            suppliedType: s2
          }) {
            return this.raise(t3, null === s2 ? Ta.EnumInvalidExplicitTypeUnknownSupplied : Ta.EnumInvalidExplicitType, e2, s2);
          }
          flowEnumErrorInvalidMemberInitializer(t3, {
            enumName: e2,
            explicitType: s2,
            memberName: r2
          }) {
            let i2 = null;
            switch (s2) {
              case "boolean":
              case "number":
              case "string":
                i2 = Ta.EnumInvalidMemberInitializerPrimaryType;
                break;
              case "symbol":
                i2 = Ta.EnumInvalidMemberInitializerSymbolType;
                break;
              default:
                i2 = Ta.EnumInvalidMemberInitializerUnknownType;
            }
            return this.raise(t3, i2, e2, r2, s2);
          }
          flowEnumErrorNumberMemberNotInitialized(t3, {
            enumName: e2,
            memberName: s2
          }) {
            this.raise(t3, Ta.EnumNumberMemberNotInitialized, e2, s2);
          }
          flowEnumErrorStringMemberInconsistentlyInitailized(t3, {
            enumName: e2
          }) {
            this.raise(t3, Ta.EnumStringMemberInconsistentlyInitailized, e2);
          }
          flowEnumMemberInit() {
            const t3 = this.state.start, e2 = () => this.match(Mi.comma) || this.match(Mi.braceR);
            switch (this.state.type) {
              case Mi.num: {
                const s2 = this.parseLiteral(this.state.value, "NumericLiteral");
                return e2() ? {
                  type: "number",
                  pos: s2.start,
                  value: s2
                } : {
                  type: "invalid",
                  pos: t3
                };
              }
              case Mi.string: {
                const s2 = this.parseLiteral(this.state.value, "StringLiteral");
                return e2() ? {
                  type: "string",
                  pos: s2.start,
                  value: s2
                } : {
                  type: "invalid",
                  pos: t3
                };
              }
              case Mi._true:
              case Mi._false: {
                const s2 = this.parseBooleanLiteral();
                return e2() ? {
                  type: "boolean",
                  pos: s2.start,
                  value: s2
                } : {
                  type: "invalid",
                  pos: t3
                };
              }
              default:
                return {
                  type: "invalid",
                  pos: t3
                };
            }
          }
          flowEnumMemberRaw() {
            const t3 = this.state.start;
            return {
              id: this.parseIdentifier(true),
              init: this.eat(Mi.eq) ? this.flowEnumMemberInit() : {
                type: "none",
                pos: t3
              }
            };
          }
          flowEnumCheckExplicitTypeMismatch(t3, e2, s2) {
            const {
              explicitType: r2
            } = e2;
            null !== r2 && r2 !== s2 && this.flowEnumErrorInvalidMemberInitializer(t3, e2);
          }
          flowEnumMembers({
            enumName: t3,
            explicitType: e2
          }) {
            const s2 = /* @__PURE__ */ new Set(), r2 = {
              booleanMembers: [],
              numberMembers: [],
              stringMembers: [],
              defaultedMembers: []
            };
            let i2 = false;
            for (; !this.match(Mi.braceR); ) {
              if (this.eat(Mi.ellipsis)) {
                i2 = true;
                break;
              }
              const a2 = this.startNode(), {
                id: n2,
                init: o2
              } = this.flowEnumMemberRaw(), u2 = n2.name;
              if ("" === u2)
                continue;
              /^[a-z]/.test(u2) && this.flowEnumErrorInvalidMemberName(n2.start, {
                enumName: t3,
                memberName: u2
              }), s2.has(u2) && this.flowEnumErrorDuplicateMemberName(n2.start, {
                enumName: t3,
                memberName: u2
              }), s2.add(u2);
              const h2 = {
                enumName: t3,
                explicitType: e2,
                memberName: u2
              };
              switch (a2.id = n2, o2.type) {
                case "boolean":
                  this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "boolean"), a2.init = o2.value, r2.booleanMembers.push(this.finishNode(a2, "EnumBooleanMember"));
                  break;
                case "number":
                  this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "number"), a2.init = o2.value, r2.numberMembers.push(this.finishNode(a2, "EnumNumberMember"));
                  break;
                case "string":
                  this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "string"), a2.init = o2.value, r2.stringMembers.push(this.finishNode(a2, "EnumStringMember"));
                  break;
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(o2.pos, h2);
                case "none":
                  switch (e2) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(o2.pos, h2);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(o2.pos, h2);
                      break;
                    default:
                      r2.defaultedMembers.push(this.finishNode(a2, "EnumDefaultedMember"));
                  }
              }
              this.match(Mi.braceR) || this.expect(Mi.comma);
            }
            return {
              members: r2,
              hasUnknownMembers: i2
            };
          }
          flowEnumStringMembers(t3, e2, {
            enumName: s2
          }) {
            if (0 === t3.length)
              return e2;
            if (0 === e2.length)
              return t3;
            if (e2.length > t3.length) {
              for (const e3 of t3)
                this.flowEnumErrorStringMemberInconsistentlyInitailized(e3.start, {
                  enumName: s2
                });
              return e2;
            }
            for (const t4 of e2)
              this.flowEnumErrorStringMemberInconsistentlyInitailized(t4.start, {
                enumName: s2
              });
            return t3;
          }
          flowEnumParseExplicitType({
            enumName: t3
          }) {
            if (this.eatContextual("of")) {
              if (!this.match(Mi.name))
                throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
                  enumName: t3,
                  suppliedType: null
                });
              const {
                value: e2
              } = this.state;
              return this.next(), "boolean" !== e2 && "number" !== e2 && "string" !== e2 && "symbol" !== e2 && this.flowEnumErrorInvalidExplicitType(this.state.start, {
                enumName: t3,
                suppliedType: e2
              }), e2;
            }
            return null;
          }
          flowEnumBody(t3, {
            enumName: e2,
            nameLoc: s2
          }) {
            const r2 = this.flowEnumParseExplicitType({
              enumName: e2
            });
            this.expect(Mi.braceL);
            const {
              members: i2,
              hasUnknownMembers: a2
            } = this.flowEnumMembers({
              enumName: e2,
              explicitType: r2
            });
            switch (t3.hasUnknownMembers = a2, r2) {
              case "boolean":
                return t3.explicitType = true, t3.members = i2.booleanMembers, this.expect(Mi.braceR), this.finishNode(t3, "EnumBooleanBody");
              case "number":
                return t3.explicitType = true, t3.members = i2.numberMembers, this.expect(Mi.braceR), this.finishNode(t3, "EnumNumberBody");
              case "string":
                return t3.explicitType = true, t3.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, {
                  enumName: e2
                }), this.expect(Mi.braceR), this.finishNode(t3, "EnumStringBody");
              case "symbol":
                return t3.members = i2.defaultedMembers, this.expect(Mi.braceR), this.finishNode(t3, "EnumSymbolBody");
              default: {
                const r3 = () => (t3.members = [], this.expect(Mi.braceR), this.finishNode(t3, "EnumStringBody"));
                t3.explicitType = false;
                const a3 = i2.booleanMembers.length, n2 = i2.numberMembers.length, o2 = i2.stringMembers.length, u2 = i2.defaultedMembers.length;
                if (a3 || n2 || o2 || u2) {
                  if (a3 || n2) {
                    if (!n2 && !o2 && a3 >= u2) {
                      for (const t4 of i2.defaultedMembers)
                        this.flowEnumErrorBooleanMemberNotInitialized(t4.start, {
                          enumName: e2,
                          memberName: t4.id.name
                        });
                      return t3.members = i2.booleanMembers, this.expect(Mi.braceR), this.finishNode(t3, "EnumBooleanBody");
                    }
                    if (!a3 && !o2 && n2 >= u2) {
                      for (const t4 of i2.defaultedMembers)
                        this.flowEnumErrorNumberMemberNotInitialized(t4.start, {
                          enumName: e2,
                          memberName: t4.id.name
                        });
                      return t3.members = i2.numberMembers, this.expect(Mi.braceR), this.finishNode(t3, "EnumNumberBody");
                    }
                    return this.flowEnumErrorInconsistentMemberValues(s2, {
                      enumName: e2
                    }), r3();
                  }
                  return t3.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, {
                    enumName: e2
                  }), this.expect(Mi.braceR), this.finishNode(t3, "EnumStringBody");
                }
                return r3();
              }
            }
          }
          flowParseEnumDeclaration(t3) {
            const e2 = this.parseIdentifier();
            return t3.id = e2, t3.body = this.flowEnumBody(this.startNode(), {
              enumName: e2.name,
              nameLoc: e2.start
            }), this.finishNode(t3, "EnumDeclaration");
          }
          updateContext(t3) {
            this.match(Mi.name) && "of" === this.state.value && t3 === Mi.name && "interface" === this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) ? this.state.exprAllowed = false : super.updateContext(t3);
          }
          isLookaheadToken_lt() {
            const t3 = this.nextTokenStart();
            if (60 === this.input.charCodeAt(t3)) {
              const e2 = this.input.charCodeAt(t3 + 1);
              return 60 !== e2 && 61 !== e2;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(t3) {
            return "TypeCastExpression" === t3.type ? t3.expression : t3;
          }
        },
        typescript: (t2) => class extends t2 {
          getScopeHandler() {
            return ja;
          }
          tsIsIdentifier() {
            return this.match(Mi.name);
          }
          tsTokenCanFollowModifier() {
            return (this.match(Mi.bracketL) || this.match(Mi.braceL) || this.match(Mi.star) || this.match(Mi.ellipsis) || this.match(Mi.hash) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(t3) {
            if (!this.match(Mi.name))
              return;
            const e2 = this.state.value;
            return -1 !== t3.indexOf(e2) && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)) ? e2 : void 0;
          }
          tsParseModifiers(t3, e2, s2, r2) {
            const i2 = (e3, s3, r3, i3) => {
              s3 === r3 && t3[i3] && this.raise(e3, Ha.InvalidModifiersOrder, r3, i3);
            }, a2 = (e3, s3, r3, i3) => {
              (t3[r3] && s3 === i3 || t3[i3] && s3 === r3) && this.raise(e3, Ha.IncompatibleModifiers, r3, i3);
            };
            for (; ; ) {
              const n2 = this.state.start, o2 = this.tsParseModifier(e2.concat(null != s2 ? s2 : []));
              if (!o2)
                break;
              za(o2) ? t3.accessibility ? this.raise(n2, Ha.DuplicateAccessibilityModifier) : (i2(n2, o2, o2, "override"), i2(n2, o2, o2, "static"), t3.accessibility = o2) : (Object.hasOwnProperty.call(t3, o2) ? this.raise(n2, Ha.DuplicateModifier, o2) : (i2(n2, o2, "static", "readonly"), i2(n2, o2, "static", "override"), i2(n2, o2, "override", "readonly"), i2(n2, o2, "abstract", "override"), a2(n2, o2, "declare", "override"), a2(n2, o2, "static", "abstract")), t3[o2] = true), null != s2 && s2.includes(o2) && this.raise(n2, r2, o2);
            }
          }
          tsIsListTerminator(t3) {
            switch (t3) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(Mi.braceR);
              case "HeritageClauseElement":
                return this.match(Mi.braceL);
              case "TupleElementTypes":
                return this.match(Mi.bracketR);
              case "TypeParametersOrArguments":
                return this.isRelational(">");
            }
            throw new Error("Unreachable");
          }
          tsParseList(t3, e2) {
            const s2 = [];
            for (; !this.tsIsListTerminator(t3); )
              s2.push(e2());
            return s2;
          }
          tsParseDelimitedList(t3, e2) {
            return qa(this.tsParseDelimitedListWorker(t3, e2, true));
          }
          tsParseDelimitedListWorker(t3, e2, s2) {
            const r2 = [];
            for (; !this.tsIsListTerminator(t3); ) {
              const i2 = e2();
              if (null == i2)
                return;
              if (r2.push(i2), !this.eat(Mi.comma)) {
                if (this.tsIsListTerminator(t3))
                  break;
                return void (s2 && this.expect(Mi.comma));
              }
            }
            return r2;
          }
          tsParseBracketedList(t3, e2, s2, r2) {
            r2 || (s2 ? this.expect(Mi.bracketL) : this.expectRelational("<"));
            const i2 = this.tsParseDelimitedList(t3, e2);
            return s2 ? this.expect(Mi.bracketR) : this.expectRelational(">"), i2;
          }
          tsParseImportType() {
            const t3 = this.startNode();
            return this.expect(Mi._import), this.expect(Mi.parenL), this.match(Mi.string) || this.raise(this.state.start, Ha.UnsupportedImportTypeArgument), t3.argument = this.parseExprAtom(), this.expect(Mi.parenR), this.eat(Mi.dot) && (t3.qualifier = this.tsParseEntityName(true)), this.isRelational("<") && (t3.typeParameters = this.tsParseTypeArguments()), this.finishNode(t3, "TSImportType");
          }
          tsParseEntityName(t3) {
            let e2 = this.parseIdentifier();
            for (; this.eat(Mi.dot); ) {
              const s2 = this.startNodeAtNode(e2);
              s2.left = e2, s2.right = this.parseIdentifier(t3), e2 = this.finishNode(s2, "TSQualifiedName");
            }
            return e2;
          }
          tsParseTypeReference() {
            const t3 = this.startNode();
            return t3.typeName = this.tsParseEntityName(false), !this.hasPrecedingLineBreak() && this.isRelational("<") && (t3.typeParameters = this.tsParseTypeArguments()), this.finishNode(t3, "TSTypeReference");
          }
          tsParseThisTypePredicate(t3) {
            this.next();
            const e2 = this.startNodeAtNode(t3);
            return e2.parameterName = t3, e2.typeAnnotation = this.tsParseTypeAnnotation(false), e2.asserts = false, this.finishNode(e2, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const t3 = this.startNode();
            return this.next(), this.finishNode(t3, "TSThisType");
          }
          tsParseTypeQuery() {
            const t3 = this.startNode();
            return this.expect(Mi._typeof), this.match(Mi._import) ? t3.exprName = this.tsParseImportType() : t3.exprName = this.tsParseEntityName(true), this.finishNode(t3, "TSTypeQuery");
          }
          tsParseTypeParameter() {
            const t3 = this.startNode();
            return t3.name = this.parseIdentifierName(t3.start), t3.constraint = this.tsEatThenParseType(Mi._extends), t3.default = this.tsEatThenParseType(Mi.eq), this.finishNode(t3, "TSTypeParameter");
          }
          tsTryParseTypeParameters() {
            if (this.isRelational("<"))
              return this.tsParseTypeParameters();
          }
          tsParseTypeParameters() {
            const t3 = this.startNode();
            return this.isRelational("<") || this.match(Mi.jsxTagStart) ? this.next() : this.unexpected(), t3.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true), 0 === t3.params.length && this.raise(t3.start, Ha.EmptyTypeParameters), this.finishNode(t3, "TSTypeParameterDeclaration");
          }
          tsTryNextParseConstantContext() {
            return this.lookahead().type === Mi._const ? (this.next(), this.tsParseTypeReference()) : null;
          }
          tsFillSignature(t3, e2) {
            const s2 = t3 === Mi.arrow;
            e2.typeParameters = this.tsTryParseTypeParameters(), this.expect(Mi.parenL), e2.parameters = this.tsParseBindingListForSignature(), (s2 || this.match(t3)) && (e2.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t3));
          }
          tsParseBindingListForSignature() {
            return this.parseBindingList(Mi.parenR, 41).map((t3) => ("Identifier" !== t3.type && "RestElement" !== t3.type && "ObjectPattern" !== t3.type && "ArrayPattern" !== t3.type && this.raise(t3.start, Ha.UnsupportedSignatureParameterKind, t3.type), t3));
          }
          tsParseTypeMemberSemicolon() {
            this.eat(Mi.comma) || this.isLineTerminator() || this.expect(Mi.semi);
          }
          tsParseSignatureMember(t3, e2) {
            return this.tsFillSignature(Mi.colon, e2), this.tsParseTypeMemberSemicolon(), this.finishNode(e2, t3);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), this.eat(Mi.name) && this.match(Mi.colon);
          }
          tsTryParseIndexSignature(t3) {
            if (!this.match(Mi.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
              return;
            this.expect(Mi.bracketL);
            const e2 = this.parseIdentifier();
            e2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(e2), this.expect(Mi.bracketR), t3.parameters = [e2];
            const s2 = this.tsTryParseTypeAnnotation();
            return s2 && (t3.typeAnnotation = s2), this.tsParseTypeMemberSemicolon(), this.finishNode(t3, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(t3, e2) {
            this.eat(Mi.question) && (t3.optional = true);
            const s2 = t3;
            if (this.match(Mi.parenL) || this.isRelational("<")) {
              e2 && this.raise(t3.start, Ha.ReadonlyForMethodSignature);
              const r2 = s2;
              if (r2.kind && this.isRelational("<") && this.raise(this.state.pos, Ha.AccesorCannotHaveTypeParameters), this.tsFillSignature(Mi.colon, r2), this.tsParseTypeMemberSemicolon(), "get" === r2.kind)
                r2.parameters.length > 0 && (this.raise(this.state.pos, Gi.BadGetterArity), this.isThisParam(r2.parameters[0]) && this.raise(this.state.pos, Ha.AccesorCannotDeclareThisParameter));
              else if ("set" === r2.kind) {
                if (1 !== r2.parameters.length)
                  this.raise(this.state.pos, Gi.BadSetterArity);
                else {
                  const t4 = r2.parameters[0];
                  this.isThisParam(t4) && this.raise(this.state.pos, Ha.AccesorCannotDeclareThisParameter), "Identifier" === t4.type && t4.optional && this.raise(this.state.pos, Ha.SetAccesorCannotHaveOptionalParameter), "RestElement" === t4.type && this.raise(this.state.pos, Ha.SetAccesorCannotHaveRestParameter);
                }
                r2.typeAnnotation && this.raise(r2.typeAnnotation.start, Ha.SetAccesorCannotHaveReturnType);
              } else
                r2.kind = "method";
              return this.finishNode(r2, "TSMethodSignature");
            }
            {
              const t4 = s2;
              e2 && (t4.readonly = true);
              const r2 = this.tsTryParseTypeAnnotation();
              return r2 && (t4.typeAnnotation = r2), this.tsParseTypeMemberSemicolon(), this.finishNode(t4, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            const t3 = this.startNode();
            if (this.match(Mi.parenL) || this.isRelational("<"))
              return this.tsParseSignatureMember("TSCallSignatureDeclaration", t3);
            if (this.match(Mi._new)) {
              const e3 = this.startNode();
              return this.next(), this.match(Mi.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", t3) : (t3.key = this.createIdentifier(e3, "new"), this.tsParsePropertyOrMethodSignature(t3, false));
            }
            this.tsParseModifiers(t3, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], Ha.InvalidModifierOnTypeMember);
            const e2 = this.tsTryParseIndexSignature(t3);
            return e2 || (this.parsePropertyName(t3, false), t3.computed || "Identifier" !== t3.key.type || "get" !== t3.key.name && "set" !== t3.key.name || !this.tsTokenCanFollowModifier() || (t3.kind = t3.key.name, this.parsePropertyName(t3, false)), this.tsParsePropertyOrMethodSignature(t3, !!t3.readonly));
          }
          tsParseTypeLiteral() {
            const t3 = this.startNode();
            return t3.members = this.tsParseObjectTypeMembers(), this.finishNode(t3, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(Mi.braceL);
            const t3 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(Mi.braceR), t3;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(Mi.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), !!this.match(Mi.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(Mi._in))));
          }
          tsParseMappedTypeParameter() {
            const t3 = this.startNode();
            return t3.name = this.parseIdentifierName(t3.start), t3.constraint = this.tsExpectThenParseType(Mi._in), this.finishNode(t3, "TSTypeParameter");
          }
          tsParseMappedType() {
            const t3 = this.startNode();
            return this.expect(Mi.braceL), this.match(Mi.plusMin) ? (t3.readonly = this.state.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (t3.readonly = true), this.expect(Mi.bracketL), t3.typeParameter = this.tsParseMappedTypeParameter(), t3.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(Mi.bracketR), this.match(Mi.plusMin) ? (t3.optional = this.state.value, this.next(), this.expect(Mi.question)) : this.eat(Mi.question) && (t3.optional = true), t3.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(Mi.braceR), this.finishNode(t3, "TSMappedType");
          }
          tsParseTupleType() {
            const t3 = this.startNode();
            t3.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let e2 = false, s2 = null;
            return t3.elementTypes.forEach((t4) => {
              var r2;
              let {
                type: i2
              } = t4;
              !e2 || "TSRestType" === i2 || "TSOptionalType" === i2 || "TSNamedTupleMember" === i2 && t4.optional || this.raise(t4.start, Ha.OptionalTypeBeforeRequired), e2 = e2 || "TSNamedTupleMember" === i2 && t4.optional || "TSOptionalType" === i2, "TSRestType" === i2 && (i2 = (t4 = t4.typeAnnotation).type);
              const a2 = "TSNamedTupleMember" === i2;
              s2 = null != (r2 = s2) ? r2 : a2, s2 !== a2 && this.raise(t4.start, Ha.MixedLabeledAndUnlabeledElements);
            }), this.finishNode(t3, "TSTupleType");
          }
          tsParseTupleElementType() {
            const {
              start: t3,
              startLoc: e2
            } = this.state, s2 = this.eat(Mi.ellipsis);
            let r2 = this.tsParseType();
            const i2 = this.eat(Mi.question);
            if (this.eat(Mi.colon)) {
              const t4 = this.startNodeAtNode(r2);
              t4.optional = i2, "TSTypeReference" !== r2.type || r2.typeParameters || "Identifier" !== r2.typeName.type ? (this.raise(r2.start, Ha.InvalidTupleMemberLabel), t4.label = r2) : t4.label = r2.typeName, t4.elementType = this.tsParseType(), r2 = this.finishNode(t4, "TSNamedTupleMember");
            } else if (i2) {
              const t4 = this.startNodeAtNode(r2);
              t4.typeAnnotation = r2, r2 = this.finishNode(t4, "TSOptionalType");
            }
            if (s2) {
              const s3 = this.startNodeAt(t3, e2);
              s3.typeAnnotation = r2, r2 = this.finishNode(s3, "TSRestType");
            }
            return r2;
          }
          tsParseParenthesizedType() {
            const t3 = this.startNode();
            return this.expect(Mi.parenL), t3.typeAnnotation = this.tsParseType(), this.expect(Mi.parenR), this.finishNode(t3, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(t3, e2) {
            const s2 = this.startNode();
            return "TSConstructorType" === t3 && (s2.abstract = !!e2, e2 && this.next(), this.next()), this.tsFillSignature(Mi.arrow, s2), this.finishNode(s2, t3);
          }
          tsParseLiteralTypeNode() {
            const t3 = this.startNode();
            return t3.literal = (() => {
              switch (this.state.type) {
                case Mi.num:
                case Mi.bigint:
                case Mi.string:
                case Mi._true:
                case Mi._false:
                  return this.parseExprAtom();
                default:
                  throw this.unexpected();
              }
            })(), this.finishNode(t3, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            const t3 = this.startNode();
            return t3.literal = this.parseTemplate(false), this.finishNode(t3, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const t3 = this.tsParseThisTypeNode();
            return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t3) : t3;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case Mi.name:
              case Mi._void:
              case Mi._null: {
                const t3 = this.match(Mi._void) ? "TSVoidKeyword" : this.match(Mi._null) ? "TSNullKeyword" : function(t4) {
                  switch (t4) {
                    case "any":
                      return "TSAnyKeyword";
                    case "boolean":
                      return "TSBooleanKeyword";
                    case "bigint":
                      return "TSBigIntKeyword";
                    case "never":
                      return "TSNeverKeyword";
                    case "number":
                      return "TSNumberKeyword";
                    case "object":
                      return "TSObjectKeyword";
                    case "string":
                      return "TSStringKeyword";
                    case "symbol":
                      return "TSSymbolKeyword";
                    case "undefined":
                      return "TSUndefinedKeyword";
                    case "unknown":
                      return "TSUnknownKeyword";
                    default:
                      return;
                  }
                }(this.state.value);
                if (void 0 !== t3 && 46 !== this.lookaheadCharCode()) {
                  const e2 = this.startNode();
                  return this.next(), this.finishNode(e2, t3);
                }
                return this.tsParseTypeReference();
              }
              case Mi.string:
              case Mi.num:
              case Mi.bigint:
              case Mi._true:
              case Mi._false:
                return this.tsParseLiteralTypeNode();
              case Mi.plusMin:
                if ("-" === this.state.value) {
                  const t3 = this.startNode(), e2 = this.lookahead();
                  if (e2.type !== Mi.num && e2.type !== Mi.bigint)
                    throw this.unexpected();
                  return t3.literal = this.parseMaybeUnary(), this.finishNode(t3, "TSLiteralType");
                }
                break;
              case Mi._this:
                return this.tsParseThisTypeOrThisTypePredicate();
              case Mi._typeof:
                return this.tsParseTypeQuery();
              case Mi._import:
                return this.tsParseImportType();
              case Mi.braceL:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case Mi.bracketL:
                return this.tsParseTupleType();
              case Mi.parenL:
                return this.tsParseParenthesizedType();
              case Mi.backQuote:
                return this.tsParseTemplateLiteralType();
            }
            throw this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let t3 = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(Mi.bracketL); )
              if (this.match(Mi.bracketR)) {
                const e2 = this.startNodeAtNode(t3);
                e2.elementType = t3, this.expect(Mi.bracketR), t3 = this.finishNode(e2, "TSArrayType");
              } else {
                const e2 = this.startNodeAtNode(t3);
                e2.objectType = t3, e2.indexType = this.tsParseType(), this.expect(Mi.bracketR), t3 = this.finishNode(e2, "TSIndexedAccessType");
              }
            return t3;
          }
          tsParseTypeOperator(t3) {
            const e2 = this.startNode();
            return this.expectContextual(t3), e2.operator = t3, e2.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === t3 && this.tsCheckTypeAnnotationForReadOnly(e2), this.finishNode(e2, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(t3) {
            switch (t3.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(t3.start, Ha.UnexpectedReadonly);
            }
          }
          tsParseInferType() {
            const t3 = this.startNode();
            this.expectContextual("infer");
            const e2 = this.startNode();
            return e2.name = this.parseIdentifierName(e2.start), t3.typeParameter = this.finishNode(e2, "TSTypeParameter"), this.finishNode(t3, "TSInferType");
          }
          tsParseTypeOperatorOrHigher() {
            const t3 = ["keyof", "unique", "readonly"].find((t4) => this.isContextual(t4));
            return t3 ? this.tsParseTypeOperator(t3) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
          }
          tsParseUnionOrIntersectionType(t3, e2, s2) {
            const r2 = this.startNode(), i2 = this.eat(s2), a2 = [];
            do {
              a2.push(e2());
            } while (this.eat(s2));
            return 1 !== a2.length || i2 ? (r2.types = a2, this.finishNode(r2, t3)) : a2[0];
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), Mi.bitwiseAND);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), Mi.bitwiseOR);
          }
          tsIsStartOfFunctionType() {
            return !!this.isRelational("<") || this.match(Mi.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (this.match(Mi.name) || this.match(Mi._this))
              return this.next(), true;
            if (this.match(Mi.braceL)) {
              let t3 = 1;
              for (this.next(); t3 > 0; )
                this.match(Mi.braceL) ? ++t3 : this.match(Mi.braceR) && --t3, this.next();
              return true;
            }
            if (this.match(Mi.bracketL)) {
              let t3 = 1;
              for (this.next(); t3 > 0; )
                this.match(Mi.bracketL) ? ++t3 : this.match(Mi.bracketR) && --t3, this.next();
              return true;
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            if (this.next(), this.match(Mi.parenR) || this.match(Mi.ellipsis))
              return true;
            if (this.tsSkipParameterStart()) {
              if (this.match(Mi.colon) || this.match(Mi.comma) || this.match(Mi.question) || this.match(Mi.eq))
                return true;
              if (this.match(Mi.parenR) && (this.next(), this.match(Mi.arrow)))
                return true;
            }
            return false;
          }
          tsParseTypeOrTypePredicateAnnotation(t3) {
            return this.tsInType(() => {
              const e2 = this.startNode();
              this.expect(t3);
              const s2 = this.startNode(), r2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (r2 && this.match(Mi._this)) {
                let t4 = this.tsParseThisTypeOrThisTypePredicate();
                return "TSThisType" === t4.type ? (s2.parameterName = t4, s2.asserts = true, t4 = this.finishNode(s2, "TSTypePredicate")) : (this.resetStartLocationFromNode(t4, s2), t4.asserts = true), e2.typeAnnotation = t4, this.finishNode(e2, "TSTypeAnnotation");
              }
              const i2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!i2)
                return r2 ? (s2.parameterName = this.parseIdentifier(), s2.asserts = r2, e2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(e2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, e2);
              const a2 = this.tsParseTypeAnnotation(false);
              return s2.parameterName = i2, s2.typeAnnotation = a2, s2.asserts = r2, e2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(e2, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            return this.match(Mi.colon) ? this.tsParseTypeOrTypePredicateAnnotation(Mi.colon) : void 0;
          }
          tsTryParseTypeAnnotation() {
            return this.match(Mi.colon) ? this.tsParseTypeAnnotation() : void 0;
          }
          tsTryParseType() {
            return this.tsEatThenParseType(Mi.colon);
          }
          tsParseTypePredicatePrefix() {
            const t3 = this.parseIdentifier();
            if (this.isContextual("is") && !this.hasPrecedingLineBreak())
              return this.next(), t3;
          }
          tsParseTypePredicateAsserts() {
            if (!this.match(Mi.name) || "asserts" !== this.state.value || this.hasPrecedingLineBreak())
              return false;
            const t3 = this.state.containsEsc;
            return this.next(), !(!this.match(Mi.name) && !this.match(Mi._this)) && (t3 && this.raise(this.state.lastTokStart, Gi.InvalidEscapedReservedWord, "asserts"), true);
          }
          tsParseTypeAnnotation(t3 = true, e2 = this.startNode()) {
            return this.tsInType(() => {
              t3 && this.expect(Mi.colon), e2.typeAnnotation = this.tsParseType();
            }), this.finishNode(e2, "TSTypeAnnotation");
          }
          tsParseType() {
            Va(this.state.inType);
            const t3 = this.tsParseNonConditionalType();
            if (this.hasPrecedingLineBreak() || !this.eat(Mi._extends))
              return t3;
            const e2 = this.startNodeAtNode(t3);
            return e2.checkType = t3, e2.extendsType = this.tsParseNonConditionalType(), this.expect(Mi.question), e2.trueType = this.tsParseType(), this.expect(Mi.colon), e2.falseType = this.tsParseType(), this.finishNode(e2, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual("abstract") && this.lookahead().type === Mi._new;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(Mi._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            const t3 = this.startNode(), e2 = this.tsTryNextParseConstantContext();
            return t3.typeAnnotation = e2 || this.tsNextThenParseType(), this.expectRelational(">"), t3.expression = this.parseMaybeUnary(), this.finishNode(t3, "TSTypeAssertion");
          }
          tsParseHeritageClause(t3) {
            const e2 = this.state.start, s2 = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
            return s2.length || this.raise(e2, Ha.EmptyHeritageClauseType, t3), s2;
          }
          tsParseExpressionWithTypeArguments() {
            const t3 = this.startNode();
            return t3.expression = this.tsParseEntityName(false), this.isRelational("<") && (t3.typeParameters = this.tsParseTypeArguments()), this.finishNode(t3, "TSExpressionWithTypeArguments");
          }
          tsParseInterfaceDeclaration(t3) {
            t3.id = this.parseIdentifier(), this.checkLVal(t3.id, "typescript interface declaration", 130), t3.typeParameters = this.tsTryParseTypeParameters(), this.eat(Mi._extends) && (t3.extends = this.tsParseHeritageClause("extends"));
            const e2 = this.startNode();
            return e2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t3.body = this.finishNode(e2, "TSInterfaceBody"), this.finishNode(t3, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(t3) {
            return t3.id = this.parseIdentifier(), this.checkLVal(t3.id, "typescript type alias", 2), t3.typeParameters = this.tsTryParseTypeParameters(), t3.typeAnnotation = this.tsInType(() => {
              if (this.expect(Mi.eq), this.isContextual("intrinsic") && this.lookahead().type !== Mi.dot) {
                const t4 = this.startNode();
                return this.next(), this.finishNode(t4, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(t3, "TSTypeAliasDeclaration");
          }
          tsInNoContext(t3) {
            const e2 = this.state.context;
            this.state.context = [e2[0]];
            try {
              return t3();
            } finally {
              this.state.context = e2;
            }
          }
          tsInType(t3) {
            const e2 = this.state.inType;
            this.state.inType = true;
            try {
              return t3();
            } finally {
              this.state.inType = e2;
            }
          }
          tsEatThenParseType(t3) {
            return this.match(t3) ? this.tsNextThenParseType() : void 0;
          }
          tsExpectThenParseType(t3) {
            return this.tsDoThenParseType(() => this.expect(t3));
          }
          tsNextThenParseType() {
            return this.tsDoThenParseType(() => this.next());
          }
          tsDoThenParseType(t3) {
            return this.tsInType(() => (t3(), this.tsParseType()));
          }
          tsParseEnumMember() {
            const t3 = this.startNode();
            return t3.id = this.match(Mi.string) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(Mi.eq) && (t3.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(t3, "TSEnumMember");
          }
          tsParseEnumDeclaration(t3, e2) {
            return e2 && (t3.const = true), t3.id = this.parseIdentifier(), this.checkLVal(t3.id, "typescript enum declaration", e2 ? 779 : 267), this.expect(Mi.braceL), t3.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(Mi.braceR), this.finishNode(t3, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            const t3 = this.startNode();
            return this.scope.enter(0), this.expect(Mi.braceL), this.parseBlockOrModuleBlockBody(t3.body = [], void 0, true, Mi.braceR), this.scope.exit(), this.finishNode(t3, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(t3, e2 = false) {
            if (t3.id = this.parseIdentifier(), e2 || this.checkLVal(t3.id, "module or namespace declaration", 1024), this.eat(Mi.dot)) {
              const e3 = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(e3, true), t3.body = e3;
            } else
              this.scope.enter(ya), this.prodParam.enter(0), t3.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(t3, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(t3) {
            return this.isContextual("global") ? (t3.global = true, t3.id = this.parseIdentifier()) : this.match(Mi.string) ? t3.id = this.parseExprAtom() : this.unexpected(), this.match(Mi.braceL) ? (this.scope.enter(ya), this.prodParam.enter(0), t3.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(t3, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(t3, e2) {
            t3.isExport = e2 || false, t3.id = this.parseIdentifier(), this.checkLVal(t3.id, "import equals declaration", 9), this.expect(Mi.eq);
            const s2 = this.tsParseModuleReference();
            return "type" === t3.importKind && "TSExternalModuleReference" !== s2.type && this.raise(s2.start, Ha.ImportAliasHasImportType), t3.moduleReference = s2, this.semicolon(), this.finishNode(t3, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual("require") && 40 === this.lookaheadCharCode();
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            const t3 = this.startNode();
            if (this.expectContextual("require"), this.expect(Mi.parenL), !this.match(Mi.string))
              throw this.unexpected();
            return t3.expression = this.parseExprAtom(), this.expect(Mi.parenR), this.finishNode(t3, "TSExternalModuleReference");
          }
          tsLookAhead(t3) {
            const e2 = this.state.clone(), s2 = t3();
            return this.state = e2, s2;
          }
          tsTryParseAndCatch(t3) {
            const e2 = this.tryParse((e3) => t3() || e3());
            if (!e2.aborted && e2.node)
              return e2.error && (this.state = e2.failState), e2.node;
          }
          tsTryParse(t3) {
            const e2 = this.state.clone(), s2 = t3();
            return void 0 !== s2 && false !== s2 ? s2 : void (this.state = e2);
          }
          tsTryParseDeclare(t3) {
            if (this.isLineTerminator())
              return;
            let e2, s2 = this.state.type;
            return this.isContextual("let") && (s2 = Mi._var, e2 = "let"), this.tsInAmbientContext(() => {
              switch (s2) {
                case Mi._function:
                  return t3.declare = true, this.parseFunctionStatement(t3, false, true);
                case Mi._class:
                  return t3.declare = true, this.parseClass(t3, true, false);
                case Mi._const:
                  if (this.match(Mi._const) && this.isLookaheadContextual("enum"))
                    return this.expect(Mi._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(t3, true);
                case Mi._var:
                  return e2 = e2 || this.state.value, this.parseVarStatement(t3, e2);
                case Mi.name: {
                  const e3 = this.state.value;
                  return "global" === e3 ? this.tsParseAmbientExternalModuleDeclaration(t3) : this.tsParseDeclaration(t3, e3, true);
                }
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true);
          }
          tsParseExpressionStatement(t3, e2) {
            switch (e2.name) {
              case "declare": {
                const e3 = this.tsTryParseDeclare(t3);
                if (e3)
                  return e3.declare = true, e3;
                break;
              }
              case "global":
                if (this.match(Mi.braceL)) {
                  this.scope.enter(ya), this.prodParam.enter(0);
                  const s2 = t3;
                  return s2.global = true, s2.id = e2, s2.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(s2, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(t3, e2.name, false);
            }
          }
          tsParseDeclaration(t3, e2, s2) {
            switch (e2) {
              case "abstract":
                if (this.tsCheckLineTerminator(s2) && (this.match(Mi._class) || this.match(Mi.name)))
                  return this.tsParseAbstractDeclaration(t3);
                break;
              case "enum":
                if (s2 || this.match(Mi.name))
                  return s2 && this.next(), this.tsParseEnumDeclaration(t3, false);
                break;
              case "interface":
                if (this.tsCheckLineTerminator(s2) && this.match(Mi.name))
                  return this.tsParseInterfaceDeclaration(t3);
                break;
              case "module":
                if (this.tsCheckLineTerminator(s2)) {
                  if (this.match(Mi.string))
                    return this.tsParseAmbientExternalModuleDeclaration(t3);
                  if (this.match(Mi.name))
                    return this.tsParseModuleOrNamespaceDeclaration(t3);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(s2) && this.match(Mi.name))
                  return this.tsParseModuleOrNamespaceDeclaration(t3);
                break;
              case "type":
                if (this.tsCheckLineTerminator(s2) && this.match(Mi.name))
                  return this.tsParseTypeAliasDeclaration(t3);
            }
          }
          tsCheckLineTerminator(t3) {
            return t3 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(t3, e2) {
            if (!this.isRelational("<"))
              return;
            const s2 = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            const r2 = this.tsTryParseAndCatch(() => {
              const s3 = this.startNodeAt(t3, e2);
              return s3.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(s3), s3.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(Mi.arrow), s3;
            });
            return this.state.maybeInArrowParameters = s2, r2 ? this.parseArrowExpression(r2, null, true) : void 0;
          }
          tsParseTypeArguments() {
            const t3 = this.startNode();
            return t3.params = this.tsInType(() => this.tsInNoContext(() => (this.expectRelational("<"), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), 0 === t3.params.length && this.raise(t3.start, Ha.EmptyTypeArguments), this.state.exprAllowed = false, this.expectRelational(">"), this.finishNode(t3, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            if (this.match(Mi.name))
              switch (this.state.value) {
                case "abstract":
                case "declare":
                case "enum":
                case "interface":
                case "module":
                case "namespace":
                case "type":
                  return true;
              }
            return false;
          }
          isExportDefaultSpecifier() {
            return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(t3, e2) {
            const s2 = this.state.start, r2 = this.state.startLoc;
            let i2, a2 = false;
            void 0 !== t3 && (i2 = this.parseAccessModifier(), a2 = !!this.tsParseModifier(["readonly"]), false === t3 && (i2 || a2) && this.raise(s2, Ha.UnexpectedParameterModifier));
            const n2 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(n2);
            const o2 = this.parseMaybeDefault(n2.start, n2.loc.start, n2);
            if (i2 || a2) {
              const t4 = this.startNodeAt(s2, r2);
              return e2.length && (t4.decorators = e2), i2 && (t4.accessibility = i2), a2 && (t4.readonly = a2), "Identifier" !== o2.type && "AssignmentPattern" !== o2.type && this.raise(t4.start, Ha.UnsupportedParameterPropertyKind), t4.parameter = o2, this.finishNode(t4, "TSParameterProperty");
            }
            return e2.length && (n2.decorators = e2), o2;
          }
          parseFunctionBodyAndFinish(t3, e2, s2 = false) {
            this.match(Mi.colon) && (t3.returnType = this.tsParseTypeOrTypePredicateAnnotation(Mi.colon));
            const r2 = "FunctionDeclaration" === e2 ? "TSDeclareFunction" : "ClassMethod" === e2 ? "TSDeclareMethod" : void 0;
            r2 && !this.match(Mi.braceL) && this.isLineTerminator() ? this.finishNode(t3, r2) : "TSDeclareFunction" === r2 && this.state.isAmbientContext && (this.raise(t3.start, Ha.DeclareFunctionHasImplementation), t3.declare) ? super.parseFunctionBodyAndFinish(t3, r2, s2) : super.parseFunctionBodyAndFinish(t3, e2, s2);
          }
          registerFunctionStatementId(t3) {
            !t3.body && t3.id ? this.checkLVal(t3.id, "function name", 1024) : super.registerFunctionStatementId(...arguments);
          }
          tsCheckForInvalidTypeCasts(t3) {
            t3.forEach((t4) => {
              "TSTypeCastExpression" === (null == t4 ? void 0 : t4.type) && this.raise(t4.typeAnnotation.start, Ha.UnexpectedTypeAnnotation);
            });
          }
          toReferencedList(t3, e2) {
            return this.tsCheckForInvalidTypeCasts(t3), t3;
          }
          parseArrayLike(...t3) {
            const e2 = super.parseArrayLike(...t3);
            return "ArrayExpression" === e2.type && this.tsCheckForInvalidTypeCasts(e2.elements), e2;
          }
          parseSubscript(t3, e2, s2, r2, i2) {
            if (!this.hasPrecedingLineBreak() && this.match(Mi.bang)) {
              this.state.exprAllowed = false, this.next();
              const r3 = this.startNodeAt(e2, s2);
              return r3.expression = t3, this.finishNode(r3, "TSNonNullExpression");
            }
            if (this.isRelational("<")) {
              const a2 = this.tsTryParseAndCatch(() => {
                if (!r2 && this.atPossibleAsyncArrow(t3)) {
                  const t4 = this.tsTryParseGenericAsyncArrowFunction(e2, s2);
                  if (t4)
                    return t4;
                }
                const a3 = this.startNodeAt(e2, s2);
                a3.callee = t3;
                const n2 = this.tsParseTypeArguments();
                if (n2) {
                  if (!r2 && this.eat(Mi.parenL))
                    return a3.arguments = this.parseCallExpressionArguments(Mi.parenR, false), this.tsCheckForInvalidTypeCasts(a3.arguments), a3.typeParameters = n2, i2.optionalChainMember && (a3.optional = false), this.finishCallExpression(a3, i2.optionalChainMember);
                  if (this.match(Mi.backQuote)) {
                    const r3 = this.parseTaggedTemplateExpression(t3, e2, s2, i2);
                    return r3.typeParameters = n2, r3;
                  }
                }
                this.unexpected();
              });
              if (a2)
                return a2;
            }
            return super.parseSubscript(t3, e2, s2, r2, i2);
          }
          parseNewArguments(t3) {
            if (this.isRelational("<")) {
              const e2 = this.tsTryParseAndCatch(() => {
                const t4 = this.tsParseTypeArguments();
                return this.match(Mi.parenL) || this.unexpected(), t4;
              });
              e2 && (t3.typeParameters = e2);
            }
            super.parseNewArguments(t3);
          }
          parseExprOp(t3, e2, s2, r2) {
            if (qa(Mi._in.binop) > r2 && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
              const i2 = this.startNodeAt(e2, s2);
              i2.expression = t3;
              const a2 = this.tsTryNextParseConstantContext();
              return i2.typeAnnotation = a2 || this.tsNextThenParseType(), this.finishNode(i2, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i2, e2, s2, r2);
            }
            return super.parseExprOp(t3, e2, s2, r2);
          }
          checkReservedWord(t3, e2, s2, r2) {
          }
          checkDuplicateExports() {
          }
          parseImport(t3) {
            if (t3.importKind = "value", this.match(Mi.name) || this.match(Mi.star) || this.match(Mi.braceL)) {
              let e3 = this.lookahead();
              if (!this.isContextual("type") || e3.type === Mi.comma || e3.type === Mi.name && "from" === e3.value || e3.type === Mi.eq || (t3.importKind = "type", this.next(), e3 = this.lookahead()), this.match(Mi.name) && e3.type === Mi.eq)
                return this.tsParseImportEqualsDeclaration(t3);
            }
            const e2 = super.parseImport(t3);
            return "type" === e2.importKind && e2.specifiers.length > 1 && "ImportDefaultSpecifier" === e2.specifiers[0].type && this.raise(e2.start, Ha.TypeImportCannotSpecifyDefaultAndNamed), e2;
          }
          parseExport(t3) {
            if (this.match(Mi._import))
              return this.next(), this.isContextual("type") && 61 !== this.lookaheadCharCode() ? (t3.importKind = "type", this.next()) : t3.importKind = "value", this.tsParseImportEqualsDeclaration(t3, true);
            if (this.eat(Mi.eq)) {
              const e2 = t3;
              return e2.expression = this.parseExpression(), this.semicolon(), this.finishNode(e2, "TSExportAssignment");
            }
            if (this.eatContextual("as")) {
              const e2 = t3;
              return this.expectContextual("namespace"), e2.id = this.parseIdentifier(), this.semicolon(), this.finishNode(e2, "TSNamespaceExportDeclaration");
            }
            return this.isContextual("type") && this.lookahead().type === Mi.braceL ? (this.next(), t3.exportKind = "type") : t3.exportKind = "value", super.parseExport(t3);
          }
          isAbstractClass() {
            return this.isContextual("abstract") && this.lookahead().type === Mi._class;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const t3 = this.startNode();
              return this.next(), t3.abstract = true, this.parseClass(t3, true, true), t3;
            }
            if ("interface" === this.state.value) {
              const t3 = this.tsParseDeclaration(this.startNode(), this.state.value, true);
              if (t3)
                return t3;
            }
            return super.parseExportDefaultExpression();
          }
          parseStatementContent(t3, e2) {
            if (this.state.type === Mi._const) {
              const t4 = this.lookahead();
              if (t4.type === Mi.name && "enum" === t4.value) {
                const t5 = this.startNode();
                return this.expect(Mi._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(t5, true);
              }
            }
            return super.parseStatementContent(t3, e2);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(t3, e2) {
            return e2.some((e3) => za(e3) ? t3.accessibility === e3 : !!t3[e3]);
          }
          parseClassMember(t3, e2, s2) {
            const r2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly"];
            this.tsParseModifiers(e2, r2.concat(["static"]));
            const i2 = () => {
              const i3 = !!e2.static;
              i3 && this.eat(Mi.braceL) ? (this.tsHasSomeModifiers(e2, r2) && this.raise(this.state.pos, Ha.StaticBlockCannotHaveModifier), this.parseClassStaticBlock(t3, e2)) : this.parseClassMemberWithIsStatic(t3, e2, s2, i3);
            };
            e2.declare ? this.tsInAmbientContext(i2) : i2();
          }
          parseClassMemberWithIsStatic(t3, e2, s2, r2) {
            const i2 = this.tsTryParseIndexSignature(e2);
            if (i2)
              return t3.body.push(i2), e2.abstract && this.raise(e2.start, Ha.IndexSignatureHasAbstract), e2.accessibility && this.raise(e2.start, Ha.IndexSignatureHasAccessibility, e2.accessibility), e2.declare && this.raise(e2.start, Ha.IndexSignatureHasDeclare), void (e2.override && this.raise(e2.start, Ha.IndexSignatureHasOverride));
            !this.state.inAbstractClass && e2.abstract && this.raise(e2.start, Ha.NonAbstractClassHasAbstractMethod), e2.override && (s2.hadSuperClass || this.raise(e2.start, Ha.OverrideNotInSubClass)), super.parseClassMemberWithIsStatic(t3, e2, s2, r2);
          }
          parsePostMemberNameModifiers(t3) {
            this.eat(Mi.question) && (t3.optional = true), t3.readonly && this.match(Mi.parenL) && this.raise(t3.start, Ha.ClassMethodHasReadonly), t3.declare && this.match(Mi.parenL) && this.raise(t3.start, Ha.ClassMethodHasDeclare);
          }
          parseExpressionStatement(t3, e2) {
            return ("Identifier" === e2.type ? this.tsParseExpressionStatement(t3, e2) : void 0) || super.parseExpressionStatement(t3, e2);
          }
          shouldParseExportDeclaration() {
            return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(t3, e2, s2, r2) {
            if (!r2 || !this.match(Mi.question))
              return super.parseConditional(t3, e2, s2, r2);
            const i2 = this.tryParse(() => super.parseConditional(t3, e2, s2));
            return i2.node ? (i2.error && (this.state = i2.failState), i2.node) : (r2.start = i2.error.pos || this.state.start, t3);
          }
          parseParenItem(t3, e2, s2) {
            if (t3 = super.parseParenItem(t3, e2, s2), this.eat(Mi.question) && (t3.optional = true, this.resetEndLocation(t3)), this.match(Mi.colon)) {
              const r2 = this.startNodeAt(e2, s2);
              return r2.expression = t3, r2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r2, "TSTypeCastExpression");
            }
            return t3;
          }
          parseExportDeclaration(t3) {
            const e2 = this.state.start, s2 = this.state.startLoc, r2 = this.eatContextual("declare");
            if (r2 && (this.isContextual("declare") || !this.shouldParseExportDeclaration()))
              throw this.raise(this.state.start, Ha.ExpectedAmbientAfterExportDeclare);
            let i2;
            return this.match(Mi.name) && (i2 = this.tsTryParseExportDeclaration()), i2 || (i2 = super.parseExportDeclaration(t3)), i2 && ("TSInterfaceDeclaration" === i2.type || "TSTypeAliasDeclaration" === i2.type || r2) && (t3.exportKind = "type"), i2 && r2 && (this.resetStartLocation(i2, e2, s2), i2.declare = true), i2;
          }
          parseClassId(t3, e2, s2) {
            if ((!e2 || s2) && this.isContextual("implements"))
              return;
            super.parseClassId(t3, e2, s2, t3.declare ? 1024 : 139);
            const r2 = this.tsTryParseTypeParameters();
            r2 && (t3.typeParameters = r2);
          }
          parseClassPropertyAnnotation(t3) {
            !t3.optional && this.eat(Mi.bang) && (t3.definite = true);
            const e2 = this.tsTryParseTypeAnnotation();
            e2 && (t3.typeAnnotation = e2);
          }
          parseClassProperty(t3) {
            return this.parseClassPropertyAnnotation(t3), this.state.isAmbientContext && this.match(Mi.eq) && this.raise(this.state.start, Ha.DeclareClassFieldHasInitializer), super.parseClassProperty(t3);
          }
          parseClassPrivateProperty(t3) {
            return t3.abstract && this.raise(t3.start, Ha.PrivateElementHasAbstract), t3.accessibility && this.raise(t3.start, Ha.PrivateElementHasAccessibility, t3.accessibility), this.parseClassPropertyAnnotation(t3), super.parseClassPrivateProperty(t3);
          }
          pushClassMethod(t3, e2, s2, r2, i2, a2) {
            const n2 = this.tsTryParseTypeParameters();
            n2 && i2 && this.raise(n2.start, Ha.ConstructorHasTypeParameters), !e2.declare || "get" !== e2.kind && "set" !== e2.kind || this.raise(e2.start, Ha.DeclareAccessor, e2.kind), n2 && (e2.typeParameters = n2), super.pushClassMethod(t3, e2, s2, r2, i2, a2);
          }
          pushClassPrivateMethod(t3, e2, s2, r2) {
            const i2 = this.tsTryParseTypeParameters();
            i2 && (e2.typeParameters = i2), super.pushClassPrivateMethod(t3, e2, s2, r2);
          }
          parseClassSuper(t3) {
            super.parseClassSuper(t3), t3.superClass && this.isRelational("<") && (t3.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual("implements") && (t3.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(t3, ...e2) {
            const s2 = this.tsTryParseTypeParameters();
            s2 && (t3.typeParameters = s2), super.parseObjPropValue(t3, ...e2);
          }
          parseFunctionParams(t3, e2) {
            const s2 = this.tsTryParseTypeParameters();
            s2 && (t3.typeParameters = s2), super.parseFunctionParams(t3, e2);
          }
          parseVarId(t3, e2) {
            super.parseVarId(t3, e2), "Identifier" === t3.id.type && this.eat(Mi.bang) && (t3.definite = true);
            const s2 = this.tsTryParseTypeAnnotation();
            s2 && (t3.id.typeAnnotation = s2, this.resetEndLocation(t3.id));
          }
          parseAsyncArrowFromCallExpression(t3, e2) {
            return this.match(Mi.colon) && (t3.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(t3, e2);
          }
          parseMaybeAssign(...t3) {
            var e2, s2, r2, i2, a2, n2, o2;
            let u2, h2, c2, p2;
            if (this.hasPlugin("jsx") && (this.match(Mi.jsxTagStart) || this.isRelational("<"))) {
              if (u2 = this.state.clone(), h2 = this.tryParse(() => super.parseMaybeAssign(...t3), u2), !h2.error)
                return h2.node;
              const {
                context: e3
              } = this.state;
              e3[e3.length - 1] === $i.j_oTag ? e3.length -= 2 : e3[e3.length - 1] === $i.j_expr && (e3.length -= 1);
            }
            if (!(null != (e2 = h2) && e2.error || this.isRelational("<")))
              return super.parseMaybeAssign(...t3);
            u2 = u2 || this.state.clone();
            const l2 = this.tryParse((e3) => {
              var s3, r3;
              p2 = this.tsParseTypeParameters();
              const i3 = super.parseMaybeAssign(...t3);
              return ("ArrowFunctionExpression" !== i3.type || null != (s3 = i3.extra) && s3.parenthesized) && e3(), 0 !== (null == (r3 = p2) ? void 0 : r3.params.length) && this.resetStartLocationFromNode(i3, p2), i3.typeParameters = p2, i3;
            }, u2);
            if (!l2.error && !l2.aborted)
              return l2.node;
            if (!h2 && (Va(!this.hasPlugin("jsx")), c2 = this.tryParse(() => super.parseMaybeAssign(...t3), u2), !c2.error))
              return c2.node;
            if (null != (s2 = h2) && s2.node)
              return this.state = h2.failState, h2.node;
            if (l2.node)
              return this.state = l2.failState, l2.node;
            if (null != (r2 = c2) && r2.node)
              return this.state = c2.failState, c2.node;
            if (null != (i2 = h2) && i2.thrown)
              throw h2.error;
            if (l2.thrown)
              throw l2.error;
            if (null != (a2 = c2) && a2.thrown)
              throw c2.error;
            throw (null == (n2 = h2) ? void 0 : n2.error) || l2.error || (null == (o2 = c2) ? void 0 : o2.error);
          }
          parseMaybeUnary(t3) {
            return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(t3);
          }
          parseArrow(t3) {
            if (this.match(Mi.colon)) {
              const e2 = this.tryParse((t4) => {
                const e3 = this.tsParseTypeOrTypePredicateAnnotation(Mi.colon);
                return !this.canInsertSemicolon() && this.match(Mi.arrow) || t4(), e3;
              });
              if (e2.aborted)
                return;
              e2.thrown || (e2.error && (this.state = e2.failState), t3.returnType = e2.node);
            }
            return super.parseArrow(t3);
          }
          parseAssignableListItemTypes(t3) {
            this.eat(Mi.question) && ("Identifier" === t3.type || this.state.isAmbientContext || this.state.inType || this.raise(t3.start, Ha.PatternIsOptional), t3.optional = true);
            const e2 = this.tsTryParseTypeAnnotation();
            return e2 && (t3.typeAnnotation = e2), this.resetEndLocation(t3), t3;
          }
          toAssignable(t3, e2 = false) {
            switch (t3.type) {
              case "TSTypeCastExpression":
                return super.toAssignable(this.typeCastToParameter(t3), e2);
              case "TSParameterProperty":
                return super.toAssignable(t3, e2);
              case "ParenthesizedExpression":
                return this.toAssignableParenthesizedExpression(t3, e2);
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                return t3.expression = this.toAssignable(t3.expression, e2), t3;
              default:
                return super.toAssignable(t3, e2);
            }
          }
          toAssignableParenthesizedExpression(t3, e2) {
            switch (t3.expression.type) {
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                return t3.expression = this.toAssignable(t3.expression, e2), t3;
              default:
                return super.toAssignable(t3, e2);
            }
          }
          checkLVal(t3, e2, ...s2) {
            var r2;
            switch (t3.type) {
              case "TSTypeCastExpression":
                return;
              case "TSParameterProperty":
                return void this.checkLVal(t3.parameter, "parameter property", ...s2);
              case "TSAsExpression":
              case "TSTypeAssertion":
                if (!(s2[0] || "parenthesized expression" === e2 || null != (r2 = t3.extra) && r2.parenthesized)) {
                  this.raise(t3.start, Gi.InvalidLhs, e2);
                  break;
                }
                return void this.checkLVal(t3.expression, "parenthesized expression", ...s2);
              case "TSNonNullExpression":
                return void this.checkLVal(t3.expression, e2, ...s2);
              default:
                return void super.checkLVal(t3, e2, ...s2);
            }
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case Mi._this:
                return this.parseIdentifier(true);
              default:
                return super.parseBindingAtom();
            }
          }
          parseMaybeDecoratorArguments(t3) {
            if (this.isRelational("<")) {
              const e2 = this.tsParseTypeArguments();
              if (this.match(Mi.parenL)) {
                const s2 = super.parseMaybeDecoratorArguments(t3);
                return s2.typeParameters = e2, s2;
              }
              this.unexpected(this.state.start, Mi.parenL);
            }
            return super.parseMaybeDecoratorArguments(t3);
          }
          checkCommaAfterRest(t3) {
            this.state.isAmbientContext && this.match(Mi.comma) && this.lookaheadCharCode() === t3 ? this.next() : super.checkCommaAfterRest(t3);
          }
          isClassMethod() {
            return this.isRelational("<") || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(Mi.bang) || this.match(Mi.colon) || super.isClassProperty();
          }
          parseMaybeDefault(...t3) {
            const e2 = super.parseMaybeDefault(...t3);
            return "AssignmentPattern" === e2.type && e2.typeAnnotation && e2.right.start < e2.typeAnnotation.start && this.raise(e2.typeAnnotation.start, Ha.TypeAnnotationAfterAssign), e2;
          }
          getTokenFromCode(t3) {
            return !this.state.inType || 62 !== t3 && 60 !== t3 ? super.getTokenFromCode(t3) : this.finishOp(Mi.relational, 1);
          }
          reScan_lt_gt() {
            if (this.match(Mi.relational)) {
              const t3 = this.input.charCodeAt(this.state.start);
              60 !== t3 && 62 !== t3 || (this.state.pos -= 1, this.readToken_lt_gt(t3));
            }
          }
          toAssignableList(t3) {
            for (let e2 = 0; e2 < t3.length; e2++) {
              const s2 = t3[e2];
              if (s2)
                switch (s2.type) {
                  case "TSTypeCastExpression":
                    t3[e2] = this.typeCastToParameter(s2);
                    break;
                  case "TSAsExpression":
                  case "TSTypeAssertion":
                    this.state.maybeInArrowParameters ? this.raise(s2.start, Ha.UnexpectedTypeCastInParameter) : t3[e2] = this.typeCastToParameter(s2);
                }
            }
            return super.toAssignableList(...arguments);
          }
          typeCastToParameter(t3) {
            return t3.expression.typeAnnotation = t3.typeAnnotation, this.resetEndLocation(t3.expression, t3.typeAnnotation.end, t3.typeAnnotation.loc.end), t3.expression;
          }
          shouldParseArrow() {
            return this.match(Mi.colon) || super.shouldParseArrow();
          }
          shouldParseAsyncArrow() {
            return this.match(Mi.colon) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(t3) {
            if (this.isRelational("<")) {
              const e2 = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
              e2 && (t3.typeParameters = e2);
            }
            return super.jsxParseOpeningElementAfterName(t3);
          }
          getGetterSetterExpectedParamCount(t3) {
            const e2 = super.getGetterSetterExpectedParamCount(t3), s2 = this.getObjectOrClassMethodParams(t3)[0];
            return s2 && this.isThisParam(s2) ? e2 + 1 : e2;
          }
          parseCatchClauseParam() {
            const t3 = super.parseCatchClauseParam(), e2 = this.tsTryParseTypeAnnotation();
            return e2 && (t3.typeAnnotation = e2, this.resetEndLocation(t3)), t3;
          }
          tsInAmbientContext(t3) {
            const e2 = this.state.isAmbientContext;
            this.state.isAmbientContext = true;
            try {
              return t3();
            } finally {
              this.state.isAmbientContext = e2;
            }
          }
          parseClass(t3, ...e2) {
            const s2 = this.state.inAbstractClass;
            this.state.inAbstractClass = !!t3.abstract;
            try {
              return super.parseClass(t3, ...e2);
            } finally {
              this.state.inAbstractClass = s2;
            }
          }
          tsParseAbstractDeclaration(t3) {
            if (this.match(Mi._class))
              return t3.abstract = true, this.parseClass(t3, true, false);
            if (this.isContextual("interface")) {
              if (!this.hasFollowingLineBreak())
                return t3.abstract = true, this.raise(t3.start, Ha.NonClassMethodPropertyHasAbstractModifer), this.next(), this.tsParseInterfaceDeclaration(t3);
            } else
              this.unexpected(null, Mi._class);
          }
          parseMethod(...t3) {
            const e2 = super.parseMethod(...t3);
            if (e2.abstract) {
              if (this.hasPlugin("estree") ? !!e2.value.body : !!e2.body) {
                const {
                  key: t4
                } = e2;
                this.raise(e2.start, Ha.AbstractMethodHasImplementation, "Identifier" === t4.type ? t4.name : "[".concat(this.input.slice(t4.start, t4.end), "]"));
              }
            }
            return e2;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
          }
        },
        v8intrinsic: (t2) => class extends t2 {
          parseV8Intrinsic() {
            if (this.match(Mi.modulo)) {
              const t3 = this.state.start, e2 = this.startNode();
              if (this.eat(Mi.modulo), this.match(Mi.name)) {
                const t4 = this.parseIdentifierName(this.state.start), s2 = this.createIdentifier(e2, t4);
                if (s2.type = "V8IntrinsicIdentifier", this.match(Mi.parenL))
                  return s2;
              }
              this.unexpected(t3);
            }
          }
          parseExprAtom() {
            return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
          }
        },
        placeholders: (t2) => class extends t2 {
          parsePlaceholder(t3) {
            if (this.match(Mi.placeholder)) {
              const e2 = this.startNode();
              return this.next(), this.assertNoSpace("Unexpected space in placeholder."), e2.name = super.parseIdentifier(true), this.assertNoSpace("Unexpected space in placeholder."), this.expect(Mi.placeholder), this.finishPlaceholder(e2, t3);
            }
          }
          finishPlaceholder(t3, e2) {
            const s2 = !(!t3.expectedNode || "Placeholder" !== t3.type);
            return t3.expectedNode = e2, s2 ? t3 : this.finishNode(t3, "Placeholder");
          }
          getTokenFromCode(t3) {
            return 37 === t3 && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(Mi.placeholder, 2) : super.getTokenFromCode(...arguments);
          }
          parseExprAtom() {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
          }
          parseIdentifier() {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
          }
          checkReservedWord(t3) {
            void 0 !== t3 && super.checkReservedWord(...arguments);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
          }
          checkLVal(t3) {
            "Placeholder" !== t3.type && super.checkLVal(...arguments);
          }
          toAssignable(t3) {
            return t3 && "Placeholder" === t3.type && "Expression" === t3.expectedNode ? (t3.expectedNode = "Pattern", t3) : super.toAssignable(...arguments);
          }
          isLet(t3) {
            if (super.isLet(t3))
              return true;
            if (!this.isContextual("let"))
              return false;
            if (t3)
              return false;
            return this.lookahead().type === Mi.placeholder;
          }
          verifyBreakContinue(t3) {
            t3.label && "Placeholder" === t3.label.type || super.verifyBreakContinue(...arguments);
          }
          parseExpressionStatement(t3, e2) {
            if ("Placeholder" !== e2.type || e2.extra && e2.extra.parenthesized)
              return super.parseExpressionStatement(...arguments);
            if (this.match(Mi.colon)) {
              const s2 = t3;
              return s2.label = this.finishPlaceholder(e2, "Identifier"), this.next(), s2.body = this.parseStatement("label"), this.finishNode(s2, "LabeledStatement");
            }
            return this.semicolon(), t3.name = e2.name, this.finishPlaceholder(t3, "Statement");
          }
          parseBlock() {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
          }
          parseFunctionId() {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
          }
          parseClass(t3, e2, s2) {
            const r2 = e2 ? "ClassDeclaration" : "ClassExpression";
            this.next(), this.takeDecorators(t3);
            const i2 = this.state.strict, a2 = this.parsePlaceholder("Identifier");
            if (a2) {
              if (this.match(Mi._extends) || this.match(Mi.placeholder) || this.match(Mi.braceL))
                t3.id = a2;
              else {
                if (s2 || !e2)
                  return t3.id = null, t3.body = this.finishPlaceholder(a2, "ClassBody"), this.finishNode(t3, r2);
                this.unexpected(null, Wa.ClassNameIsRequired);
              }
            } else
              this.parseClassId(t3, e2, s2);
            return this.parseClassSuper(t3), t3.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!t3.superClass, i2), this.finishNode(t3, r2);
          }
          parseExport(t3) {
            const e2 = this.parsePlaceholder("Identifier");
            if (!e2)
              return super.parseExport(...arguments);
            if (!this.isContextual("from") && !this.match(Mi.comma))
              return t3.specifiers = [], t3.source = null, t3.declaration = this.finishPlaceholder(e2, "Declaration"), this.finishNode(t3, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            const s2 = this.startNode();
            return s2.exported = e2, t3.specifiers = [this.finishNode(s2, "ExportDefaultSpecifier")], super.parseExport(t3);
          }
          isExportDefaultSpecifier() {
            if (this.match(Mi._default)) {
              const t3 = this.nextTokenStart();
              if (this.isUnparsedContextual(t3, "from") && this.input.startsWith(Mi.placeholder.label, this.nextTokenStartSince(t3 + 4)))
                return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(t3) {
            return !!(t3.specifiers && t3.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
          }
          checkExport(t3) {
            const {
              specifiers: e2
            } = t3;
            null != e2 && e2.length && (t3.specifiers = e2.filter((t4) => "Placeholder" === t4.exported.type)), super.checkExport(t3), t3.specifiers = e2;
          }
          parseImport(t3) {
            const e2 = this.parsePlaceholder("Identifier");
            if (!e2)
              return super.parseImport(...arguments);
            if (t3.specifiers = [], !this.isContextual("from") && !this.match(Mi.comma))
              return t3.source = this.finishPlaceholder(e2, "StringLiteral"), this.semicolon(), this.finishNode(t3, "ImportDeclaration");
            const s2 = this.startNodeAtNode(e2);
            if (s2.local = e2, this.finishNode(s2, "ImportDefaultSpecifier"), t3.specifiers.push(s2), this.eat(Mi.comma)) {
              this.maybeParseStarImportSpecifier(t3) || this.parseNamedImportSpecifiers(t3);
            }
            return this.expectContextual("from"), t3.source = this.parseImportSource(), this.semicolon(), this.finishNode(t3, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
          }
        }
      }, Ya = Object.keys($a), Qa = {
        sourceType: "script",
        sourceFilename: void 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createParenthesizedExpressions: false,
        errorRecovery: false
      };
      class Za {
        constructor() {
          this.strict = void 0, this.curLine = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inPipeline = false, this.inType = false, this.noAnonFunctionType = false, this.inPropertyName = false, this.hasFlowComment = false, this.isIterator = false, this.isAmbientContext = false, this.inAbstractClass = false, this.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.trailingComments = [], this.leadingComments = [], this.commentStack = [], this.commentPreviousNode = null, this.pos = 0, this.lineStart = 0, this.type = Mi.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [$i.braceStatement], this.exprAllowed = true, this.containsEsc = false, this.strictErrors = /* @__PURE__ */ new Map(), this.exportedIdentifiers = [], this.tokensLength = 0;
        }
        init(t2) {
          this.strict = false !== t2.strictMode && "module" === t2.sourceType, this.curLine = t2.startLine, this.startLoc = this.endLoc = this.curPosition();
        }
        curPosition() {
          return new Vi(this.curLine, this.pos - this.lineStart);
        }
        clone(t2) {
          const e2 = new Za(), s2 = Object.keys(this);
          for (let r2 = 0, i2 = s2.length; r2 < i2; r2++) {
            const i3 = s2[r2];
            let a2 = this[i3];
            !t2 && Array.isArray(a2) && (a2 = a2.slice()), e2[i3] = a2;
          }
          return e2;
        }
      }
      var tn = function(t2) {
        return t2 >= 48 && t2 <= 57;
      };
      const en = /* @__PURE__ */ new Set(["g", "m", "s", "i", "y", "u"]), sn = {
        decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
        hex: [46, 88, 95, 120]
      }, rn = {
        bin: [48, 49]
      };
      rn.oct = [...rn.bin, 50, 51, 52, 53, 54, 55], rn.dec = [...rn.oct, 56, 57], rn.hex = [...rn.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
      class an {
        constructor(t2) {
          this.type = t2.type, this.value = t2.value, this.start = t2.start, this.end = t2.end, this.loc = new Hi(t2.startLoc, t2.endLoc);
        }
      }
      class nn {
        constructor() {
          this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        }
      }
      class on {
        constructor(t2) {
          this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.raise = t2;
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new nn());
        }
        exit() {
          const t2 = this.stack.pop(), e2 = this.current();
          for (const [s2, r2] of Array.from(t2.undefinedPrivateNames))
            e2 ? e2.undefinedPrivateNames.has(s2) || e2.undefinedPrivateNames.set(s2, r2) : this.raise(r2, Gi.InvalidPrivateFieldResolution, s2);
        }
        declarePrivateName(t2, e2, s2) {
          const r2 = this.current();
          let i2 = r2.privateNames.has(t2);
          if (3 & e2) {
            const s3 = i2 && r2.loneAccessors.get(t2);
            if (s3) {
              const a2 = 4 & s3, n2 = 4 & e2;
              i2 = (3 & s3) === (3 & e2) || a2 !== n2, i2 || r2.loneAccessors.delete(t2);
            } else
              i2 || r2.loneAccessors.set(t2, e2);
          }
          i2 && this.raise(s2, Gi.PrivateNameRedeclaration, t2), r2.privateNames.add(t2), r2.undefinedPrivateNames.delete(t2);
        }
        usePrivateName(t2, e2) {
          let s2;
          for (s2 of this.stack)
            if (s2.privateNames.has(t2))
              return;
          s2 ? s2.undefinedPrivateNames.set(t2, e2) : this.raise(e2, Gi.InvalidPrivateFieldResolution, t2);
        }
      }
      class un {
        constructor(t2 = 0) {
          this.type = void 0, this.type = t2;
        }
        canBeArrowParameterDeclaration() {
          return 2 === this.type || 1 === this.type;
        }
        isCertainlyParameterDeclaration() {
          return 3 === this.type;
        }
      }
      class hn extends un {
        constructor(t2) {
          super(t2), this.errors = /* @__PURE__ */ new Map();
        }
        recordDeclarationError(t2, e2) {
          this.errors.set(t2, e2);
        }
        clearDeclarationError(t2) {
          this.errors.delete(t2);
        }
        iterateErrors(t2) {
          this.errors.forEach(t2);
        }
      }
      class cn {
        constructor(t2) {
          this.stack = [new un()], this.raise = t2;
        }
        enter(t2) {
          this.stack.push(t2);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(t2, e2) {
          const {
            stack: s2
          } = this;
          let r2 = s2.length - 1, i2 = s2[r2];
          for (; !i2.isCertainlyParameterDeclaration(); ) {
            if (!i2.canBeArrowParameterDeclaration())
              return;
            i2.recordDeclarationError(t2, e2), i2 = s2[--r2];
          }
          this.raise(t2, e2);
        }
        recordParenthesizedIdentifierError(t2, e2) {
          const {
            stack: s2
          } = this, r2 = s2[s2.length - 1];
          if (r2.isCertainlyParameterDeclaration())
            this.raise(t2, e2);
          else {
            if (!r2.canBeArrowParameterDeclaration())
              return;
            r2.recordDeclarationError(t2, e2);
          }
        }
        recordAsyncArrowParametersError(t2, e2) {
          const {
            stack: s2
          } = this;
          let r2 = s2.length - 1, i2 = s2[r2];
          for (; i2.canBeArrowParameterDeclaration(); )
            2 === i2.type && i2.recordDeclarationError(t2, e2), i2 = s2[--r2];
        }
        validateAsPattern() {
          const {
            stack: t2
          } = this, e2 = t2[t2.length - 1];
          e2.canBeArrowParameterDeclaration() && e2.iterateErrors((e3, s2) => {
            this.raise(s2, e3);
            let r2 = t2.length - 2, i2 = t2[r2];
            for (; i2.canBeArrowParameterDeclaration(); )
              i2.clearDeclarationError(s2), i2 = t2[--r2];
          });
        }
      }
      function pn() {
        return new un();
      }
      class ln {
        constructor() {
          this.shorthandAssign = -1, this.doubleProto = -1;
        }
      }
      class dn {
        constructor(t2, e2, s2) {
          this.type = void 0, this.start = void 0, this.end = void 0, this.loc = void 0, this.range = void 0, this.leadingComments = void 0, this.trailingComments = void 0, this.innerComments = void 0, this.extra = void 0, this.type = "", this.start = e2, this.end = 0, this.loc = new Hi(s2), null != t2 && t2.options.ranges && (this.range = [e2, 0]), null != t2 && t2.filename && (this.loc.filename = t2.filename);
        }
        __clone() {
          const t2 = new dn(), e2 = Object.keys(this);
          for (let s2 = 0, r2 = e2.length; s2 < r2; s2++) {
            const r3 = e2[s2];
            "leadingComments" !== r3 && "trailingComments" !== r3 && "innerComments" !== r3 && (t2[r3] = this[r3]);
          }
          return t2;
        }
      }
      const Dn = (t2) => "ParenthesizedExpression" === t2.type ? Dn(t2.expression) : t2;
      const mn = {
        kind: "loop"
      }, fn = {
        kind: "switch"
      }, yn = /[\uD800-\uDFFF]/u;
      class An extends class extends class extends class extends class extends class extends class extends class extends class extends class {
        constructor() {
          this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
        }
        hasPlugin(t2) {
          return this.plugins.has(t2);
        }
        getPluginOption(t2, e2) {
          if (this.hasPlugin(t2))
            return this.plugins.get(t2)[e2];
        }
      } {
        addComment(t2) {
          this.filename && (t2.loc.filename = this.filename), this.state.trailingComments.push(t2), this.state.leadingComments.push(t2);
        }
        adjustCommentsAfterTrailingComma(t2, e2, s2) {
          if (0 === this.state.leadingComments.length)
            return;
          let r2 = null, i2 = e2.length;
          for (; null === r2 && i2 > 0; )
            r2 = e2[--i2];
          if (null === r2)
            return;
          for (let t3 = 0; t3 < this.state.leadingComments.length; t3++)
            this.state.leadingComments[t3].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(t3, 1), t3--);
          const a2 = [];
          for (let e3 = 0; e3 < this.state.leadingComments.length; e3++) {
            const r3 = this.state.leadingComments[e3];
            r3.end < t2.end ? (a2.push(r3), s2 || (this.state.leadingComments.splice(e3, 1), e3--)) : (void 0 === t2.trailingComments && (t2.trailingComments = []), t2.trailingComments.push(r3));
          }
          s2 && (this.state.leadingComments = []), a2.length > 0 ? r2.trailingComments = a2 : void 0 !== r2.trailingComments && (r2.trailingComments = []);
        }
        processComment(t2) {
          if ("Program" === t2.type && t2.body.length > 0)
            return;
          const e2 = this.state.commentStack;
          let s2, r2, i2, a2, n2;
          if (this.state.trailingComments.length > 0)
            this.state.trailingComments[0].start >= t2.end ? (i2 = this.state.trailingComments, this.state.trailingComments = []) : this.state.trailingComments.length = 0;
          else if (e2.length > 0) {
            const s3 = zi(e2);
            s3.trailingComments && s3.trailingComments[0].start >= t2.end && (i2 = s3.trailingComments, delete s3.trailingComments);
          }
          for (e2.length > 0 && zi(e2).start >= t2.start && (s2 = e2.pop()); e2.length > 0 && zi(e2).start >= t2.start; )
            r2 = e2.pop();
          if (!r2 && s2 && (r2 = s2), s2)
            switch (t2.type) {
              case "ObjectExpression":
                this.adjustCommentsAfterTrailingComma(t2, t2.properties);
                break;
              case "ObjectPattern":
                this.adjustCommentsAfterTrailingComma(t2, t2.properties, true);
                break;
              case "CallExpression":
                this.adjustCommentsAfterTrailingComma(t2, t2.arguments);
                break;
              case "ArrayExpression":
                this.adjustCommentsAfterTrailingComma(t2, t2.elements);
                break;
              case "ArrayPattern":
                this.adjustCommentsAfterTrailingComma(t2, t2.elements, true);
            }
          else
            this.state.commentPreviousNode && ("ImportSpecifier" === this.state.commentPreviousNode.type && "ImportSpecifier" !== t2.type || "ExportSpecifier" === this.state.commentPreviousNode.type && "ExportSpecifier" !== t2.type) && this.adjustCommentsAfterTrailingComma(t2, [this.state.commentPreviousNode]);
          if (r2) {
            if (r2.leadingComments) {
              if (r2 !== t2 && r2.leadingComments.length > 0 && zi(r2.leadingComments).end <= t2.start)
                t2.leadingComments = r2.leadingComments, delete r2.leadingComments;
              else
                for (a2 = r2.leadingComments.length - 2; a2 >= 0; --a2)
                  if (r2.leadingComments[a2].end <= t2.start) {
                    t2.leadingComments = r2.leadingComments.splice(0, a2 + 1);
                    break;
                  }
            }
          } else if (this.state.leadingComments.length > 0)
            if (zi(this.state.leadingComments).end <= t2.start) {
              if (this.state.commentPreviousNode)
                for (n2 = 0; n2 < this.state.leadingComments.length; n2++)
                  this.state.leadingComments[n2].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(n2, 1), n2--);
              this.state.leadingComments.length > 0 && (t2.leadingComments = this.state.leadingComments, this.state.leadingComments = []);
            } else {
              for (a2 = 0; a2 < this.state.leadingComments.length && !(this.state.leadingComments[a2].end > t2.start); a2++)
                ;
              const e3 = this.state.leadingComments.slice(0, a2);
              e3.length && (t2.leadingComments = e3), i2 = this.state.leadingComments.slice(a2), 0 === i2.length && (i2 = null);
            }
          if (this.state.commentPreviousNode = t2, i2)
            if (i2.length && i2[0].start >= t2.start && zi(i2).end <= t2.end)
              t2.innerComments = i2;
            else {
              const e3 = i2.findIndex((e4) => e4.end >= t2.end);
              e3 > 0 ? (t2.innerComments = i2.slice(0, e3), t2.trailingComments = i2.slice(e3)) : t2.trailingComments = i2;
            }
          e2.push(t2);
        }
      } {
        getLocationForPosition(t2) {
          let e2;
          return e2 = t2 === this.state.start ? this.state.startLoc : t2 === this.state.lastTokStart ? this.state.lastTokStartLoc : t2 === this.state.end ? this.state.endLoc : t2 === this.state.lastTokEnd ? this.state.lastTokEndLoc : function(t3, e3) {
            let s2, r2 = 1, i2 = 0;
            for (ji.lastIndex = 0; (s2 = ji.exec(t3)) && s2.index < e3; )
              r2++, i2 = ji.lastIndex;
            return new Vi(r2, e3 - i2);
          }(this.input, t2), e2;
        }
        raise(t2, {
          code: e2,
          reasonCode: s2,
          template: r2
        }, ...i2) {
          return this.raiseWithData(t2, {
            code: e2,
            reasonCode: s2
          }, r2, ...i2);
        }
        raiseOverwrite(t2, {
          code: e2,
          template: s2
        }, ...r2) {
          const i2 = this.getLocationForPosition(t2), a2 = s2.replace(/%(\d+)/g, (t3, e3) => r2[e3]) + " (".concat(i2.line, ":").concat(i2.column, ")");
          if (this.options.errorRecovery) {
            const e3 = this.state.errors;
            for (let s3 = e3.length - 1; s3 >= 0; s3--) {
              const r3 = e3[s3];
              if (r3.pos === t2)
                return Object.assign(r3, {
                  message: a2
                });
              if (r3.pos < t2)
                break;
            }
          }
          return this._raise({
            code: e2,
            loc: i2,
            pos: t2
          }, a2);
        }
        raiseWithData(t2, e2, s2, ...r2) {
          const i2 = this.getLocationForPosition(t2), a2 = s2.replace(/%(\d+)/g, (t3, e3) => r2[e3]) + " (".concat(i2.line, ":").concat(i2.column, ")");
          return this._raise(Object.assign({
            loc: i2,
            pos: t2
          }, e2), a2);
        }
        _raise(t2, e2) {
          const s2 = new SyntaxError(e2);
          if (Object.assign(s2, t2), this.options.errorRecovery)
            return this.isLookahead || this.state.errors.push(s2), s2;
          throw s2;
        }
      } {
        constructor(t2, e2) {
          super(), this.isLookahead = void 0, this.tokens = [], this.state = new Za(), this.state.init(t2), this.input = e2, this.length = e2.length, this.isLookahead = false;
        }
        pushToken(t2) {
          this.tokens.length = this.state.tokensLength, this.tokens.push(t2), ++this.state.tokensLength;
        }
        next() {
          this.isLookahead || (this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new an(this.state))), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
        }
        eat(t2) {
          return !!this.match(t2) && (this.next(), true);
        }
        match(t2) {
          return this.state.type === t2;
        }
        lookahead() {
          const t2 = this.state;
          this.state = t2.clone(true), this.isLookahead = true, this.next(), this.isLookahead = false;
          const e2 = this.state;
          return this.state = t2, e2;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(t2) {
          Ui.lastIndex = t2;
          return t2 + Ui.exec(this.input)[0].length;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        setStrict(t2) {
          this.state.strict = t2, t2 && (this.state.strictErrors.forEach((t3, e2) => this.raise(e2, t3)), this.state.strictErrors.clear());
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          const t2 = this.curContext();
          if (null != t2 && t2.preserveSpace || this.skipSpace(), this.state.start = this.state.pos, this.state.startLoc = this.state.curPosition(), this.state.pos >= this.length)
            return void this.finishToken(Mi.eof);
          const e2 = null == t2 ? void 0 : t2.override;
          e2 ? e2(this) : this.getTokenFromCode(this.input.codePointAt(this.state.pos));
        }
        pushComment(t2, e2, s2, r2, i2, a2) {
          const n2 = {
            type: t2 ? "CommentBlock" : "CommentLine",
            value: e2,
            start: s2,
            end: r2,
            loc: new Hi(i2, a2)
          };
          this.options.tokens && this.pushToken(n2), this.state.comments.push(n2), this.addComment(n2);
        }
        skipBlockComment() {
          const t2 = this.state.curPosition(), e2 = this.state.pos, s2 = this.input.indexOf("*/", this.state.pos + 2);
          if (-1 === s2)
            throw this.raise(e2, Gi.UnterminatedComment);
          let r2;
          for (this.state.pos = s2 + 2, ji.lastIndex = e2; (r2 = ji.exec(this.input)) && r2.index < this.state.pos; )
            ++this.state.curLine, this.state.lineStart = r2.index + r2[0].length;
          this.isLookahead || this.pushComment(true, this.input.slice(e2 + 2, s2), e2, this.state.pos, t2, this.state.curPosition());
        }
        skipLineComment(t2) {
          const e2 = this.state.pos, s2 = this.state.curPosition();
          let r2 = this.input.charCodeAt(this.state.pos += t2);
          if (this.state.pos < this.length)
            for (; !_i(r2) && ++this.state.pos < this.length; )
              r2 = this.input.charCodeAt(this.state.pos);
          this.isLookahead || this.pushComment(false, this.input.slice(e2 + t2, this.state.pos), e2, this.state.pos, s2, this.state.curPosition());
        }
        skipSpace() {
          t:
            for (; this.state.pos < this.length; ) {
              const t2 = this.input.charCodeAt(this.state.pos);
              switch (t2) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42:
                      this.skipBlockComment();
                      break;
                    case 47:
                      this.skipLineComment(2);
                      break;
                    default:
                      break t;
                  }
                  break;
                default:
                  if (!qi(t2))
                    break t;
                  ++this.state.pos;
              }
            }
        }
        finishToken(t2, e2) {
          this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
          const s2 = this.state.type;
          this.state.type = t2, this.state.value = e2, this.isLookahead || this.updateContext(s2);
        }
        readToken_numberSign() {
          if (0 === this.state.pos && this.readToken_interpreter())
            return;
          const t2 = this.state.pos + 1, e2 = this.input.charCodeAt(t2);
          if (e2 >= 48 && e2 <= 57)
            throw this.raise(this.state.pos, Gi.UnexpectedDigitAfterHash);
          if (123 === e2 || 91 === e2 && this.hasPlugin("recordAndTuple")) {
            if (this.expectPlugin("recordAndTuple"), "hash" !== this.getPluginOption("recordAndTuple", "syntaxType"))
              throw this.raise(this.state.pos, 123 === e2 ? Gi.RecordExpressionHashIncorrectStartSyntaxType : Gi.TupleExpressionHashIncorrectStartSyntaxType);
            123 === e2 ? this.finishToken(Mi.braceHashL) : this.finishToken(Mi.bracketHashL), this.state.pos += 2;
          } else
            this.finishOp(Mi.hash, 1);
        }
        readToken_dot() {
          const t2 = this.input.charCodeAt(this.state.pos + 1);
          t2 >= 48 && t2 <= 57 ? this.readNumber(true) : 46 === t2 && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(Mi.ellipsis)) : (++this.state.pos, this.finishToken(Mi.dot));
        }
        readToken_slash() {
          if (this.state.exprAllowed && !this.state.inType)
            return ++this.state.pos, void this.readRegexp();
          61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(Mi.assign, 2) : this.finishOp(Mi.slash, 1);
        }
        readToken_interpreter() {
          if (0 !== this.state.pos || this.length < 2)
            return false;
          let t2 = this.input.charCodeAt(this.state.pos + 1);
          if (33 !== t2)
            return false;
          const e2 = this.state.pos;
          for (this.state.pos += 1; !_i(t2) && ++this.state.pos < this.length; )
            t2 = this.input.charCodeAt(this.state.pos);
          const s2 = this.input.slice(e2 + 2, this.state.pos);
          return this.finishToken(Mi.interpreterDirective, s2), true;
        }
        readToken_mult_modulo(t2) {
          let e2 = 42 === t2 ? Mi.star : Mi.modulo, s2 = 1, r2 = this.input.charCodeAt(this.state.pos + 1);
          const i2 = this.state.exprAllowed;
          42 === t2 && 42 === r2 && (s2++, r2 = this.input.charCodeAt(this.state.pos + 2), e2 = Mi.exponent), 61 !== r2 || i2 || (s2++, e2 = Mi.assign), this.finishOp(e2, s2);
        }
        readToken_pipe_amp(t2) {
          const e2 = this.input.charCodeAt(this.state.pos + 1);
          if (e2 !== t2) {
            if (124 === t2) {
              if (62 === e2)
                return void this.finishOp(Mi.pipeline, 2);
              if (this.hasPlugin("recordAndTuple") && 125 === e2) {
                if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                  throw this.raise(this.state.pos, Gi.RecordExpressionBarIncorrectEndSyntaxType);
                return void this.finishOp(Mi.braceBarR, 2);
              }
              if (this.hasPlugin("recordAndTuple") && 93 === e2) {
                if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                  throw this.raise(this.state.pos, Gi.TupleExpressionBarIncorrectEndSyntaxType);
                return void this.finishOp(Mi.bracketBarR, 2);
              }
            }
            61 !== e2 ? this.finishOp(124 === t2 ? Mi.bitwiseOR : Mi.bitwiseAND, 1) : this.finishOp(Mi.assign, 2);
          } else
            61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(Mi.assign, 3) : this.finishOp(124 === t2 ? Mi.logicalOR : Mi.logicalAND, 2);
        }
        readToken_caret() {
          61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(Mi.assign, 2) : this.finishOp(Mi.bitwiseXOR, 1);
        }
        readToken_plus_min(t2) {
          const e2 = this.input.charCodeAt(this.state.pos + 1);
          if (e2 === t2)
            return 45 !== e2 || this.inModule || 62 !== this.input.charCodeAt(this.state.pos + 2) || 0 !== this.state.lastTokEnd && !this.hasPrecedingLineBreak() ? void this.finishOp(Mi.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), void this.nextToken());
          61 === e2 ? this.finishOp(Mi.assign, 2) : this.finishOp(Mi.plusMin, 1);
        }
        readToken_lt_gt(t2) {
          const e2 = this.input.charCodeAt(this.state.pos + 1);
          let s2 = 1;
          return e2 === t2 ? (s2 = 62 === t2 && 62 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.state.pos + s2) ? void this.finishOp(Mi.assign, s2 + 1) : void this.finishOp(Mi.bitShift, s2)) : 33 !== e2 || 60 !== t2 || this.inModule || 45 !== this.input.charCodeAt(this.state.pos + 2) || 45 !== this.input.charCodeAt(this.state.pos + 3) ? (61 === e2 && (s2 = 2), void this.finishOp(Mi.relational, s2)) : (this.skipLineComment(4), this.skipSpace(), void this.nextToken());
        }
        readToken_eq_excl(t2) {
          const e2 = this.input.charCodeAt(this.state.pos + 1);
          if (61 !== e2)
            return 61 === t2 && 62 === e2 ? (this.state.pos += 2, void this.finishToken(Mi.arrow)) : void this.finishOp(61 === t2 ? Mi.eq : Mi.bang, 1);
          this.finishOp(Mi.equality, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
        }
        readToken_question() {
          const t2 = this.input.charCodeAt(this.state.pos + 1), e2 = this.input.charCodeAt(this.state.pos + 2);
          63 === t2 ? 61 === e2 ? this.finishOp(Mi.assign, 3) : this.finishOp(Mi.nullishCoalescing, 2) : 46 !== t2 || e2 >= 48 && e2 <= 57 ? (++this.state.pos, this.finishToken(Mi.question)) : (this.state.pos += 2, this.finishToken(Mi.questionDot));
        }
        getTokenFromCode(t2) {
          switch (t2) {
            case 46:
              return void this.readToken_dot();
            case 40:
              return ++this.state.pos, void this.finishToken(Mi.parenL);
            case 41:
              return ++this.state.pos, void this.finishToken(Mi.parenR);
            case 59:
              return ++this.state.pos, void this.finishToken(Mi.semi);
            case 44:
              return ++this.state.pos, void this.finishToken(Mi.comma);
            case 91:
              if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                  throw this.raise(this.state.pos, Gi.TupleExpressionBarIncorrectStartSyntaxType);
                this.finishToken(Mi.bracketBarL), this.state.pos += 2;
              } else
                ++this.state.pos, this.finishToken(Mi.bracketL);
              return;
            case 93:
              return ++this.state.pos, void this.finishToken(Mi.bracketR);
            case 123:
              if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType"))
                  throw this.raise(this.state.pos, Gi.RecordExpressionBarIncorrectStartSyntaxType);
                this.finishToken(Mi.braceBarL), this.state.pos += 2;
              } else
                ++this.state.pos, this.finishToken(Mi.braceL);
              return;
            case 125:
              return ++this.state.pos, void this.finishToken(Mi.braceR);
            case 58:
              return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(Mi.doubleColon, 2) : (++this.state.pos, this.finishToken(Mi.colon)));
            case 63:
              return void this.readToken_question();
            case 96:
              return ++this.state.pos, void this.finishToken(Mi.backQuote);
            case 48: {
              const t3 = this.input.charCodeAt(this.state.pos + 1);
              if (120 === t3 || 88 === t3)
                return void this.readRadixNumber(16);
              if (111 === t3 || 79 === t3)
                return void this.readRadixNumber(8);
              if (98 === t3 || 66 === t3)
                return void this.readRadixNumber(2);
            }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return void this.readNumber(false);
            case 34:
            case 39:
              return void this.readString(t2);
            case 47:
              return void this.readToken_slash();
            case 37:
            case 42:
              return void this.readToken_mult_modulo(t2);
            case 124:
            case 38:
              return void this.readToken_pipe_amp(t2);
            case 94:
              return void this.readToken_caret();
            case 43:
            case 45:
              return void this.readToken_plus_min(t2);
            case 60:
            case 62:
              return void this.readToken_lt_gt(t2);
            case 61:
            case 33:
              return void this.readToken_eq_excl(t2);
            case 126:
              return void this.finishOp(Mi.tilde, 1);
            case 64:
              return ++this.state.pos, void this.finishToken(Mi.at);
            case 35:
              return void this.readToken_numberSign();
            case 92:
              return void this.readWord();
            default:
              if (ia(t2))
                return void this.readWord();
          }
          throw this.raise(this.state.pos, Gi.InvalidOrUnexpectedToken, String.fromCodePoint(t2));
        }
        finishOp(t2, e2) {
          const s2 = this.input.slice(this.state.pos, this.state.pos + e2);
          this.state.pos += e2, this.finishToken(t2, s2);
        }
        readRegexp() {
          const t2 = this.state.pos;
          let e2, s2;
          for (; ; ) {
            if (this.state.pos >= this.length)
              throw this.raise(t2, Gi.UnterminatedRegExp);
            const r3 = this.input.charAt(this.state.pos);
            if (Ri.test(r3))
              throw this.raise(t2, Gi.UnterminatedRegExp);
            if (e2)
              e2 = false;
            else {
              if ("[" === r3)
                s2 = true;
              else if ("]" === r3 && s2)
                s2 = false;
              else if ("/" === r3 && !s2)
                break;
              e2 = "\\" === r3;
            }
            ++this.state.pos;
          }
          const r2 = this.input.slice(t2, this.state.pos);
          ++this.state.pos;
          let i2 = "";
          for (; this.state.pos < this.length; ) {
            const t3 = this.input[this.state.pos], e3 = this.input.codePointAt(this.state.pos);
            if (en.has(t3))
              i2.indexOf(t3) > -1 && this.raise(this.state.pos + 1, Gi.DuplicateRegExpFlags);
            else {
              if (!aa(e3) && 92 !== e3)
                break;
              this.raise(this.state.pos + 1, Gi.MalformedRegExpFlags);
            }
            ++this.state.pos, i2 += t3;
          }
          this.finishToken(Mi.regexp, {
            pattern: r2,
            flags: i2
          });
        }
        readInt(t2, e2, s2, r2 = true) {
          const i2 = this.state.pos, a2 = 16 === t2 ? sn.hex : sn.decBinOct, n2 = 16 === t2 ? rn.hex : 10 === t2 ? rn.dec : 8 === t2 ? rn.oct : rn.bin;
          let o2 = false, u2 = 0;
          for (let i3 = 0, h2 = null == e2 ? 1 / 0 : e2; i3 < h2; ++i3) {
            const e3 = this.input.charCodeAt(this.state.pos);
            let h3;
            if (95 !== e3) {
              if (h3 = e3 >= 97 ? e3 - 97 + 10 : e3 >= 65 ? e3 - 65 + 10 : tn(e3) ? e3 - 48 : 1 / 0, h3 >= t2)
                if (this.options.errorRecovery && h3 <= 9)
                  h3 = 0, this.raise(this.state.start + i3 + 2, Gi.InvalidDigit, t2);
                else {
                  if (!s2)
                    break;
                  h3 = 0, o2 = true;
                }
              ++this.state.pos, u2 = u2 * t2 + h3;
            } else {
              const t3 = this.input.charCodeAt(this.state.pos - 1), e4 = this.input.charCodeAt(this.state.pos + 1);
              (-1 === n2.indexOf(e4) || a2.indexOf(t3) > -1 || a2.indexOf(e4) > -1 || Number.isNaN(e4)) && this.raise(this.state.pos, Gi.UnexpectedNumericSeparator), r2 || this.raise(this.state.pos, Gi.NumericSeparatorInEscapeSequence), ++this.state.pos;
            }
          }
          return this.state.pos === i2 || null != e2 && this.state.pos - i2 !== e2 || o2 ? null : u2;
        }
        readRadixNumber(t2) {
          const e2 = this.state.pos;
          let s2 = false;
          this.state.pos += 2;
          const r2 = this.readInt(t2);
          null == r2 && this.raise(this.state.start + 2, Gi.InvalidDigit, t2);
          const i2 = this.input.charCodeAt(this.state.pos);
          if (110 === i2)
            ++this.state.pos, s2 = true;
          else if (109 === i2)
            throw this.raise(e2, Gi.InvalidDecimal);
          if (ia(this.input.codePointAt(this.state.pos)))
            throw this.raise(this.state.pos, Gi.NumberIdentifier);
          if (s2) {
            const t3 = this.input.slice(e2, this.state.pos).replace(/[_n]/g, "");
            this.finishToken(Mi.bigint, t3);
          } else
            this.finishToken(Mi.num, r2);
        }
        readNumber(t2) {
          const e2 = this.state.pos;
          let s2 = false, r2 = false, i2 = false, a2 = false, n2 = false;
          t2 || null !== this.readInt(10) || this.raise(e2, Gi.InvalidNumber);
          const o2 = this.state.pos - e2 >= 2 && 48 === this.input.charCodeAt(e2);
          if (o2) {
            const t3 = this.input.slice(e2, this.state.pos);
            if (this.recordStrictModeErrors(e2, Gi.StrictOctalLiteral), !this.state.strict) {
              const s3 = t3.indexOf("_");
              s3 > 0 && this.raise(s3 + e2, Gi.ZeroDigitNumericSeparator);
            }
            n2 = o2 && !/[89]/.test(t3);
          }
          let u2 = this.input.charCodeAt(this.state.pos);
          if (46 !== u2 || n2 || (++this.state.pos, this.readInt(10), s2 = true, u2 = this.input.charCodeAt(this.state.pos)), 69 !== u2 && 101 !== u2 || n2 || (u2 = this.input.charCodeAt(++this.state.pos), 43 !== u2 && 45 !== u2 || ++this.state.pos, null === this.readInt(10) && this.raise(e2, Gi.InvalidOrMissingExponent), s2 = true, a2 = true, u2 = this.input.charCodeAt(this.state.pos)), 110 === u2 && ((s2 || o2) && this.raise(e2, Gi.InvalidBigIntLiteral), ++this.state.pos, r2 = true), 109 === u2 && (this.expectPlugin("decimal", this.state.pos), (a2 || o2) && this.raise(e2, Gi.InvalidDecimal), ++this.state.pos, i2 = true), ia(this.input.codePointAt(this.state.pos)))
            throw this.raise(this.state.pos, Gi.NumberIdentifier);
          const h2 = this.input.slice(e2, this.state.pos).replace(/[_mn]/g, "");
          if (r2)
            return void this.finishToken(Mi.bigint, h2);
          if (i2)
            return void this.finishToken(Mi.decimal, h2);
          const c2 = n2 ? parseInt(h2, 8) : parseFloat(h2);
          this.finishToken(Mi.num, c2);
        }
        readCodePoint(t2) {
          let e2;
          if (123 === this.input.charCodeAt(this.state.pos)) {
            const s2 = ++this.state.pos;
            if (e2 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, t2), ++this.state.pos, null !== e2 && e2 > 1114111) {
              if (!t2)
                return null;
              this.raise(s2, Gi.InvalidCodePoint);
            }
          } else
            e2 = this.readHexChar(4, false, t2);
          return e2;
        }
        readString(t2) {
          let e2 = "", s2 = ++this.state.pos;
          for (; ; ) {
            if (this.state.pos >= this.length)
              throw this.raise(this.state.start, Gi.UnterminatedString);
            const r2 = this.input.charCodeAt(this.state.pos);
            if (r2 === t2)
              break;
            if (92 === r2)
              e2 += this.input.slice(s2, this.state.pos), e2 += this.readEscapedChar(false), s2 = this.state.pos;
            else if (8232 === r2 || 8233 === r2)
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            else {
              if (_i(r2))
                throw this.raise(this.state.start, Gi.UnterminatedString);
              ++this.state.pos;
            }
          }
          e2 += this.input.slice(s2, this.state.pos++), this.finishToken(Mi.string, e2);
        }
        readTmplToken() {
          let t2 = "", e2 = this.state.pos, s2 = false;
          for (; ; ) {
            if (this.state.pos >= this.length)
              throw this.raise(this.state.start, Gi.UnterminatedTemplate);
            const r2 = this.input.charCodeAt(this.state.pos);
            if (96 === r2 || 36 === r2 && 123 === this.input.charCodeAt(this.state.pos + 1))
              return this.state.pos === this.state.start && this.match(Mi.template) ? 36 === r2 ? (this.state.pos += 2, void this.finishToken(Mi.dollarBraceL)) : (++this.state.pos, void this.finishToken(Mi.backQuote)) : (t2 += this.input.slice(e2, this.state.pos), void this.finishToken(Mi.template, s2 ? null : t2));
            if (92 === r2) {
              t2 += this.input.slice(e2, this.state.pos);
              const r3 = this.readEscapedChar(true);
              null === r3 ? s2 = true : t2 += r3, e2 = this.state.pos;
            } else if (_i(r2)) {
              switch (t2 += this.input.slice(e2, this.state.pos), ++this.state.pos, r2) {
                case 13:
                  10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;
                case 10:
                  t2 += "\n";
                  break;
                default:
                  t2 += String.fromCharCode(r2);
              }
              ++this.state.curLine, this.state.lineStart = this.state.pos, e2 = this.state.pos;
            } else
              ++this.state.pos;
          }
        }
        recordStrictModeErrors(t2, e2) {
          this.state.strict && !this.state.strictErrors.has(t2) ? this.raise(t2, e2) : this.state.strictErrors.set(t2, e2);
        }
        readEscapedChar(t2) {
          const e2 = !t2, s2 = this.input.charCodeAt(++this.state.pos);
          switch (++this.state.pos, s2) {
            case 110:
              return "\n";
            case 114:
              return "\r";
            case 120: {
              const t3 = this.readHexChar(2, false, e2);
              return null === t3 ? null : String.fromCharCode(t3);
            }
            case 117: {
              const t3 = this.readCodePoint(e2);
              return null === t3 ? null : String.fromCodePoint(t3);
            }
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;
            case 10:
              this.state.lineStart = this.state.pos, ++this.state.curLine;
            case 8232:
            case 8233:
              return "";
            case 56:
            case 57:
              if (t2)
                return null;
              this.recordStrictModeErrors(this.state.pos - 1, Gi.StrictNumericEscape);
            default:
              if (s2 >= 48 && s2 <= 55) {
                const e3 = this.state.pos - 1;
                let s3 = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], r2 = parseInt(s3, 8);
                r2 > 255 && (s3 = s3.slice(0, -1), r2 = parseInt(s3, 8)), this.state.pos += s3.length - 1;
                const i2 = this.input.charCodeAt(this.state.pos);
                if ("0" !== s3 || 56 === i2 || 57 === i2) {
                  if (t2)
                    return null;
                  this.recordStrictModeErrors(e3, Gi.StrictNumericEscape);
                }
                return String.fromCharCode(r2);
              }
              return String.fromCharCode(s2);
          }
        }
        readHexChar(t2, e2, s2) {
          const r2 = this.state.pos, i2 = this.readInt(16, t2, e2, false);
          return null === i2 && (s2 ? this.raise(r2, Gi.InvalidEscapeSequence) : this.state.pos = r2 - 1), i2;
        }
        readWord1() {
          let t2 = "";
          this.state.containsEsc = false;
          const e2 = this.state.pos;
          let s2 = this.state.pos;
          for (; this.state.pos < this.length; ) {
            const r2 = this.input.codePointAt(this.state.pos);
            if (aa(r2))
              this.state.pos += r2 <= 65535 ? 1 : 2;
            else if (this.state.isIterator && 64 === r2)
              ++this.state.pos;
            else {
              if (92 !== r2)
                break;
              {
                this.state.containsEsc = true, t2 += this.input.slice(s2, this.state.pos);
                const r3 = this.state.pos, i2 = this.state.pos === e2 ? ia : aa;
                if (117 !== this.input.charCodeAt(++this.state.pos)) {
                  this.raise(this.state.pos, Gi.MissingUnicodeEscape);
                  continue;
                }
                ++this.state.pos;
                const a2 = this.readCodePoint(true);
                null !== a2 && (i2(a2) || this.raise(r3, Gi.EscapedCharNotAnIdentifier), t2 += String.fromCodePoint(a2)), s2 = this.state.pos;
              }
            }
          }
          return t2 + this.input.slice(s2, this.state.pos);
        }
        isIterator(t2) {
          return "@@iterator" === t2 || "@@asyncIterator" === t2;
        }
        readWord() {
          const t2 = this.readWord1(), e2 = ki.get(t2) || Mi.name;
          !this.state.isIterator || this.isIterator(t2) && this.state.inType || this.raise(this.state.pos, Gi.InvalidIdentifier, t2), this.finishToken(e2, t2);
        }
        checkKeywordEscapes() {
          const t2 = this.state.type.keyword;
          t2 && this.state.containsEsc && this.raise(this.state.start, Gi.InvalidEscapedReservedWord, t2);
        }
        braceIsBlock(t2) {
          const e2 = this.curContext();
          return e2 === $i.functionExpression || e2 === $i.functionStatement || (t2 !== Mi.colon || e2 !== $i.braceStatement && e2 !== $i.braceExpression ? t2 === Mi._return || t2 === Mi.name && this.state.exprAllowed ? this.hasPrecedingLineBreak() : t2 === Mi._else || t2 === Mi.semi || t2 === Mi.eof || t2 === Mi.parenR || t2 === Mi.arrow || (t2 === Mi.braceL ? e2 === $i.braceStatement : t2 !== Mi._var && t2 !== Mi._const && t2 !== Mi.name && (t2 === Mi.relational || !this.state.exprAllowed)) : !e2.isExpr);
        }
        updateContext(t2) {
          const e2 = this.state.type;
          let s2;
          !e2.keyword || t2 !== Mi.dot && t2 !== Mi.questionDot ? (s2 = e2.updateContext) ? s2.call(this, t2) : this.state.exprAllowed = e2.beforeExpr : this.state.exprAllowed = false;
        }
      } {
        addExtra(t2, e2, s2) {
          if (!t2)
            return;
          (t2.extra = t2.extra || {})[e2] = s2;
        }
        isRelational(t2) {
          return this.match(Mi.relational) && this.state.value === t2;
        }
        expectRelational(t2) {
          this.isRelational(t2) ? this.next() : this.unexpected(null, Mi.relational);
        }
        isContextual(t2) {
          return this.match(Mi.name) && this.state.value === t2 && !this.state.containsEsc;
        }
        isUnparsedContextual(t2, e2) {
          const s2 = t2 + e2.length;
          return this.input.slice(t2, s2) === e2 && (s2 === this.input.length || !aa(this.input.charCodeAt(s2)));
        }
        isLookaheadContextual(t2) {
          const e2 = this.nextTokenStart();
          return this.isUnparsedContextual(e2, t2);
        }
        eatContextual(t2) {
          return this.isContextual(t2) && this.eat(Mi.name);
        }
        expectContextual(t2, e2) {
          this.eatContextual(t2) || this.unexpected(null, e2);
        }
        canInsertSemicolon() {
          return this.match(Mi.eof) || this.match(Mi.braceR) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
          return Ri.test(this.input.slice(this.state.lastTokEnd, this.state.start));
        }
        hasFollowingLineBreak() {
          return Ri.test(this.input.slice(this.state.end, this.nextTokenStart()));
        }
        isLineTerminator() {
          return this.eat(Mi.semi) || this.canInsertSemicolon();
        }
        semicolon(t2 = true) {
          (t2 ? this.isLineTerminator() : this.eat(Mi.semi)) || this.raise(this.state.lastTokEnd, Gi.MissingSemicolon);
        }
        expect(t2, e2) {
          this.eat(t2) || this.unexpected(e2, t2);
        }
        assertNoSpace(t2 = "Unexpected space.") {
          this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, {
            code: Wi.SyntaxError,
            reasonCode: "UnexpectedSpace",
            template: t2
          });
        }
        unexpected(t2, e2 = {
          code: Wi.SyntaxError,
          reasonCode: "UnexpectedToken",
          template: "Unexpected token"
        }) {
          throw e2 instanceof vi && (e2 = {
            code: Wi.SyntaxError,
            reasonCode: "UnexpectedToken",
            template: 'Unexpected token, expected "'.concat(e2.label, '"')
          }), this.raise(null != t2 ? t2 : this.state.start, e2);
        }
        expectPlugin(t2, e2) {
          if (!this.hasPlugin(t2))
            throw this.raiseWithData(null != e2 ? e2 : this.state.start, {
              missingPlugin: [t2]
            }, "This experimental syntax requires enabling the parser plugin: '".concat(t2, "'"));
          return true;
        }
        expectOnePlugin(t2, e2) {
          if (!t2.some((t3) => this.hasPlugin(t3)))
            throw this.raiseWithData(null != e2 ? e2 : this.state.start, {
              missingPlugin: t2
            }, "This experimental syntax requires enabling one of the following parser plugin(s): '".concat(t2.join(", "), "'"));
        }
        tryParse(t2, e2 = this.state.clone()) {
          const s2 = {
            node: null
          };
          try {
            const r2 = t2((t3 = null) => {
              throw s2.node = t3, s2;
            });
            if (this.state.errors.length > e2.errors.length) {
              const t3 = this.state;
              return this.state = e2, {
                node: r2,
                error: t3.errors[e2.errors.length],
                thrown: false,
                aborted: false,
                failState: t3
              };
            }
            return {
              node: r2,
              error: null,
              thrown: false,
              aborted: false,
              failState: null
            };
          } catch (t3) {
            const r2 = this.state;
            if (this.state = e2, t3 instanceof SyntaxError)
              return {
                node: null,
                error: t3,
                thrown: true,
                aborted: false,
                failState: r2
              };
            if (t3 === s2)
              return {
                node: s2.node,
                error: null,
                thrown: false,
                aborted: true,
                failState: r2
              };
            throw t3;
          }
        }
        checkExpressionErrors(t2, e2) {
          if (!t2)
            return false;
          const {
            shorthandAssign: s2,
            doubleProto: r2
          } = t2;
          if (!e2)
            return s2 >= 0 || r2 >= 0;
          s2 >= 0 && this.unexpected(s2), r2 >= 0 && this.raise(r2, Gi.DuplicateProto);
        }
        isLiteralPropertyName() {
          return this.match(Mi.name) || !!this.state.type.keyword || this.match(Mi.string) || this.match(Mi.num) || this.match(Mi.bigint) || this.match(Mi.decimal);
        }
        isPrivateName(t2) {
          return "PrivateName" === t2.type;
        }
        getPrivateNameSV(t2) {
          return t2.id.name;
        }
        hasPropertyAsPrivateName(t2) {
          return ("MemberExpression" === t2.type || "OptionalMemberExpression" === t2.type) && this.isPrivateName(t2.property);
        }
        isOptionalChain(t2) {
          return "OptionalMemberExpression" === t2.type || "OptionalCallExpression" === t2.type;
        }
        isObjectProperty(t2) {
          return "ObjectProperty" === t2.type;
        }
        isObjectMethod(t2) {
          return "ObjectMethod" === t2.type;
        }
        initializeScopes(t2 = "module" === this.options.sourceType) {
          const e2 = this.state.labels;
          this.state.labels = [];
          const s2 = this.state.exportedIdentifiers;
          this.state.exportedIdentifiers = [];
          const r2 = this.inModule;
          this.inModule = t2;
          const i2 = this.scope, a2 = this.getScopeHandler();
          this.scope = new a2(this.raise.bind(this), this.inModule);
          const n2 = this.prodParam;
          this.prodParam = new _a();
          const o2 = this.classScope;
          this.classScope = new on(this.raise.bind(this));
          const u2 = this.expressionScope;
          return this.expressionScope = new cn(this.raise.bind(this)), () => {
            this.state.labels = e2, this.state.exportedIdentifiers = s2, this.inModule = r2, this.scope = i2, this.prodParam = n2, this.classScope = o2, this.expressionScope = u2;
          };
        }
        enterInitialScopes() {
          let t2 = 0;
          this.hasPlugin("topLevelAwait") && this.inModule && (t2 |= 2), this.scope.enter(1), this.prodParam.enter(t2);
        }
      } {
        startNode() {
          return new dn(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(t2, e2) {
          return new dn(this, t2, e2);
        }
        startNodeAtNode(t2) {
          return this.startNodeAt(t2.start, t2.loc.start);
        }
        finishNode(t2, e2) {
          return this.finishNodeAt(t2, e2, this.state.lastTokEnd, this.state.lastTokEndLoc);
        }
        finishNodeAt(t2, e2, s2, r2) {
          return t2.type = e2, t2.end = s2, t2.loc.end = r2, this.options.ranges && (t2.range[1] = s2), this.processComment(t2), t2;
        }
        resetStartLocation(t2, e2, s2) {
          t2.start = e2, t2.loc.start = s2, this.options.ranges && (t2.range[0] = e2);
        }
        resetEndLocation(t2, e2 = this.state.lastTokEnd, s2 = this.state.lastTokEndLoc) {
          t2.end = e2, t2.loc.end = s2, this.options.ranges && (t2.range[1] = e2);
        }
        resetStartLocationFromNode(t2, e2) {
          this.resetStartLocation(t2, e2.start, e2.loc.start);
        }
      } {
        toAssignable(t2, e2 = false) {
          var s2, r2;
          let i2;
          switch (("ParenthesizedExpression" === t2.type || null != (s2 = t2.extra) && s2.parenthesized) && (i2 = Dn(t2), e2 ? "Identifier" === i2.type ? this.expressionScope.recordParenthesizedIdentifierError(t2.start, Gi.InvalidParenthesizedAssignment) : "MemberExpression" !== i2.type && this.raise(t2.start, Gi.InvalidParenthesizedAssignment) : this.raise(t2.start, Gi.InvalidParenthesizedAssignment)), t2.type) {
            case "Identifier":
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
              break;
            case "ObjectExpression":
              t2.type = "ObjectPattern";
              for (let s3 = 0, r3 = t2.properties.length, i3 = r3 - 1; s3 < r3; s3++) {
                var a2;
                const r4 = t2.properties[s3], n2 = s3 === i3;
                this.toAssignableObjectExpressionProp(r4, n2, e2), n2 && "RestElement" === r4.type && null != (a2 = t2.extra) && a2.trailingComma && this.raiseRestNotLast(t2.extra.trailingComma);
              }
              break;
            case "ObjectProperty":
              this.toAssignable(t2.value, e2);
              break;
            case "SpreadElement": {
              this.checkToRestConversion(t2), t2.type = "RestElement";
              const s3 = t2.argument;
              this.toAssignable(s3, e2);
              break;
            }
            case "ArrayExpression":
              t2.type = "ArrayPattern", this.toAssignableList(t2.elements, null == (r2 = t2.extra) ? void 0 : r2.trailingComma, e2);
              break;
            case "AssignmentExpression":
              "=" !== t2.operator && this.raise(t2.left.end, Gi.MissingEqInAssignment), t2.type = "AssignmentPattern", delete t2.operator, this.toAssignable(t2.left, e2);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(i2, e2);
          }
          return t2;
        }
        toAssignableObjectExpressionProp(t2, e2, s2) {
          if ("ObjectMethod" === t2.type) {
            const e3 = "get" === t2.kind || "set" === t2.kind ? Gi.PatternHasAccessor : Gi.PatternHasMethod;
            this.raise(t2.key.start, e3);
          } else
            "SpreadElement" !== t2.type || e2 ? this.toAssignable(t2, s2) : this.raiseRestNotLast(t2.start);
        }
        toAssignableList(t2, e2, s2) {
          let r2 = t2.length;
          if (r2) {
            const i2 = t2[r2 - 1];
            if ("RestElement" === (null == i2 ? void 0 : i2.type))
              --r2;
            else if ("SpreadElement" === (null == i2 ? void 0 : i2.type)) {
              i2.type = "RestElement";
              let t3 = i2.argument;
              this.toAssignable(t3, s2), t3 = Dn(t3), "Identifier" !== t3.type && "MemberExpression" !== t3.type && "ArrayPattern" !== t3.type && "ObjectPattern" !== t3.type && this.unexpected(t3.start), e2 && this.raiseTrailingCommaAfterRest(e2), --r2;
            }
          }
          for (let e3 = 0; e3 < r2; e3++) {
            const r3 = t2[e3];
            r3 && (this.toAssignable(r3, s2), "RestElement" === r3.type && this.raiseRestNotLast(r3.start));
          }
          return t2;
        }
        toReferencedList(t2, e2) {
          return t2;
        }
        toReferencedListDeep(t2, e2) {
          this.toReferencedList(t2, e2);
          for (const e3 of t2)
            "ArrayExpression" === (null == e3 ? void 0 : e3.type) && this.toReferencedListDeep(e3.elements);
        }
        parseSpread(t2, e2) {
          const s2 = this.startNode();
          return this.next(), s2.argument = this.parseMaybeAssignAllowIn(t2, void 0, e2), this.finishNode(s2, "SpreadElement");
        }
        parseRestBinding() {
          const t2 = this.startNode();
          return this.next(), t2.argument = this.parseBindingAtom(), this.finishNode(t2, "RestElement");
        }
        parseBindingAtom() {
          switch (this.state.type) {
            case Mi.bracketL: {
              const t2 = this.startNode();
              return this.next(), t2.elements = this.parseBindingList(Mi.bracketR, 93, true), this.finishNode(t2, "ArrayPattern");
            }
            case Mi.braceL:
              return this.parseObjectLike(Mi.braceR, true);
          }
          return this.parseIdentifier();
        }
        parseBindingList(t2, e2, s2, r2) {
          const i2 = [];
          let a2 = true;
          for (; !this.eat(t2); )
            if (a2 ? a2 = false : this.expect(Mi.comma), s2 && this.match(Mi.comma))
              i2.push(null);
            else {
              if (this.eat(t2))
                break;
              if (this.match(Mi.ellipsis)) {
                i2.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(e2), this.expect(t2);
                break;
              }
              {
                const t3 = [];
                for (this.match(Mi.at) && this.hasPlugin("decorators") && this.raise(this.state.start, Gi.UnsupportedParameterDecorator); this.match(Mi.at); )
                  t3.push(this.parseDecorator());
                i2.push(this.parseAssignableListItem(r2, t3));
              }
            }
          return i2;
        }
        parseAssignableListItem(t2, e2) {
          const s2 = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(s2);
          const r2 = this.parseMaybeDefault(s2.start, s2.loc.start, s2);
          return e2.length && (s2.decorators = e2), r2;
        }
        parseAssignableListItemTypes(t2) {
          return t2;
        }
        parseMaybeDefault(t2, e2, s2) {
          var r2, i2, a2;
          if (e2 = null != (r2 = e2) ? r2 : this.state.startLoc, t2 = null != (i2 = t2) ? i2 : this.state.start, s2 = null != (a2 = s2) ? a2 : this.parseBindingAtom(), !this.eat(Mi.eq))
            return s2;
          const n2 = this.startNodeAt(t2, e2);
          return n2.left = s2, n2.right = this.parseMaybeAssignAllowIn(), this.finishNode(n2, "AssignmentPattern");
        }
        checkLVal(t2, e2, s2 = 64, r2, i2, a2 = false) {
          switch (t2.type) {
            case "Identifier": {
              const {
                name: e3
              } = t2;
              this.state.strict && (a2 ? Da(e3, this.inModule) : da(e3)) && this.raise(t2.start, 64 === s2 ? Gi.StrictEvalArguments : Gi.StrictEvalArgumentsBinding, e3), r2 && (r2.has(e3) ? this.raise(t2.start, Gi.ParamDupe) : r2.add(e3)), i2 && "let" === e3 && this.raise(t2.start, Gi.LetInLexicalBinding), 64 & s2 || this.scope.declareName(e3, s2, t2.start);
              break;
            }
            case "MemberExpression":
              64 !== s2 && this.raise(t2.start, Gi.InvalidPropertyBindingPattern);
              break;
            case "ObjectPattern":
              for (let e3 of t2.properties) {
                if (this.isObjectProperty(e3))
                  e3 = e3.value;
                else if (this.isObjectMethod(e3))
                  continue;
                this.checkLVal(e3, "object destructuring pattern", s2, r2, i2);
              }
              break;
            case "ArrayPattern":
              for (const e3 of t2.elements)
                e3 && this.checkLVal(e3, "array destructuring pattern", s2, r2, i2);
              break;
            case "AssignmentPattern":
              this.checkLVal(t2.left, "assignment pattern", s2, r2);
              break;
            case "RestElement":
              this.checkLVal(t2.argument, "rest element", s2, r2);
              break;
            case "ParenthesizedExpression":
              this.checkLVal(t2.expression, "parenthesized expression", s2, r2);
              break;
            default:
              this.raise(t2.start, 64 === s2 ? Gi.InvalidLhs : Gi.InvalidLhsBinding, e2);
          }
        }
        checkToRestConversion(t2) {
          "Identifier" !== t2.argument.type && "MemberExpression" !== t2.argument.type && this.raise(t2.argument.start, Gi.InvalidRestAssignmentPattern);
        }
        checkCommaAfterRest(t2) {
          this.match(Mi.comma) && (this.lookaheadCharCode() === t2 ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
        }
        raiseRestNotLast(t2) {
          throw this.raise(t2, Gi.ElementAfterRest);
        }
        raiseTrailingCommaAfterRest(t2) {
          this.raise(t2, Gi.RestTrailingComma);
        }
      } {
        checkProto(t2, e2, s2, r2) {
          if ("SpreadElement" === t2.type || this.isObjectMethod(t2) || t2.computed || t2.shorthand)
            return;
          const i2 = t2.key;
          if ("__proto__" === ("Identifier" === i2.type ? i2.name : i2.value)) {
            if (e2)
              return void this.raise(i2.start, Gi.RecordNoProto);
            s2.used && (r2 ? -1 === r2.doubleProto && (r2.doubleProto = i2.start) : this.raise(i2.start, Gi.DuplicateProto)), s2.used = true;
          }
        }
        shouldExitDescending(t2, e2) {
          return "ArrowFunctionExpression" === t2.type && t2.start === e2;
        }
        getExpression() {
          let t2 = 0;
          this.hasPlugin("topLevelAwait") && this.inModule && (t2 |= 2), this.scope.enter(1), this.prodParam.enter(t2), this.nextToken();
          const e2 = this.parseExpression();
          return this.match(Mi.eof) || this.unexpected(), e2.comments = this.state.comments, e2.errors = this.state.errors, this.options.tokens && (e2.tokens = this.tokens), e2;
        }
        parseExpression(t2, e2) {
          return t2 ? this.disallowInAnd(() => this.parseExpressionBase(e2)) : this.allowInAnd(() => this.parseExpressionBase(e2));
        }
        parseExpressionBase(t2) {
          const e2 = this.state.start, s2 = this.state.startLoc, r2 = this.parseMaybeAssign(t2);
          if (this.match(Mi.comma)) {
            const i2 = this.startNodeAt(e2, s2);
            for (i2.expressions = [r2]; this.eat(Mi.comma); )
              i2.expressions.push(this.parseMaybeAssign(t2));
            return this.toReferencedList(i2.expressions), this.finishNode(i2, "SequenceExpression");
          }
          return r2;
        }
        parseMaybeAssignDisallowIn(t2, e2, s2) {
          return this.disallowInAnd(() => this.parseMaybeAssign(t2, e2, s2));
        }
        parseMaybeAssignAllowIn(t2, e2, s2) {
          return this.allowInAnd(() => this.parseMaybeAssign(t2, e2, s2));
        }
        parseMaybeAssign(t2, e2, s2) {
          const r2 = this.state.start, i2 = this.state.startLoc;
          if (this.isContextual("yield") && this.prodParam.hasYield) {
            this.state.exprAllowed = true;
            let t3 = this.parseYield();
            return e2 && (t3 = e2.call(this, t3, r2, i2)), t3;
          }
          let a2;
          t2 ? a2 = false : (t2 = new ln(), a2 = true), (this.match(Mi.parenL) || this.match(Mi.name)) && (this.state.potentialArrowAt = this.state.start);
          let n2 = this.parseMaybeConditional(t2, s2);
          if (e2 && (n2 = e2.call(this, n2, r2, i2)), this.state.type.isAssign) {
            const e3 = this.startNodeAt(r2, i2), s3 = this.state.value;
            return e3.operator = s3, this.match(Mi.eq) ? (e3.left = this.toAssignable(n2, true), t2.doubleProto = -1) : e3.left = n2, t2.shorthandAssign >= e3.left.start && (t2.shorthandAssign = -1), this.checkLVal(n2, "assignment expression"), this.next(), e3.right = this.parseMaybeAssign(), this.finishNode(e3, "AssignmentExpression");
          }
          return a2 && this.checkExpressionErrors(t2, true), n2;
        }
        parseMaybeConditional(t2, e2) {
          const s2 = this.state.start, r2 = this.state.startLoc, i2 = this.state.potentialArrowAt, a2 = this.parseExprOps(t2);
          return this.shouldExitDescending(a2, i2) ? a2 : this.parseConditional(a2, s2, r2, e2);
        }
        parseConditional(t2, e2, s2, r2) {
          if (this.eat(Mi.question)) {
            const r3 = this.startNodeAt(e2, s2);
            return r3.test = t2, r3.consequent = this.parseMaybeAssignAllowIn(), this.expect(Mi.colon), r3.alternate = this.parseMaybeAssign(), this.finishNode(r3, "ConditionalExpression");
          }
          return t2;
        }
        parseExprOps(t2) {
          const e2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseMaybeUnary(t2);
          return this.shouldExitDescending(i2, r2) ? i2 : this.parseExprOp(i2, e2, s2, -1);
        }
        parseExprOp(t2, e2, s2, r2) {
          let i2 = this.state.type.binop;
          if (null != i2 && (this.prodParam.hasIn || !this.match(Mi._in)) && i2 > r2) {
            const a2 = this.state.type;
            if (a2 === Mi.pipeline) {
              if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                return t2;
              this.state.inPipeline = true, this.checkPipelineAtInfixOperator(t2, e2);
            }
            const n2 = this.startNodeAt(e2, s2);
            n2.left = t2, n2.operator = this.state.value;
            const o2 = a2 === Mi.logicalOR || a2 === Mi.logicalAND, u2 = a2 === Mi.nullishCoalescing;
            if (u2 && (i2 = Mi.logicalAND.binop), this.next(), a2 === Mi.pipeline && "minimal" === this.getPluginOption("pipelineOperator", "proposal") && this.match(Mi.name) && "await" === this.state.value && this.prodParam.hasAwait)
              throw this.raise(this.state.start, Gi.UnexpectedAwaitAfterPipelineBody);
            n2.right = this.parseExprOpRightExpr(a2, i2), this.finishNode(n2, o2 || u2 ? "LogicalExpression" : "BinaryExpression");
            const h2 = this.state.type;
            if (u2 && (h2 === Mi.logicalOR || h2 === Mi.logicalAND) || o2 && h2 === Mi.nullishCoalescing)
              throw this.raise(this.state.start, Gi.MixingCoalesceWithLogical);
            return this.parseExprOp(n2, e2, s2, r2);
          }
          return t2;
        }
        parseExprOpRightExpr(t2, e2) {
          const s2 = this.state.start, r2 = this.state.startLoc;
          switch (t2) {
            case Mi.pipeline:
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "smart":
                  return this.withTopicPermittingContext(() => this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(t2, e2), s2, r2));
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e2));
              }
            default:
              return this.parseExprOpBaseRightExpr(t2, e2);
          }
        }
        parseExprOpBaseRightExpr(t2, e2) {
          const s2 = this.state.start, r2 = this.state.startLoc;
          return this.parseExprOp(this.parseMaybeUnary(), s2, r2, t2.rightAssociative ? e2 - 1 : e2);
        }
        checkExponentialAfterUnary(t2) {
          this.match(Mi.exponent) && this.raise(t2.argument.start, Gi.UnexpectedTokenUnaryExponentiation);
        }
        parseMaybeUnary(t2, e2) {
          const s2 = this.state.start, r2 = this.state.startLoc, i2 = this.isContextual("await");
          if (i2 && this.isAwaitAllowed()) {
            this.next();
            const t3 = this.parseAwait(s2, r2);
            return e2 || this.checkExponentialAfterUnary(t3), t3;
          }
          if (this.isContextual("module") && 123 === this.lookaheadCharCode() && !this.hasFollowingLineBreak())
            return this.parseModuleExpression();
          const a2 = this.match(Mi.incDec), n2 = this.startNode();
          if (this.state.type.prefix) {
            n2.operator = this.state.value, n2.prefix = true, this.match(Mi._throw) && this.expectPlugin("throwExpressions");
            const s3 = this.match(Mi._delete);
            if (this.next(), n2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t2, true), this.state.strict && s3) {
              const t3 = n2.argument;
              "Identifier" === t3.type ? this.raise(n2.start, Gi.StrictDelete) : this.hasPropertyAsPrivateName(t3) && this.raise(n2.start, Gi.DeletePrivateField);
            }
            if (!a2)
              return e2 || this.checkExponentialAfterUnary(n2), this.finishNode(n2, "UnaryExpression");
          }
          const o2 = this.parseUpdate(n2, a2, t2);
          if (i2) {
            if ((this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(Mi.modulo)) && !this.isAmbiguousAwait())
              return this.raiseOverwrite(s2, this.hasPlugin("topLevelAwait") ? Gi.AwaitNotInAsyncContext : Gi.AwaitNotInAsyncFunction), this.parseAwait(s2, r2);
          }
          return o2;
        }
        parseUpdate(t2, e2, s2) {
          if (e2)
            return this.checkLVal(t2.argument, "prefix operation"), this.finishNode(t2, "UpdateExpression");
          const r2 = this.state.start, i2 = this.state.startLoc;
          let a2 = this.parseExprSubscripts(s2);
          if (this.checkExpressionErrors(s2, false))
            return a2;
          for (; this.state.type.postfix && !this.canInsertSemicolon(); ) {
            const t3 = this.startNodeAt(r2, i2);
            t3.operator = this.state.value, t3.prefix = false, t3.argument = a2, this.checkLVal(a2, "postfix operation"), this.next(), a2 = this.finishNode(t3, "UpdateExpression");
          }
          return a2;
        }
        parseExprSubscripts(t2) {
          const e2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprAtom(t2);
          return this.shouldExitDescending(i2, r2) ? i2 : this.parseSubscripts(i2, e2, s2);
        }
        parseSubscripts(t2, e2, s2, r2) {
          const i2 = {
            optionalChainMember: false,
            maybeAsyncArrow: this.atPossibleAsyncArrow(t2),
            stop: false
          };
          do {
            t2 = this.parseSubscript(t2, e2, s2, r2, i2), i2.maybeAsyncArrow = false;
          } while (!i2.stop);
          return t2;
        }
        parseSubscript(t2, e2, s2, r2, i2) {
          if (!r2 && this.eat(Mi.doubleColon))
            return this.parseBind(t2, e2, s2, r2, i2);
          if (this.match(Mi.backQuote))
            return this.parseTaggedTemplateExpression(t2, e2, s2, i2);
          let a2 = false;
          if (this.match(Mi.questionDot)) {
            if (r2 && 40 === this.lookaheadCharCode())
              return i2.stop = true, t2;
            i2.optionalChainMember = a2 = true, this.next();
          }
          return !r2 && this.match(Mi.parenL) ? this.parseCoverCallAndAsyncArrowHead(t2, e2, s2, i2, a2) : a2 || this.match(Mi.bracketL) || this.eat(Mi.dot) ? this.parseMember(t2, e2, s2, i2, a2) : (i2.stop = true, t2);
        }
        parseMember(t2, e2, s2, r2, i2) {
          const a2 = this.startNodeAt(e2, s2), n2 = this.eat(Mi.bracketL);
          a2.object = t2, a2.computed = n2;
          const o2 = n2 ? this.parseExpression() : this.parseMaybePrivateName(true);
          return this.isPrivateName(o2) && ("Super" === a2.object.type && this.raise(e2, Gi.SuperPrivateField), this.classScope.usePrivateName(this.getPrivateNameSV(o2), o2.start)), a2.property = o2, n2 && this.expect(Mi.bracketR), r2.optionalChainMember ? (a2.optional = i2, this.finishNode(a2, "OptionalMemberExpression")) : this.finishNode(a2, "MemberExpression");
        }
        parseBind(t2, e2, s2, r2, i2) {
          const a2 = this.startNodeAt(e2, s2);
          return a2.object = t2, a2.callee = this.parseNoCallExpr(), i2.stop = true, this.parseSubscripts(this.finishNode(a2, "BindExpression"), e2, s2, r2);
        }
        parseCoverCallAndAsyncArrowHead(t2, e2, s2, r2, i2) {
          const a2 = this.state.maybeInArrowParameters;
          this.state.maybeInArrowParameters = true, this.next();
          let n2 = this.startNodeAt(e2, s2);
          return n2.callee = t2, r2.maybeAsyncArrow && this.expressionScope.enter(new hn(2)), r2.optionalChainMember && (n2.optional = i2), n2.arguments = i2 ? this.parseCallExpressionArguments(Mi.parenR, false) : this.parseCallExpressionArguments(Mi.parenR, r2.maybeAsyncArrow, "Import" === t2.type, "Super" !== t2.type, n2), this.finishCallExpression(n2, r2.optionalChainMember), r2.maybeAsyncArrow && this.shouldParseAsyncArrow() && !i2 ? (r2.stop = true, this.expressionScope.validateAsPattern(), this.expressionScope.exit(), n2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e2, s2), n2)) : (r2.maybeAsyncArrow && this.expressionScope.exit(), this.toReferencedArguments(n2)), this.state.maybeInArrowParameters = a2, n2;
        }
        toReferencedArguments(t2, e2) {
          this.toReferencedListDeep(t2.arguments, e2);
        }
        parseTaggedTemplateExpression(t2, e2, s2, r2) {
          const i2 = this.startNodeAt(e2, s2);
          return i2.tag = t2, i2.quasi = this.parseTemplate(true), r2.optionalChainMember && this.raise(e2, Gi.OptionalChainingNoTemplate), this.finishNode(i2, "TaggedTemplateExpression");
        }
        atPossibleAsyncArrow(t2) {
          return "Identifier" === t2.type && "async" === t2.name && this.state.lastTokEnd === t2.end && !this.canInsertSemicolon() && t2.end - t2.start == 5 && t2.start === this.state.potentialArrowAt;
        }
        finishCallExpression(t2, e2) {
          if ("Import" === t2.callee.type)
            if (2 === t2.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), 0 === t2.arguments.length || t2.arguments.length > 2)
              this.raise(t2.start, Gi.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
            else
              for (const e3 of t2.arguments)
                "SpreadElement" === e3.type && this.raise(e3.start, Gi.ImportCallSpreadArgument);
          return this.finishNode(t2, e2 ? "OptionalCallExpression" : "CallExpression");
        }
        parseCallExpressionArguments(t2, e2, s2, r2, i2) {
          const a2 = [];
          let n2 = true;
          const o2 = this.state.inFSharpPipelineDirectBody;
          for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t2); ) {
            if (n2)
              n2 = false;
            else if (this.expect(Mi.comma), this.match(t2)) {
              !s2 || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(this.state.lastTokStart, Gi.ImportCallArgumentTrailingComma), i2 && this.addExtra(i2, "trailingComma", this.state.lastTokStart), this.next();
              break;
            }
            a2.push(this.parseExprListItem(false, e2 ? new ln() : void 0, e2 ? {
              start: 0
            } : void 0, r2));
          }
          return this.state.inFSharpPipelineDirectBody = o2, a2;
        }
        shouldParseAsyncArrow() {
          return this.match(Mi.arrow) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(t2, e2) {
          var s2;
          return this.expect(Mi.arrow), this.parseArrowExpression(t2, e2.arguments, true, null == (s2 = e2.extra) ? void 0 : s2.trailingComma), t2;
        }
        parseNoCallExpr() {
          const t2 = this.state.start, e2 = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), t2, e2, true);
        }
        parseExprAtom(t2) {
          this.state.type === Mi.slash && this.readRegexp();
          const e2 = this.state.potentialArrowAt === this.state.start;
          let s2;
          switch (this.state.type) {
            case Mi._super:
              return this.parseSuper();
            case Mi._import:
              return s2 = this.startNode(), this.next(), this.match(Mi.dot) ? this.parseImportMetaProperty(s2) : (this.match(Mi.parenL) || this.raise(this.state.lastTokStart, Gi.UnsupportedImport), this.finishNode(s2, "Import"));
            case Mi._this:
              return s2 = this.startNode(), this.next(), this.finishNode(s2, "ThisExpression");
            case Mi.name: {
              const t3 = this.state.containsEsc, s3 = this.parseIdentifier();
              if (!t3 && "async" === s3.name && !this.canInsertSemicolon()) {
                if (this.match(Mi._function)) {
                  const t4 = this.state.context.length - 1;
                  if (this.state.context[t4] !== $i.functionStatement)
                    throw new Error("Internal error");
                  return this.state.context[t4] = $i.functionExpression, this.next(), this.parseFunction(this.startNodeAtNode(s3), void 0, true);
                }
                if (this.match(Mi.name))
                  return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(s3) : s3;
                if (this.match(Mi._do))
                  return this.parseDo(true);
              }
              return e2 && this.match(Mi.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(s3), [s3], false)) : s3;
            }
            case Mi._do:
              return this.parseDo(false);
            case Mi.regexp: {
              const t3 = this.state.value;
              return s2 = this.parseLiteral(t3.value, "RegExpLiteral"), s2.pattern = t3.pattern, s2.flags = t3.flags, s2;
            }
            case Mi.num:
              return this.parseLiteral(this.state.value, "NumericLiteral");
            case Mi.bigint:
              return this.parseLiteral(this.state.value, "BigIntLiteral");
            case Mi.decimal:
              return this.parseLiteral(this.state.value, "DecimalLiteral");
            case Mi.string:
              return this.parseLiteral(this.state.value, "StringLiteral");
            case Mi._null:
              return s2 = this.startNode(), this.next(), this.finishNode(s2, "NullLiteral");
            case Mi._true:
            case Mi._false:
              return this.parseBooleanLiteral();
            case Mi.parenL:
              return this.parseParenAndDistinguishExpression(e2);
            case Mi.bracketBarL:
            case Mi.bracketHashL:
              return this.parseArrayLike(this.state.type === Mi.bracketBarL ? Mi.bracketBarR : Mi.bracketR, false, true, t2);
            case Mi.bracketL:
              return this.parseArrayLike(Mi.bracketR, true, false, t2);
            case Mi.braceBarL:
            case Mi.braceHashL:
              return this.parseObjectLike(this.state.type === Mi.braceBarL ? Mi.braceBarR : Mi.braceR, false, true, t2);
            case Mi.braceL:
              return this.parseObjectLike(Mi.braceR, false, false, t2);
            case Mi._function:
              return this.parseFunctionOrFunctionSent();
            case Mi.at:
              this.parseDecorators();
            case Mi._class:
              return s2 = this.startNode(), this.takeDecorators(s2), this.parseClass(s2, false);
            case Mi._new:
              return this.parseNewOrNewTarget();
            case Mi.backQuote:
              return this.parseTemplate(false);
            case Mi.doubleColon: {
              s2 = this.startNode(), this.next(), s2.object = null;
              const t3 = s2.callee = this.parseNoCallExpr();
              if ("MemberExpression" === t3.type)
                return this.finishNode(s2, "BindExpression");
              throw this.raise(t3.start, Gi.UnsupportedBind);
            }
            case Mi.hash: {
              if (this.state.inPipeline)
                return s2 = this.startNode(), "smart" !== this.getPluginOption("pipelineOperator", "proposal") && this.raise(s2.start, Gi.PrimaryTopicRequiresSmartPipeline), this.next(), this.primaryTopicReferenceIsAllowedInCurrentTopicContext() || this.raise(s2.start, Gi.PrimaryTopicNotAllowed), this.registerTopicReference(), this.finishNode(s2, "PipelinePrimaryTopicReference");
              const t3 = this.input.codePointAt(this.state.end);
              if (ia(t3) || 92 === t3) {
                const t4 = this.state.start;
                if (s2 = this.parseMaybePrivateName(true), this.match(Mi._in))
                  this.expectPlugin("privateIn"), this.classScope.usePrivateName(this.getPrivateNameSV(s2), s2.start);
                else {
                  if (!this.hasPlugin("privateIn"))
                    throw this.unexpected(t4);
                  this.raise(this.state.start, Gi.PrivateInExpectedIn, this.getPrivateNameSV(s2));
                }
                return s2;
              }
            }
            case Mi.relational:
              if ("<" === this.state.value) {
                const t3 = this.input.codePointAt(this.nextTokenStart());
                (ia(t3) || 62 === t3) && this.expectOnePlugin(["jsx", "flow", "typescript"]);
              }
            default:
              throw this.unexpected();
          }
        }
        parseAsyncArrowUnaryFunction(t2) {
          const e2 = this.startNodeAtNode(t2);
          this.prodParam.enter(Ua(true, this.prodParam.hasYield));
          const s2 = [this.parseIdentifier()];
          return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(this.state.pos, Gi.LineTerminatorBeforeArrow), this.expect(Mi.arrow), this.parseArrowExpression(e2, s2, true), e2;
        }
        parseDo(t2) {
          this.expectPlugin("doExpressions"), t2 && this.expectPlugin("asyncDoExpressions");
          const e2 = this.startNode();
          e2.async = t2, this.next();
          const s2 = this.state.labels;
          return this.state.labels = [], t2 ? (this.prodParam.enter(2), e2.body = this.parseBlock(), this.prodParam.exit()) : e2.body = this.parseBlock(), this.state.labels = s2, this.finishNode(e2, "DoExpression");
        }
        parseSuper() {
          const t2 = this.startNode();
          return this.next(), !this.match(Mi.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(t2.start, Gi.UnexpectedSuper) : this.raise(t2.start, Gi.SuperNotAllowed), this.match(Mi.parenL) || this.match(Mi.bracketL) || this.match(Mi.dot) || this.raise(t2.start, Gi.UnsupportedSuper), this.finishNode(t2, "Super");
        }
        parseBooleanLiteral() {
          const t2 = this.startNode();
          return t2.value = this.match(Mi._true), this.next(), this.finishNode(t2, "BooleanLiteral");
        }
        parseMaybePrivateName(t2) {
          if (this.match(Mi.hash)) {
            t2 || this.raise(this.state.pos, Gi.UnexpectedPrivateField);
            const e2 = this.startNode();
            return this.next(), this.assertNoSpace("Unexpected space between # and identifier"), e2.id = this.parseIdentifier(true), this.finishNode(e2, "PrivateName");
          }
          return this.parseIdentifier(true);
        }
        parseFunctionOrFunctionSent() {
          const t2 = this.startNode();
          if (this.next(), this.prodParam.hasYield && this.match(Mi.dot)) {
            const e2 = this.createIdentifier(this.startNodeAtNode(t2), "function");
            return this.next(), this.parseMetaProperty(t2, e2, "sent");
          }
          return this.parseFunction(t2);
        }
        parseMetaProperty(t2, e2, s2) {
          t2.meta = e2, "function" === e2.name && "sent" === s2 && (this.isContextual(s2) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected());
          const r2 = this.state.containsEsc;
          return t2.property = this.parseIdentifier(true), (t2.property.name !== s2 || r2) && this.raise(t2.property.start, Gi.UnsupportedMetaProperty, e2.name, s2), this.finishNode(t2, "MetaProperty");
        }
        parseImportMetaProperty(t2) {
          const e2 = this.createIdentifier(this.startNodeAtNode(t2), "import");
          return this.next(), this.isContextual("meta") && (this.inModule || this.raise(e2.start, Ki.ImportMetaOutsideModule), this.sawUnambiguousESM = true), this.parseMetaProperty(t2, e2, "meta");
        }
        parseLiteral(t2, e2, s2, r2) {
          s2 = s2 || this.state.start, r2 = r2 || this.state.startLoc;
          const i2 = this.startNodeAt(s2, r2);
          return this.addExtra(i2, "rawValue", t2), this.addExtra(i2, "raw", this.input.slice(s2, this.state.end)), i2.value = t2, this.next(), this.finishNode(i2, e2);
        }
        parseParenAndDistinguishExpression(t2) {
          const e2 = this.state.start, s2 = this.state.startLoc;
          let r2;
          this.next(), this.expressionScope.enter(new hn(1));
          const i2 = this.state.maybeInArrowParameters, a2 = this.state.inFSharpPipelineDirectBody;
          this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
          const n2 = this.state.start, o2 = this.state.startLoc, u2 = [], h2 = new ln(), c2 = {
            start: 0
          };
          let p2, l2, d2 = true;
          for (; !this.match(Mi.parenR); ) {
            if (d2)
              d2 = false;
            else if (this.expect(Mi.comma, c2.start || null), this.match(Mi.parenR)) {
              l2 = this.state.start;
              break;
            }
            if (this.match(Mi.ellipsis)) {
              const t3 = this.state.start, e3 = this.state.startLoc;
              p2 = this.state.start, u2.push(this.parseParenItem(this.parseRestBinding(), t3, e3)), this.checkCommaAfterRest(41);
              break;
            }
            u2.push(this.parseMaybeAssignAllowIn(h2, this.parseParenItem, c2));
          }
          const D2 = this.state.lastTokEnd, m2 = this.state.lastTokEndLoc;
          this.expect(Mi.parenR), this.state.maybeInArrowParameters = i2, this.state.inFSharpPipelineDirectBody = a2;
          let f2 = this.startNodeAt(e2, s2);
          if (t2 && this.shouldParseArrow() && (f2 = this.parseArrow(f2)))
            return this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(f2, u2, false), f2;
          if (this.expressionScope.exit(), u2.length || this.unexpected(this.state.lastTokStart), l2 && this.unexpected(l2), p2 && this.unexpected(p2), this.checkExpressionErrors(h2, true), c2.start && this.unexpected(c2.start), this.toReferencedListDeep(u2, true), u2.length > 1 ? (r2 = this.startNodeAt(n2, o2), r2.expressions = u2, this.finishNodeAt(r2, "SequenceExpression", D2, m2)) : r2 = u2[0], !this.options.createParenthesizedExpressions)
            return this.addExtra(r2, "parenthesized", true), this.addExtra(r2, "parenStart", e2), r2;
          const y2 = this.startNodeAt(e2, s2);
          return y2.expression = r2, this.finishNode(y2, "ParenthesizedExpression"), y2;
        }
        shouldParseArrow() {
          return !this.canInsertSemicolon();
        }
        parseArrow(t2) {
          if (this.eat(Mi.arrow))
            return t2;
        }
        parseParenItem(t2, e2, s2) {
          return t2;
        }
        parseNewOrNewTarget() {
          const t2 = this.startNode();
          if (this.next(), this.match(Mi.dot)) {
            const e2 = this.createIdentifier(this.startNodeAtNode(t2), "new");
            this.next();
            const s2 = this.parseMetaProperty(t2, e2, "target");
            return this.scope.inNonArrowFunction || this.scope.inClass || this.raise(s2.start, Gi.UnexpectedNewTarget), s2;
          }
          return this.parseNew(t2);
        }
        parseNew(t2) {
          return t2.callee = this.parseNoCallExpr(), "Import" === t2.callee.type ? this.raise(t2.callee.start, Gi.ImportCallNotNewExpression) : this.isOptionalChain(t2.callee) ? this.raise(this.state.lastTokEnd, Gi.OptionalChainingNoNew) : this.eat(Mi.questionDot) && this.raise(this.state.start, Gi.OptionalChainingNoNew), this.parseNewArguments(t2), this.finishNode(t2, "NewExpression");
        }
        parseNewArguments(t2) {
          if (this.eat(Mi.parenL)) {
            const e2 = this.parseExprList(Mi.parenR);
            this.toReferencedList(e2), t2.arguments = e2;
          } else
            t2.arguments = [];
        }
        parseTemplateElement(t2) {
          const e2 = this.startNode();
          return null === this.state.value && (t2 || this.raise(this.state.start + 1, Gi.InvalidEscapeSequenceTemplate)), e2.value = {
            raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
            cooked: this.state.value
          }, this.next(), e2.tail = this.match(Mi.backQuote), this.finishNode(e2, "TemplateElement");
        }
        parseTemplate(t2) {
          const e2 = this.startNode();
          this.next(), e2.expressions = [];
          let s2 = this.parseTemplateElement(t2);
          for (e2.quasis = [s2]; !s2.tail; )
            this.expect(Mi.dollarBraceL), e2.expressions.push(this.parseTemplateSubstitution()), this.expect(Mi.braceR), e2.quasis.push(s2 = this.parseTemplateElement(t2));
          return this.next(), this.finishNode(e2, "TemplateLiteral");
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(t2, e2, s2, r2) {
          s2 && this.expectPlugin("recordAndTuple");
          const i2 = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const a2 = /* @__PURE__ */ Object.create(null);
          let n2 = true;
          const o2 = this.startNode();
          for (o2.properties = [], this.next(); !this.match(t2); ) {
            if (n2)
              n2 = false;
            else if (this.expect(Mi.comma), this.match(t2)) {
              this.addExtra(o2, "trailingComma", this.state.lastTokStart);
              break;
            }
            const i3 = this.parsePropertyDefinition(e2, r2);
            e2 || this.checkProto(i3, s2, a2, r2), s2 && !this.isObjectProperty(i3) && "SpreadElement" !== i3.type && this.raise(i3.start, Gi.InvalidRecordProperty), i3.shorthand && this.addExtra(i3, "shorthand", true), o2.properties.push(i3);
          }
          this.state.exprAllowed = false, this.next(), this.state.inFSharpPipelineDirectBody = i2;
          let u2 = "ObjectExpression";
          return e2 ? u2 = "ObjectPattern" : s2 && (u2 = "RecordExpression"), this.finishNode(o2, u2);
        }
        maybeAsyncOrAccessorProp(t2) {
          return !t2.computed && "Identifier" === t2.key.type && (this.isLiteralPropertyName() || this.match(Mi.bracketL) || this.match(Mi.star));
        }
        parsePropertyDefinition(t2, e2) {
          let s2 = [];
          if (this.match(Mi.at))
            for (this.hasPlugin("decorators") && this.raise(this.state.start, Gi.UnsupportedPropertyDecorator); this.match(Mi.at); )
              s2.push(this.parseDecorator());
          const r2 = this.startNode();
          let i2, a2, n2 = false, o2 = false, u2 = false;
          if (this.match(Mi.ellipsis))
            return s2.length && this.unexpected(), t2 ? (this.next(), r2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(r2, "RestElement")) : this.parseSpread();
          s2.length && (r2.decorators = s2, s2 = []), r2.method = false, (t2 || e2) && (i2 = this.state.start, a2 = this.state.startLoc), t2 || (n2 = this.eat(Mi.star));
          const h2 = this.state.containsEsc, c2 = this.parsePropertyName(r2, false);
          if (!t2 && !n2 && !h2 && this.maybeAsyncOrAccessorProp(r2)) {
            const t3 = c2.name;
            "async" !== t3 || this.hasPrecedingLineBreak() || (o2 = true, n2 = this.eat(Mi.star), this.parsePropertyName(r2, false)), "get" !== t3 && "set" !== t3 || (u2 = true, r2.kind = t3, this.match(Mi.star) && (n2 = true, this.raise(this.state.pos, Gi.AccessorIsGenerator, t3), this.next()), this.parsePropertyName(r2, false));
          }
          return this.parseObjPropValue(r2, i2, a2, n2, o2, t2, u2, e2), r2;
        }
        getGetterSetterExpectedParamCount(t2) {
          return "get" === t2.kind ? 0 : 1;
        }
        getObjectOrClassMethodParams(t2) {
          return t2.params;
        }
        checkGetterSetterParams(t2) {
          var e2;
          const s2 = this.getGetterSetterExpectedParamCount(t2), r2 = this.getObjectOrClassMethodParams(t2), i2 = t2.start;
          r2.length !== s2 && ("get" === t2.kind ? this.raise(i2, Gi.BadGetterArity) : this.raise(i2, Gi.BadSetterArity)), "set" === t2.kind && "RestElement" === (null == (e2 = r2[r2.length - 1]) ? void 0 : e2.type) && this.raise(i2, Gi.BadSetterRestParameter);
        }
        parseObjectMethod(t2, e2, s2, r2, i2) {
          return i2 ? (this.parseMethod(t2, e2, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(t2), t2) : s2 || e2 || this.match(Mi.parenL) ? (r2 && this.unexpected(), t2.kind = "method", t2.method = true, this.parseMethod(t2, e2, s2, false, false, "ObjectMethod")) : void 0;
        }
        parseObjectProperty(t2, e2, s2, r2, i2) {
          return t2.shorthand = false, this.eat(Mi.colon) ? (t2.value = r2 ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(i2), this.finishNode(t2, "ObjectProperty")) : t2.computed || "Identifier" !== t2.key.type ? void 0 : (this.checkReservedWord(t2.key.name, t2.key.start, true, false), r2 ? t2.value = this.parseMaybeDefault(e2, s2, t2.key.__clone()) : this.match(Mi.eq) && i2 ? (-1 === i2.shorthandAssign && (i2.shorthandAssign = this.state.start), t2.value = this.parseMaybeDefault(e2, s2, t2.key.__clone())) : t2.value = t2.key.__clone(), t2.shorthand = true, this.finishNode(t2, "ObjectProperty"));
        }
        parseObjPropValue(t2, e2, s2, r2, i2, a2, n2, o2) {
          const u2 = this.parseObjectMethod(t2, r2, i2, a2, n2) || this.parseObjectProperty(t2, e2, s2, a2, o2);
          return u2 || this.unexpected(), u2;
        }
        parsePropertyName(t2, e2) {
          if (this.eat(Mi.bracketL))
            t2.computed = true, t2.key = this.parseMaybeAssignAllowIn(), this.expect(Mi.bracketR);
          else {
            const s2 = this.state.inPropertyName;
            this.state.inPropertyName = true, t2.key = this.match(Mi.num) || this.match(Mi.string) || this.match(Mi.bigint) || this.match(Mi.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(e2), this.isPrivateName(t2.key) || (t2.computed = false), this.state.inPropertyName = s2;
          }
          return t2.key;
        }
        initFunction(t2, e2) {
          t2.id = null, t2.generator = false, t2.async = !!e2;
        }
        parseMethod(t2, e2, s2, r2, i2, a2, n2 = false) {
          this.initFunction(t2, s2), t2.generator = !!e2;
          const o2 = r2;
          return this.scope.enter(18 | (n2 ? 64 : 0) | (i2 ? 32 : 0)), this.prodParam.enter(Ua(s2, t2.generator)), this.parseFunctionParams(t2, o2), this.parseFunctionBodyAndFinish(t2, a2, true), this.prodParam.exit(), this.scope.exit(), t2;
        }
        parseArrayLike(t2, e2, s2, r2) {
          s2 && this.expectPlugin("recordAndTuple");
          const i2 = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = false;
          const a2 = this.startNode();
          return this.next(), a2.elements = this.parseExprList(t2, !s2, r2, a2), this.state.inFSharpPipelineDirectBody = i2, this.finishNode(a2, s2 ? "TupleExpression" : "ArrayExpression");
        }
        parseArrowExpression(t2, e2, s2, r2) {
          this.scope.enter(6);
          let i2 = Ua(s2, false);
          !this.match(Mi.bracketL) && this.prodParam.hasIn && (i2 |= 8), this.prodParam.enter(i2), this.initFunction(t2, s2);
          const a2 = this.state.maybeInArrowParameters;
          return e2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t2, e2, r2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t2, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a2, this.finishNode(t2, "ArrowFunctionExpression");
        }
        setArrowFunctionParameters(t2, e2, s2) {
          t2.params = this.toAssignableList(e2, s2, false);
        }
        parseFunctionBodyAndFinish(t2, e2, s2 = false) {
          this.parseFunctionBody(t2, false, s2), this.finishNode(t2, e2);
        }
        parseFunctionBody(t2, e2, s2 = false) {
          const r2 = e2 && !this.match(Mi.braceL);
          if (this.expressionScope.enter(pn()), r2)
            t2.body = this.parseMaybeAssign(), this.checkParams(t2, false, e2, false);
          else {
            const r3 = this.state.strict, i2 = this.state.labels;
            this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), t2.body = this.parseBlock(true, false, (i3) => {
              const a2 = !this.isSimpleParamList(t2.params);
              if (i3 && a2) {
                const e3 = "method" !== t2.kind && "constructor" !== t2.kind || !t2.key ? t2.start : t2.key.end;
                this.raise(e3, Gi.IllegalLanguageModeDirective);
              }
              const n2 = !r3 && this.state.strict;
              this.checkParams(t2, !(this.state.strict || e2 || s2 || a2), e2, n2), this.state.strict && t2.id && this.checkLVal(t2.id, "function name", 65, void 0, void 0, n2);
            }), this.prodParam.exit(), this.expressionScope.exit(), this.state.labels = i2;
          }
        }
        isSimpleParamList(t2) {
          for (let e2 = 0, s2 = t2.length; e2 < s2; e2++)
            if ("Identifier" !== t2[e2].type)
              return false;
          return true;
        }
        checkParams(t2, e2, s2, r2 = true) {
          const i2 = /* @__PURE__ */ new Set();
          for (const s3 of t2.params)
            this.checkLVal(s3, "function parameter list", 5, e2 ? null : i2, void 0, r2);
        }
        parseExprList(t2, e2, s2, r2) {
          const i2 = [];
          let a2 = true;
          for (; !this.eat(t2); ) {
            if (a2)
              a2 = false;
            else if (this.expect(Mi.comma), this.match(t2)) {
              r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
              break;
            }
            i2.push(this.parseExprListItem(e2, s2));
          }
          return i2;
        }
        parseExprListItem(t2, e2, s2, r2) {
          let i2;
          if (this.match(Mi.comma))
            t2 || this.raise(this.state.pos, Gi.UnexpectedToken, ","), i2 = null;
          else if (this.match(Mi.ellipsis)) {
            const t3 = this.state.start, r3 = this.state.startLoc;
            i2 = this.parseParenItem(this.parseSpread(e2, s2), t3, r3);
          } else if (this.match(Mi.question)) {
            this.expectPlugin("partialApplication"), r2 || this.raise(this.state.start, Gi.UnexpectedArgumentPlaceholder);
            const t3 = this.startNode();
            this.next(), i2 = this.finishNode(t3, "ArgumentPlaceholder");
          } else
            i2 = this.parseMaybeAssignAllowIn(e2, this.parseParenItem, s2);
          return i2;
        }
        parseIdentifier(t2) {
          const e2 = this.startNode(), s2 = this.parseIdentifierName(e2.start, t2);
          return this.createIdentifier(e2, s2);
        }
        createIdentifier(t2, e2) {
          return t2.name = e2, t2.loc.identifierName = e2, this.finishNode(t2, "Identifier");
        }
        parseIdentifierName(t2, e2) {
          let s2;
          const {
            start: r2,
            type: i2
          } = this.state;
          if (i2 === Mi.name)
            s2 = this.state.value;
          else {
            if (!i2.keyword)
              throw this.unexpected();
            {
              s2 = i2.keyword;
              const t3 = this.curContext();
              i2 !== Mi._class && i2 !== Mi._function || t3 !== $i.functionStatement && t3 !== $i.functionExpression || this.state.context.pop();
            }
          }
          return e2 ? this.state.type = Mi.name : this.checkReservedWord(s2, r2, !!i2.keyword, false), this.next(), s2;
        }
        checkReservedWord(t2, e2, s2, r2) {
          if (this.prodParam.hasYield && "yield" === t2)
            return void this.raise(e2, Gi.YieldBindingIdentifier);
          if ("await" === t2) {
            if (this.prodParam.hasAwait)
              return void this.raise(e2, Gi.AwaitBindingIdentifier);
            if (this.scope.inStaticBlock && !this.scope.inNonArrowFunction)
              return void this.raise(e2, Gi.AwaitBindingIdentifierInStaticBlock);
            this.expressionScope.recordAsyncArrowParametersError(e2, Gi.AwaitBindingIdentifier);
          }
          if (this.scope.inClass && !this.scope.inNonArrowFunction && "arguments" === t2)
            return void this.raise(e2, Gi.ArgumentsInClass);
          if (s2 && ma(t2))
            return void this.raise(e2, Gi.UnexpectedKeyword, t2);
          (this.state.strict ? r2 ? Da : la : pa)(t2, this.inModule) && this.raise(e2, Gi.UnexpectedReservedWord, t2);
        }
        isAwaitAllowed() {
          return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
        }
        parseAwait(t2, e2) {
          const s2 = this.startNodeAt(t2, e2);
          return this.expressionScope.recordParameterInitializerError(s2.start, Gi.AwaitExpressionFormalParameter), this.eat(Mi.star) && this.raise(s2.start, Gi.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (s2.argument = this.parseMaybeUnary(null, true)), this.finishNode(s2, "AwaitExpression");
        }
        isAmbiguousAwait() {
          return this.hasPrecedingLineBreak() || this.match(Mi.plusMin) || this.match(Mi.parenL) || this.match(Mi.bracketL) || this.match(Mi.backQuote) || this.match(Mi.regexp) || this.match(Mi.slash) || this.hasPlugin("v8intrinsic") && this.match(Mi.modulo);
        }
        parseYield() {
          const t2 = this.startNode();
          return this.expressionScope.recordParameterInitializerError(t2.start, Gi.YieldInParameter), this.next(), this.match(Mi.semi) || !this.match(Mi.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak() ? (t2.delegate = false, t2.argument = null) : (t2.delegate = this.eat(Mi.star), t2.argument = this.parseMaybeAssign()), this.finishNode(t2, "YieldExpression");
        }
        checkPipelineAtInfixOperator(t2, e2) {
          "smart" === this.getPluginOption("pipelineOperator", "proposal") && "SequenceExpression" === t2.type && this.raise(e2, Gi.PipelineHeadSequenceExpression);
        }
        parseSmartPipelineBody(t2, e2, s2) {
          return this.checkSmartPipelineBodyEarlyErrors(t2, e2), this.parseSmartPipelineBodyInStyle(t2, e2, s2);
        }
        checkSmartPipelineBodyEarlyErrors(t2, e2) {
          if (this.match(Mi.arrow))
            throw this.raise(this.state.start, Gi.PipelineBodyNoArrow);
          "SequenceExpression" === t2.type && this.raise(e2, Gi.PipelineBodySequenceExpression);
        }
        parseSmartPipelineBodyInStyle(t2, e2, s2) {
          const r2 = this.startNodeAt(e2, s2), i2 = this.isSimpleReference(t2);
          return i2 ? r2.callee = t2 : (this.topicReferenceWasUsedInCurrentTopicContext() || this.raise(e2, Gi.PipelineTopicUnused), r2.expression = t2), this.finishNode(r2, i2 ? "PipelineBareFunction" : "PipelineTopicExpression");
        }
        isSimpleReference(t2) {
          switch (t2.type) {
            case "MemberExpression":
              return !t2.computed && this.isSimpleReference(t2.object);
            case "Identifier":
              return true;
            default:
              return false;
          }
        }
        withTopicPermittingContext(t2) {
          const e2 = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null
          };
          try {
            return t2();
          } finally {
            this.state.topicContext = e2;
          }
        }
        withTopicForbiddingContext(t2) {
          const e2 = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return t2();
          } finally {
            this.state.topicContext = e2;
          }
        }
        withSoloAwaitPermittingContext(t2) {
          const e2 = this.state.soloAwait;
          this.state.soloAwait = true;
          try {
            return t2();
          } finally {
            this.state.soloAwait = e2;
          }
        }
        allowInAnd(t2) {
          const e2 = this.prodParam.currentFlags();
          if (8 & ~e2) {
            this.prodParam.enter(8 | e2);
            try {
              return t2();
            } finally {
              this.prodParam.exit();
            }
          }
          return t2();
        }
        disallowInAnd(t2) {
          const e2 = this.prodParam.currentFlags();
          if (8 & e2) {
            this.prodParam.enter(-9 & e2);
            try {
              return t2();
            } finally {
              this.prodParam.exit();
            }
          }
          return t2();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        primaryTopicReferenceIsAllowedInCurrentTopicContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentTopicContext() {
          return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(t2) {
          const e2 = this.state.start, s2 = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          const r2 = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = true;
          const i2 = this.parseExprOp(this.parseMaybeUnary(), e2, s2, t2);
          return this.state.inFSharpPipelineDirectBody = r2, i2;
        }
        parseModuleExpression() {
          this.expectPlugin("moduleBlocks");
          const t2 = this.startNode();
          this.next(), this.eat(Mi.braceL);
          const e2 = this.initializeScopes(true);
          this.enterInitialScopes();
          const s2 = this.startNode();
          try {
            t2.body = this.parseProgram(s2, Mi.braceR, "module");
          } finally {
            e2();
          }
          return this.eat(Mi.braceR), this.finishNode(t2, "ModuleExpression");
        }
      } {
        parseTopLevel(t2, e2) {
          return t2.program = this.parseProgram(e2), t2.comments = this.state.comments, this.options.tokens && (t2.tokens = this.tokens), this.finishNode(t2, "File");
        }
        parseProgram(t2, e2 = Mi.eof, s2 = this.options.sourceType) {
          if (t2.sourceType = s2, t2.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t2, true, true, e2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
            for (const [t3] of Array.from(this.scope.undefinedExports)) {
              const e3 = this.scope.undefinedExports.get(t3);
              this.raise(e3, Gi.ModuleExportUndefined, t3);
            }
          return this.finishNode(t2, "Program");
        }
        stmtToDirective(t2) {
          const e2 = t2.expression, s2 = this.startNodeAt(e2.start, e2.loc.start), r2 = this.startNodeAt(t2.start, t2.loc.start), i2 = this.input.slice(e2.start, e2.end), a2 = s2.value = i2.slice(1, -1);
          return this.addExtra(s2, "raw", i2), this.addExtra(s2, "rawValue", a2), r2.value = this.finishNodeAt(s2, "DirectiveLiteral", e2.end, e2.loc.end), this.finishNodeAt(r2, "Directive", t2.end, t2.loc.end);
        }
        parseInterpreterDirective() {
          if (!this.match(Mi.interpreterDirective))
            return null;
          const t2 = this.startNode();
          return t2.value = this.state.value, this.next(), this.finishNode(t2, "InterpreterDirective");
        }
        isLet(t2) {
          return !!this.isContextual("let") && this.isLetKeyword(t2);
        }
        isLetKeyword(t2) {
          const e2 = this.nextTokenStart(), s2 = this.input.charCodeAt(e2);
          if (91 === s2)
            return true;
          if (t2)
            return false;
          if (123 === s2)
            return true;
          if (ia(s2)) {
            let t3 = e2 + 1;
            for (; aa(this.input.charCodeAt(t3)); )
              ++t3;
            const s3 = this.input.slice(e2, t3);
            if (!fa.test(s3))
              return true;
          }
          return false;
        }
        parseStatement(t2, e2) {
          return this.match(Mi.at) && this.parseDecorators(true), this.parseStatementContent(t2, e2);
        }
        parseStatementContent(t2, e2) {
          let s2 = this.state.type;
          const r2 = this.startNode();
          let i2;
          switch (this.isLet(t2) && (s2 = Mi._var, i2 = "let"), s2) {
            case Mi._break:
            case Mi._continue:
              return this.parseBreakContinueStatement(r2, s2.keyword);
            case Mi._debugger:
              return this.parseDebuggerStatement(r2);
            case Mi._do:
              return this.parseDoStatement(r2);
            case Mi._for:
              return this.parseForStatement(r2);
            case Mi._function:
              if (46 === this.lookaheadCharCode())
                break;
              return t2 && (this.state.strict ? this.raise(this.state.start, Gi.StrictFunction) : "if" !== t2 && "label" !== t2 && this.raise(this.state.start, Gi.SloppyFunction)), this.parseFunctionStatement(r2, false, !t2);
            case Mi._class:
              return t2 && this.unexpected(), this.parseClass(r2, true);
            case Mi._if:
              return this.parseIfStatement(r2);
            case Mi._return:
              return this.parseReturnStatement(r2);
            case Mi._switch:
              return this.parseSwitchStatement(r2);
            case Mi._throw:
              return this.parseThrowStatement(r2);
            case Mi._try:
              return this.parseTryStatement(r2);
            case Mi._const:
            case Mi._var:
              return i2 = i2 || this.state.value, t2 && "var" !== i2 && this.raise(this.state.start, Gi.UnexpectedLexicalDeclaration), this.parseVarStatement(r2, i2);
            case Mi._while:
              return this.parseWhileStatement(r2);
            case Mi._with:
              return this.parseWithStatement(r2);
            case Mi.braceL:
              return this.parseBlock();
            case Mi.semi:
              return this.parseEmptyStatement(r2);
            case Mi._import: {
              const t3 = this.lookaheadCharCode();
              if (40 === t3 || 46 === t3)
                break;
            }
            case Mi._export: {
              let t3;
              return this.options.allowImportExportEverywhere || e2 || this.raise(this.state.start, Gi.UnexpectedImportExport), this.next(), s2 === Mi._import ? (t3 = this.parseImport(r2), "ImportDeclaration" !== t3.type || t3.importKind && "value" !== t3.importKind || (this.sawUnambiguousESM = true)) : (t3 = this.parseExport(r2), ("ExportNamedDeclaration" !== t3.type || t3.exportKind && "value" !== t3.exportKind) && ("ExportAllDeclaration" !== t3.type || t3.exportKind && "value" !== t3.exportKind) && "ExportDefaultDeclaration" !== t3.type || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(r2), t3;
            }
            default:
              if (this.isAsyncFunction())
                return t2 && this.raise(this.state.start, Gi.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(r2, true, !t2);
          }
          const a2 = this.state.value, n2 = this.parseExpression();
          return s2 === Mi.name && "Identifier" === n2.type && this.eat(Mi.colon) ? this.parseLabeledStatement(r2, a2, n2, t2) : this.parseExpressionStatement(r2, n2);
        }
        assertModuleNodeAllowed(t2) {
          this.options.allowImportExportEverywhere || this.inModule || this.raise(t2.start, Ki.ImportOutsideModule);
        }
        takeDecorators(t2) {
          const e2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          e2.length && (t2.decorators = e2, this.resetStartLocationFromNode(t2, e2[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
        }
        canHaveLeadingDecorator() {
          return this.match(Mi._class);
        }
        parseDecorators(t2) {
          const e2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          for (; this.match(Mi.at); ) {
            const t3 = this.parseDecorator();
            e2.push(t3);
          }
          if (this.match(Mi._export))
            t2 || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Gi.DecoratorExportClass);
          else if (!this.canHaveLeadingDecorator())
            throw this.raise(this.state.start, Gi.UnexpectedLeadingDecorator);
        }
        parseDecorator() {
          this.expectOnePlugin(["decorators-legacy", "decorators"]);
          const t2 = this.startNode();
          if (this.next(), this.hasPlugin("decorators")) {
            this.state.decoratorStack.push([]);
            const e2 = this.state.start, s2 = this.state.startLoc;
            let r2;
            if (this.eat(Mi.parenL))
              r2 = this.parseExpression(), this.expect(Mi.parenR);
            else
              for (r2 = this.parseIdentifier(false); this.eat(Mi.dot); ) {
                const t3 = this.startNodeAt(e2, s2);
                t3.object = r2, t3.property = this.parseIdentifier(true), t3.computed = false, r2 = this.finishNode(t3, "MemberExpression");
              }
            t2.expression = this.parseMaybeDecoratorArguments(r2), this.state.decoratorStack.pop();
          } else
            t2.expression = this.parseExprSubscripts();
          return this.finishNode(t2, "Decorator");
        }
        parseMaybeDecoratorArguments(t2) {
          if (this.eat(Mi.parenL)) {
            const e2 = this.startNodeAtNode(t2);
            return e2.callee = t2, e2.arguments = this.parseCallExpressionArguments(Mi.parenR, false), this.toReferencedList(e2.arguments), this.finishNode(e2, "CallExpression");
          }
          return t2;
        }
        parseBreakContinueStatement(t2, e2) {
          const s2 = "break" === e2;
          return this.next(), this.isLineTerminator() ? t2.label = null : (t2.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t2, e2), this.finishNode(t2, s2 ? "BreakStatement" : "ContinueStatement");
        }
        verifyBreakContinue(t2, e2) {
          const s2 = "break" === e2;
          let r2;
          for (r2 = 0; r2 < this.state.labels.length; ++r2) {
            const e3 = this.state.labels[r2];
            if (null == t2.label || e3.name === t2.label.name) {
              if (null != e3.kind && (s2 || "loop" === e3.kind))
                break;
              if (t2.label && s2)
                break;
            }
          }
          r2 === this.state.labels.length && this.raise(t2.start, Gi.IllegalBreakContinue, e2);
        }
        parseDebuggerStatement(t2) {
          return this.next(), this.semicolon(), this.finishNode(t2, "DebuggerStatement");
        }
        parseHeaderExpression() {
          this.expect(Mi.parenL);
          const t2 = this.parseExpression();
          return this.expect(Mi.parenR), t2;
        }
        parseDoStatement(t2) {
          return this.next(), this.state.labels.push(mn), t2.body = this.withTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(Mi._while), t2.test = this.parseHeaderExpression(), this.eat(Mi.semi), this.finishNode(t2, "DoWhileStatement");
        }
        parseForStatement(t2) {
          this.next(), this.state.labels.push(mn);
          let e2 = -1;
          if (this.isAwaitAllowed() && this.eatContextual("await") && (e2 = this.state.lastTokStart), this.scope.enter(0), this.expect(Mi.parenL), this.match(Mi.semi))
            return e2 > -1 && this.unexpected(e2), this.parseFor(t2, null);
          const s2 = this.isContextual("let"), r2 = s2 && this.isLetKeyword();
          if (this.match(Mi._var) || this.match(Mi._const) || r2) {
            const s3 = this.startNode(), i3 = r2 ? "let" : this.state.value;
            return this.next(), this.parseVar(s3, true, i3), this.finishNode(s3, "VariableDeclaration"), (this.match(Mi._in) || this.isContextual("of")) && 1 === s3.declarations.length ? this.parseForIn(t2, s3, e2) : (e2 > -1 && this.unexpected(e2), this.parseFor(t2, s3));
          }
          const i2 = this.match(Mi.name) && !this.state.containsEsc, a2 = new ln(), n2 = this.parseExpression(true, a2), o2 = this.isContextual("of");
          if (o2 && (s2 ? this.raise(n2.start, Gi.ForOfLet) : -1 === e2 && i2 && "Identifier" === n2.type && "async" === n2.name && this.raise(n2.start, Gi.ForOfAsync)), o2 || this.match(Mi._in)) {
            this.toAssignable(n2, true);
            const s3 = o2 ? "for-of statement" : "for-in statement";
            return this.checkLVal(n2, s3), this.parseForIn(t2, n2, e2);
          }
          return this.checkExpressionErrors(a2, true), e2 > -1 && this.unexpected(e2), this.parseFor(t2, n2);
        }
        parseFunctionStatement(t2, e2, s2) {
          return this.next(), this.parseFunction(t2, 1 | (s2 ? 0 : 2), e2);
        }
        parseIfStatement(t2) {
          return this.next(), t2.test = this.parseHeaderExpression(), t2.consequent = this.parseStatement("if"), t2.alternate = this.eat(Mi._else) ? this.parseStatement("if") : null, this.finishNode(t2, "IfStatement");
        }
        parseReturnStatement(t2) {
          return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, Gi.IllegalReturn), this.next(), this.isLineTerminator() ? t2.argument = null : (t2.argument = this.parseExpression(), this.semicolon()), this.finishNode(t2, "ReturnStatement");
        }
        parseSwitchStatement(t2) {
          this.next(), t2.discriminant = this.parseHeaderExpression();
          const e2 = t2.cases = [];
          let s2, r2;
          for (this.expect(Mi.braceL), this.state.labels.push(fn), this.scope.enter(0); !this.match(Mi.braceR); )
            if (this.match(Mi._case) || this.match(Mi._default)) {
              const t3 = this.match(Mi._case);
              s2 && this.finishNode(s2, "SwitchCase"), e2.push(s2 = this.startNode()), s2.consequent = [], this.next(), t3 ? s2.test = this.parseExpression() : (r2 && this.raise(this.state.lastTokStart, Gi.MultipleDefaultsInSwitch), r2 = true, s2.test = null), this.expect(Mi.colon);
            } else
              s2 ? s2.consequent.push(this.parseStatement(null)) : this.unexpected();
          return this.scope.exit(), s2 && this.finishNode(s2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t2, "SwitchStatement");
        }
        parseThrowStatement(t2) {
          return this.next(), this.hasPrecedingLineBreak() && this.raise(this.state.lastTokEnd, Gi.NewlineAfterThrow), t2.argument = this.parseExpression(), this.semicolon(), this.finishNode(t2, "ThrowStatement");
        }
        parseCatchClauseParam() {
          const t2 = this.parseBindingAtom(), e2 = "Identifier" === t2.type;
          return this.scope.enter(e2 ? 8 : 0), this.checkLVal(t2, "catch clause", 9), t2;
        }
        parseTryStatement(t2) {
          if (this.next(), t2.block = this.parseBlock(), t2.handler = null, this.match(Mi._catch)) {
            const e2 = this.startNode();
            this.next(), this.match(Mi.parenL) ? (this.expect(Mi.parenL), e2.param = this.parseCatchClauseParam(), this.expect(Mi.parenR)) : (e2.param = null, this.scope.enter(0)), e2.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t2.handler = this.finishNode(e2, "CatchClause");
          }
          return t2.finalizer = this.eat(Mi._finally) ? this.parseBlock() : null, t2.handler || t2.finalizer || this.raise(t2.start, Gi.NoCatchOrFinally), this.finishNode(t2, "TryStatement");
        }
        parseVarStatement(t2, e2) {
          return this.next(), this.parseVar(t2, false, e2), this.semicolon(), this.finishNode(t2, "VariableDeclaration");
        }
        parseWhileStatement(t2) {
          return this.next(), t2.test = this.parseHeaderExpression(), this.state.labels.push(mn), t2.body = this.withTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(t2, "WhileStatement");
        }
        parseWithStatement(t2) {
          return this.state.strict && this.raise(this.state.start, Gi.StrictWith), this.next(), t2.object = this.parseHeaderExpression(), t2.body = this.withTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(t2, "WithStatement");
        }
        parseEmptyStatement(t2) {
          return this.next(), this.finishNode(t2, "EmptyStatement");
        }
        parseLabeledStatement(t2, e2, s2, r2) {
          for (const t3 of this.state.labels)
            t3.name === e2 && this.raise(s2.start, Gi.LabelRedeclaration, e2);
          const i2 = this.state.type.isLoop ? "loop" : this.match(Mi._switch) ? "switch" : null;
          for (let e3 = this.state.labels.length - 1; e3 >= 0; e3--) {
            const s3 = this.state.labels[e3];
            if (s3.statementStart !== t2.start)
              break;
            s3.statementStart = this.state.start, s3.kind = i2;
          }
          return this.state.labels.push({
            name: e2,
            kind: i2,
            statementStart: this.state.start
          }), t2.body = this.parseStatement(r2 ? -1 === r2.indexOf("label") ? r2 + "label" : r2 : "label"), this.state.labels.pop(), t2.label = s2, this.finishNode(t2, "LabeledStatement");
        }
        parseExpressionStatement(t2, e2) {
          return t2.expression = e2, this.semicolon(), this.finishNode(t2, "ExpressionStatement");
        }
        parseBlock(t2 = false, e2 = true, s2) {
          const r2 = this.startNode();
          return t2 && this.state.strictErrors.clear(), this.expect(Mi.braceL), e2 && this.scope.enter(0), this.parseBlockBody(r2, t2, false, Mi.braceR, s2), e2 && this.scope.exit(), this.finishNode(r2, "BlockStatement");
        }
        isValidDirective(t2) {
          return "ExpressionStatement" === t2.type && "StringLiteral" === t2.expression.type && !t2.expression.extra.parenthesized;
        }
        parseBlockBody(t2, e2, s2, r2, i2) {
          const a2 = t2.body = [], n2 = t2.directives = [];
          this.parseBlockOrModuleBlockBody(a2, e2 ? n2 : void 0, s2, r2, i2);
        }
        parseBlockOrModuleBlockBody(t2, e2, s2, r2, i2) {
          const a2 = this.state.strict;
          let n2 = false, o2 = false;
          for (; !this.match(r2); ) {
            const r3 = this.parseStatement(null, s2);
            if (e2 && !o2) {
              if (this.isValidDirective(r3)) {
                const t3 = this.stmtToDirective(r3);
                e2.push(t3), n2 || "use strict" !== t3.value.value || (n2 = true, this.setStrict(true));
                continue;
              }
              o2 = true, this.state.strictErrors.clear();
            }
            t2.push(r3);
          }
          i2 && i2.call(this, n2), a2 || this.setStrict(false), this.next();
        }
        parseFor(t2, e2) {
          return t2.init = e2, this.semicolon(false), t2.test = this.match(Mi.semi) ? null : this.parseExpression(), this.semicolon(false), t2.update = this.match(Mi.parenR) ? null : this.parseExpression(), this.expect(Mi.parenR), t2.body = this.withTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, "ForStatement");
        }
        parseForIn(t2, e2, s2) {
          const r2 = this.match(Mi._in);
          return this.next(), r2 ? s2 > -1 && this.unexpected(s2) : t2.await = s2 > -1, "VariableDeclaration" !== e2.type || null == e2.declarations[0].init || r2 && !this.state.strict && "var" === e2.kind && "Identifier" === e2.declarations[0].id.type ? "AssignmentPattern" === e2.type && this.raise(e2.start, Gi.InvalidLhs, "for-loop") : this.raise(e2.start, Gi.ForInOfLoopInitializer, r2 ? "for-in" : "for-of"), t2.left = e2, t2.right = r2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(Mi.parenR), t2.body = this.withTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, r2 ? "ForInStatement" : "ForOfStatement");
        }
        parseVar(t2, e2, s2) {
          const r2 = t2.declarations = [], i2 = this.hasPlugin("typescript");
          for (t2.kind = s2; ; ) {
            const t3 = this.startNode();
            if (this.parseVarId(t3, s2), this.eat(Mi.eq) ? t3.init = e2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : ("const" !== s2 || this.match(Mi._in) || this.isContextual("of") ? "Identifier" === t3.id.type || e2 && (this.match(Mi._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, Gi.DeclarationMissingInitializer, "Complex binding patterns") : i2 || this.raise(this.state.lastTokEnd, Gi.DeclarationMissingInitializer, "Const declarations"), t3.init = null), r2.push(this.finishNode(t3, "VariableDeclarator")), !this.eat(Mi.comma))
              break;
          }
          return t2;
        }
        parseVarId(t2, e2) {
          t2.id = this.parseBindingAtom(), this.checkLVal(t2.id, "variable declaration", "var" === e2 ? 5 : 9, void 0, "var" !== e2);
        }
        parseFunction(t2, e2 = 0, s2 = false) {
          const r2 = 1 & e2, i2 = 2 & e2, a2 = !(!r2 || 4 & e2);
          this.initFunction(t2, s2), this.match(Mi.star) && i2 && this.raise(this.state.start, Gi.GeneratorInSingleStatementContext), t2.generator = this.eat(Mi.star), r2 && (t2.id = this.parseFunctionId(a2));
          const n2 = this.state.maybeInArrowParameters;
          return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(Ua(s2, t2.generator)), r2 || (t2.id = this.parseFunctionId()), this.parseFunctionParams(t2, false), this.withTopicForbiddingContext(() => {
            this.parseFunctionBodyAndFinish(t2, r2 ? "FunctionDeclaration" : "FunctionExpression");
          }), this.prodParam.exit(), this.scope.exit(), r2 && !i2 && this.registerFunctionStatementId(t2), this.state.maybeInArrowParameters = n2, t2;
        }
        parseFunctionId(t2) {
          return t2 || this.match(Mi.name) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(t2, e2) {
          this.expect(Mi.parenL), this.expressionScope.enter(new un(3)), t2.params = this.parseBindingList(Mi.parenR, 41, false, e2), this.expressionScope.exit();
        }
        registerFunctionStatementId(t2) {
          t2.id && this.scope.declareName(t2.id.name, this.state.strict || t2.generator || t2.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, t2.id.start);
        }
        parseClass(t2, e2, s2) {
          this.next(), this.takeDecorators(t2);
          const r2 = this.state.strict;
          return this.state.strict = true, this.parseClassId(t2, e2, s2), this.parseClassSuper(t2), t2.body = this.parseClassBody(!!t2.superClass, r2), this.finishNode(t2, e2 ? "ClassDeclaration" : "ClassExpression");
        }
        isClassProperty() {
          return this.match(Mi.eq) || this.match(Mi.semi) || this.match(Mi.braceR);
        }
        isClassMethod() {
          return this.match(Mi.parenL);
        }
        isNonstaticConstructor(t2) {
          return !(t2.computed || t2.static || "constructor" !== t2.key.name && "constructor" !== t2.key.value);
        }
        parseClassBody(t2, e2) {
          this.classScope.enter();
          const s2 = {
            hadConstructor: false,
            hadSuperClass: t2
          };
          let r2 = [];
          const i2 = this.startNode();
          if (i2.body = [], this.expect(Mi.braceL), this.withTopicForbiddingContext(() => {
            for (; !this.match(Mi.braceR); ) {
              if (this.eat(Mi.semi)) {
                if (r2.length > 0)
                  throw this.raise(this.state.lastTokEnd, Gi.DecoratorSemicolon);
                continue;
              }
              if (this.match(Mi.at)) {
                r2.push(this.parseDecorator());
                continue;
              }
              const t3 = this.startNode();
              r2.length && (t3.decorators = r2, this.resetStartLocationFromNode(t3, r2[0]), r2 = []), this.parseClassMember(i2, t3, s2), "constructor" === t3.kind && t3.decorators && t3.decorators.length > 0 && this.raise(t3.start, Gi.DecoratorConstructor);
            }
          }), this.state.strict = e2, this.next(), r2.length)
            throw this.raise(this.state.start, Gi.TrailingDecorator);
          return this.classScope.exit(), this.finishNode(i2, "ClassBody");
        }
        parseClassMemberFromModifier(t2, e2) {
          const s2 = this.parseIdentifier(true);
          if (this.isClassMethod()) {
            const r2 = e2;
            return r2.kind = "method", r2.computed = false, r2.key = s2, r2.static = false, this.pushClassMethod(t2, r2, false, false, false, false), true;
          }
          if (this.isClassProperty()) {
            const r2 = e2;
            return r2.computed = false, r2.key = s2, r2.static = false, t2.body.push(this.parseClassProperty(r2)), true;
          }
          return false;
        }
        parseClassMember(t2, e2, s2) {
          const r2 = this.isContextual("static");
          if (r2) {
            if (this.parseClassMemberFromModifier(t2, e2))
              return;
            if (this.eat(Mi.braceL))
              return void this.parseClassStaticBlock(t2, e2);
          }
          this.parseClassMemberWithIsStatic(t2, e2, s2, r2);
        }
        parseClassMemberWithIsStatic(t2, e2, s2, r2) {
          const i2 = e2, a2 = e2, n2 = e2, o2 = e2, u2 = i2, h2 = i2;
          if (e2.static = r2, this.eat(Mi.star))
            return u2.kind = "method", this.parseClassElementName(u2), this.isPrivateName(u2.key) ? void this.pushClassPrivateMethod(t2, a2, true, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Gi.ConstructorIsGenerator), void this.pushClassMethod(t2, i2, true, false, false, false));
          const c2 = this.state.containsEsc, p2 = this.parseClassElementName(e2), l2 = this.isPrivateName(p2), d2 = "Identifier" === p2.type, D2 = this.state.start;
          if (this.parsePostMemberNameModifiers(h2), this.isClassMethod()) {
            if (u2.kind = "method", l2)
              return void this.pushClassPrivateMethod(t2, a2, false, false);
            const r3 = this.isNonstaticConstructor(i2);
            let n3 = false;
            r3 && (i2.kind = "constructor", s2.hadConstructor && !this.hasPlugin("typescript") && this.raise(p2.start, Gi.DuplicateConstructor), r3 && this.hasPlugin("typescript") && e2.override && this.raise(p2.start, Gi.OverrideOnConstructor), s2.hadConstructor = true, n3 = s2.hadSuperClass), this.pushClassMethod(t2, i2, false, false, r3, n3);
          } else if (this.isClassProperty())
            l2 ? this.pushClassPrivateProperty(t2, o2) : this.pushClassProperty(t2, n2);
          else if (!d2 || "async" !== p2.name || c2 || this.isLineTerminator())
            !d2 || "get" !== p2.name && "set" !== p2.name || c2 || this.match(Mi.star) && this.isLineTerminator() ? this.isLineTerminator() ? l2 ? this.pushClassPrivateProperty(t2, o2) : this.pushClassProperty(t2, n2) : this.unexpected() : (u2.kind = p2.name, this.parseClassElementName(i2), this.isPrivateName(u2.key) ? this.pushClassPrivateMethod(t2, a2, false, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Gi.ConstructorIsAccessor), this.pushClassMethod(t2, i2, false, false, false, false)), this.checkGetterSetterParams(i2));
          else {
            const e3 = this.eat(Mi.star);
            h2.optional && this.unexpected(D2), u2.kind = "method", this.parseClassElementName(u2), this.parsePostMemberNameModifiers(h2), this.isPrivateName(u2.key) ? this.pushClassPrivateMethod(t2, a2, e3, true) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Gi.ConstructorIsAsync), this.pushClassMethod(t2, i2, e3, true, false, false));
          }
        }
        parseClassElementName(t2) {
          const e2 = this.parsePropertyName(t2, true);
          return t2.computed || !t2.static || "prototype" !== e2.name && "prototype" !== e2.value || this.raise(e2.start, Gi.StaticPrototype), this.isPrivateName(e2) && "constructor" === this.getPrivateNameSV(e2) && this.raise(e2.start, Gi.ConstructorClassPrivateField), e2;
        }
        parseClassStaticBlock(t2, e2) {
          var s2;
          this.expectPlugin("classStaticBlock", e2.start), this.scope.enter(208);
          const r2 = this.state.labels;
          this.state.labels = [], this.prodParam.enter(0);
          const i2 = e2.body = [];
          this.parseBlockOrModuleBlockBody(i2, void 0, false, Mi.braceR), this.prodParam.exit(), this.scope.exit(), this.state.labels = r2, t2.body.push(this.finishNode(e2, "StaticBlock")), null != (s2 = e2.decorators) && s2.length && this.raise(e2.start, Gi.DecoratorStaticBlock);
        }
        pushClassProperty(t2, e2) {
          e2.computed || "constructor" !== e2.key.name && "constructor" !== e2.key.value || this.raise(e2.key.start, Gi.ConstructorClassField), t2.body.push(this.parseClassProperty(e2));
        }
        pushClassPrivateProperty(t2, e2) {
          const s2 = this.parseClassPrivateProperty(e2);
          t2.body.push(s2), this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), 0, s2.key.start);
        }
        pushClassMethod(t2, e2, s2, r2, i2, a2) {
          t2.body.push(this.parseMethod(e2, s2, r2, i2, a2, "ClassMethod", true));
        }
        pushClassPrivateMethod(t2, e2, s2, r2) {
          const i2 = this.parseMethod(e2, s2, r2, false, false, "ClassPrivateMethod", true);
          t2.body.push(i2);
          const a2 = "get" === i2.kind ? i2.static ? 6 : 2 : "set" === i2.kind ? i2.static ? 5 : 1 : 0;
          this.classScope.declarePrivateName(this.getPrivateNameSV(i2.key), a2, i2.key.start);
        }
        parsePostMemberNameModifiers(t2) {
        }
        parseClassPrivateProperty(t2) {
          return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassPrivateProperty");
        }
        parseClassProperty(t2) {
          return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassProperty");
        }
        parseInitializer(t2) {
          this.scope.enter(80), this.expressionScope.enter(pn()), this.prodParam.enter(0), t2.value = this.eat(Mi.eq) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
        }
        parseClassId(t2, e2, s2, r2 = 139) {
          this.match(Mi.name) ? (t2.id = this.parseIdentifier(), e2 && this.checkLVal(t2.id, "class name", r2)) : s2 || !e2 ? t2.id = null : this.unexpected(null, Gi.MissingClassName);
        }
        parseClassSuper(t2) {
          t2.superClass = this.eat(Mi._extends) ? this.parseExprSubscripts() : null;
        }
        parseExport(t2) {
          const e2 = this.maybeParseExportDefaultSpecifier(t2), s2 = !e2 || this.eat(Mi.comma), r2 = s2 && this.eatExportStar(t2), i2 = r2 && this.maybeParseExportNamespaceSpecifier(t2), a2 = s2 && (!i2 || this.eat(Mi.comma)), n2 = e2 || r2;
          if (r2 && !i2)
            return e2 && this.unexpected(), this.parseExportFrom(t2, true), this.finishNode(t2, "ExportAllDeclaration");
          const o2 = this.maybeParseExportNamedSpecifiers(t2);
          if (e2 && s2 && !r2 && !o2 || i2 && a2 && !o2)
            throw this.unexpected(null, Mi.braceL);
          let u2;
          if (n2 || o2 ? (u2 = false, this.parseExportFrom(t2, n2)) : u2 = this.maybeParseExportDeclaration(t2), n2 || o2 || u2)
            return this.checkExport(t2, true, false, !!t2.source), this.finishNode(t2, "ExportNamedDeclaration");
          if (this.eat(Mi._default))
            return t2.declaration = this.parseExportDefaultExpression(), this.checkExport(t2, true, true), this.finishNode(t2, "ExportDefaultDeclaration");
          throw this.unexpected(null, Mi.braceL);
        }
        eatExportStar(t2) {
          return this.eat(Mi.star);
        }
        maybeParseExportDefaultSpecifier(t2) {
          if (this.isExportDefaultSpecifier()) {
            this.expectPlugin("exportDefaultFrom");
            const e2 = this.startNode();
            return e2.exported = this.parseIdentifier(true), t2.specifiers = [this.finishNode(e2, "ExportDefaultSpecifier")], true;
          }
          return false;
        }
        maybeParseExportNamespaceSpecifier(t2) {
          if (this.isContextual("as")) {
            t2.specifiers || (t2.specifiers = []);
            const e2 = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
            return this.next(), e2.exported = this.parseModuleExportName(), t2.specifiers.push(this.finishNode(e2, "ExportNamespaceSpecifier")), true;
          }
          return false;
        }
        maybeParseExportNamedSpecifiers(t2) {
          return !!this.match(Mi.braceL) && (t2.specifiers || (t2.specifiers = []), t2.specifiers.push(...this.parseExportSpecifiers()), t2.source = null, t2.declaration = null, true);
        }
        maybeParseExportDeclaration(t2) {
          return !!this.shouldParseExportDeclaration() && (t2.specifiers = [], t2.source = null, t2.declaration = this.parseExportDeclaration(t2), true);
        }
        isAsyncFunction() {
          if (!this.isContextual("async"))
            return false;
          const t2 = this.nextTokenStart();
          return !Ri.test(this.input.slice(this.state.pos, t2)) && this.isUnparsedContextual(t2, "function");
        }
        parseExportDefaultExpression() {
          const t2 = this.startNode(), e2 = this.isAsyncFunction();
          if (this.match(Mi._function) || e2)
            return this.next(), e2 && this.next(), this.parseFunction(t2, 5, e2);
          if (this.match(Mi._class))
            return this.parseClass(t2, true, true);
          if (this.match(Mi.at))
            return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Gi.DecoratorBeforeExport), this.parseDecorators(false), this.parseClass(t2, true, true);
          if (this.match(Mi._const) || this.match(Mi._var) || this.isLet())
            throw this.raise(this.state.start, Gi.UnsupportedDefaultExport);
          {
            const t3 = this.parseMaybeAssignAllowIn();
            return this.semicolon(), t3;
          }
        }
        parseExportDeclaration(t2) {
          return this.parseStatement(null);
        }
        isExportDefaultSpecifier() {
          if (this.match(Mi.name)) {
            const t3 = this.state.value;
            if ("async" === t3 && !this.state.containsEsc || "let" === t3)
              return false;
            if (("type" === t3 || "interface" === t3) && !this.state.containsEsc) {
              const t4 = this.lookahead();
              if (t4.type === Mi.name && "from" !== t4.value || t4.type === Mi.braceL)
                return this.expectOnePlugin(["flow", "typescript"]), false;
            }
          } else if (!this.match(Mi._default))
            return false;
          const t2 = this.nextTokenStart(), e2 = this.isUnparsedContextual(t2, "from");
          if (44 === this.input.charCodeAt(t2) || this.match(Mi.name) && e2)
            return true;
          if (this.match(Mi._default) && e2) {
            const e3 = this.input.charCodeAt(this.nextTokenStartSince(t2 + 4));
            return 34 === e3 || 39 === e3;
          }
          return false;
        }
        parseExportFrom(t2, e2) {
          if (this.eatContextual("from")) {
            t2.source = this.parseImportSource(), this.checkExport(t2);
            const e3 = this.maybeParseImportAssertions();
            e3 && (t2.assertions = e3);
          } else
            e2 ? this.unexpected() : t2.source = null;
          this.semicolon();
        }
        shouldParseExportDeclaration() {
          if (this.match(Mi.at) && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
            if (!this.getPluginOption("decorators", "decoratorsBeforeExport"))
              return true;
            this.unexpected(this.state.start, Gi.DecoratorBeforeExport);
          }
          return "var" === this.state.type.keyword || "const" === this.state.type.keyword || "function" === this.state.type.keyword || "class" === this.state.type.keyword || this.isLet() || this.isAsyncFunction();
        }
        checkExport(t2, e2, s2, r2) {
          if (e2) {
            if (s2) {
              if (this.checkDuplicateExports(t2, "default"), this.hasPlugin("exportDefaultFrom")) {
                var i2;
                const e3 = t2.declaration;
                "Identifier" !== e3.type || "from" !== e3.name || e3.end - e3.start != 4 || null != (i2 = e3.extra) && i2.parenthesized || this.raise(e3.start, Gi.ExportDefaultFromAsIdentifier);
              }
            } else if (t2.specifiers && t2.specifiers.length)
              for (const e3 of t2.specifiers) {
                const {
                  exported: t3
                } = e3, s3 = "Identifier" === t3.type ? t3.name : t3.value;
                if (this.checkDuplicateExports(e3, s3), !r2 && e3.local) {
                  const {
                    local: t4
                  } = e3;
                  "StringLiteral" === t4.type ? this.raise(e3.start, Gi.ExportBindingIsString, t4.value, s3) : (this.checkReservedWord(t4.name, t4.start, true, false), this.scope.checkLocalExport(t4));
                }
              }
            else if (t2.declaration) {
              if ("FunctionDeclaration" === t2.declaration.type || "ClassDeclaration" === t2.declaration.type) {
                const e3 = t2.declaration.id;
                if (!e3)
                  throw new Error("Assertion failure");
                this.checkDuplicateExports(t2, e3.name);
              } else if ("VariableDeclaration" === t2.declaration.type)
                for (const e3 of t2.declaration.declarations)
                  this.checkDeclaration(e3.id);
            }
          }
          if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
            throw this.raise(t2.start, Gi.UnsupportedDecoratorExport);
        }
        checkDeclaration(t2) {
          if ("Identifier" === t2.type)
            this.checkDuplicateExports(t2, t2.name);
          else if ("ObjectPattern" === t2.type)
            for (const e2 of t2.properties)
              this.checkDeclaration(e2);
          else if ("ArrayPattern" === t2.type)
            for (const e2 of t2.elements)
              e2 && this.checkDeclaration(e2);
          else
            "ObjectProperty" === t2.type ? this.checkDeclaration(t2.value) : "RestElement" === t2.type ? this.checkDeclaration(t2.argument) : "AssignmentPattern" === t2.type && this.checkDeclaration(t2.left);
        }
        checkDuplicateExports(t2, e2) {
          this.state.exportedIdentifiers.indexOf(e2) > -1 && this.raise(t2.start, "default" === e2 ? Gi.DuplicateDefaultExport : Gi.DuplicateExport, e2), this.state.exportedIdentifiers.push(e2);
        }
        parseExportSpecifiers() {
          const t2 = [];
          let e2 = true;
          for (this.expect(Mi.braceL); !this.eat(Mi.braceR); ) {
            if (e2)
              e2 = false;
            else if (this.expect(Mi.comma), this.eat(Mi.braceR))
              break;
            const s2 = this.startNode();
            s2.local = this.parseModuleExportName(), s2.exported = this.eatContextual("as") ? this.parseModuleExportName() : s2.local.__clone(), t2.push(this.finishNode(s2, "ExportSpecifier"));
          }
          return t2;
        }
        parseModuleExportName() {
          if (this.match(Mi.string)) {
            const t2 = this.parseLiteral(this.state.value, "StringLiteral"), e2 = t2.value.match(yn);
            return e2 && this.raise(t2.start, Gi.ModuleExportNameHasLoneSurrogate, e2[0].charCodeAt(0).toString(16)), t2;
          }
          return this.parseIdentifier(true);
        }
        parseImport(t2) {
          if (t2.specifiers = [], !this.match(Mi.string)) {
            const e3 = !this.maybeParseDefaultImportSpecifier(t2) || this.eat(Mi.comma), s2 = e3 && this.maybeParseStarImportSpecifier(t2);
            e3 && !s2 && this.parseNamedImportSpecifiers(t2), this.expectContextual("from");
          }
          t2.source = this.parseImportSource();
          const e2 = this.maybeParseImportAssertions();
          if (e2)
            t2.assertions = e2;
          else {
            const e3 = this.maybeParseModuleAttributes();
            e3 && (t2.attributes = e3);
          }
          return this.semicolon(), this.finishNode(t2, "ImportDeclaration");
        }
        parseImportSource() {
          return this.match(Mi.string) || this.unexpected(), this.parseExprAtom();
        }
        shouldParseDefaultImport(t2) {
          return this.match(Mi.name);
        }
        parseImportSpecifierLocal(t2, e2, s2, r2) {
          e2.local = this.parseIdentifier(), this.checkLVal(e2.local, r2, 9), t2.specifiers.push(this.finishNode(e2, s2));
        }
        parseAssertEntries() {
          const t2 = [], e2 = /* @__PURE__ */ new Set();
          do {
            if (this.match(Mi.braceR))
              break;
            const s2 = this.startNode(), r2 = this.state.value;
            if (this.match(Mi.string) ? s2.key = this.parseLiteral(r2, "StringLiteral") : s2.key = this.parseIdentifier(true), this.expect(Mi.colon), "type" !== r2 && this.raise(s2.key.start, Gi.ModuleAttributeDifferentFromType, r2), e2.has(r2) && this.raise(s2.key.start, Gi.ModuleAttributesWithDuplicateKeys, r2), e2.add(r2), !this.match(Mi.string))
              throw this.unexpected(this.state.start, Gi.ModuleAttributeInvalidValue);
            s2.value = this.parseLiteral(this.state.value, "StringLiteral"), this.finishNode(s2, "ImportAttribute"), t2.push(s2);
          } while (this.eat(Mi.comma));
          return t2;
        }
        maybeParseModuleAttributes() {
          if (!this.match(Mi._with) || this.hasPrecedingLineBreak())
            return this.hasPlugin("moduleAttributes") ? [] : null;
          this.expectPlugin("moduleAttributes"), this.next();
          const t2 = [], e2 = /* @__PURE__ */ new Set();
          do {
            const s2 = this.startNode();
            if (s2.key = this.parseIdentifier(true), "type" !== s2.key.name && this.raise(s2.key.start, Gi.ModuleAttributeDifferentFromType, s2.key.name), e2.has(s2.key.name) && this.raise(s2.key.start, Gi.ModuleAttributesWithDuplicateKeys, s2.key.name), e2.add(s2.key.name), this.expect(Mi.colon), !this.match(Mi.string))
              throw this.unexpected(this.state.start, Gi.ModuleAttributeInvalidValue);
            s2.value = this.parseLiteral(this.state.value, "StringLiteral"), this.finishNode(s2, "ImportAttribute"), t2.push(s2);
          } while (this.eat(Mi.comma));
          return t2;
        }
        maybeParseImportAssertions() {
          if (!this.isContextual("assert") || this.hasPrecedingLineBreak())
            return this.hasPlugin("importAssertions") ? [] : null;
          this.expectPlugin("importAssertions"), this.next(), this.eat(Mi.braceL);
          const t2 = this.parseAssertEntries();
          return this.eat(Mi.braceR), t2;
        }
        maybeParseDefaultImportSpecifier(t2) {
          return !!this.shouldParseDefaultImport(t2) && (this.parseImportSpecifierLocal(t2, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), true);
        }
        maybeParseStarImportSpecifier(t2) {
          if (this.match(Mi.star)) {
            const e2 = this.startNode();
            return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(t2, e2, "ImportNamespaceSpecifier", "import namespace specifier"), true;
          }
          return false;
        }
        parseNamedImportSpecifiers(t2) {
          let e2 = true;
          for (this.expect(Mi.braceL); !this.eat(Mi.braceR); ) {
            if (e2)
              e2 = false;
            else {
              if (this.eat(Mi.colon))
                throw this.raise(this.state.start, Gi.DestructureNamedImport);
              if (this.expect(Mi.comma), this.eat(Mi.braceR))
                break;
            }
            this.parseImportSpecifier(t2);
          }
        }
        parseImportSpecifier(t2) {
          const e2 = this.startNode();
          if (e2.imported = this.parseModuleExportName(), this.eatContextual("as"))
            e2.local = this.parseIdentifier();
          else {
            const {
              imported: t3
            } = e2;
            if ("StringLiteral" === t3.type)
              throw this.raise(e2.start, Gi.ImportBindingIsString, t3.value);
            this.checkReservedWord(t3.name, e2.start, true, true), e2.local = t3.__clone();
          }
          this.checkLVal(e2.local, "import specifier", 9), t2.specifiers.push(this.finishNode(e2, "ImportSpecifier"));
        }
        isThisParam(t2) {
          return "Identifier" === t2.type && "this" === t2.name;
        }
      } {
        constructor(t2, e2) {
          super(t2 = function(t3) {
            const e3 = {};
            for (const s2 of Object.keys(Qa))
              e3[s2] = t3 && null != t3[s2] ? t3[s2] : Qa[s2];
            return e3;
          }(t2), e2), this.options = t2, this.initializeScopes(), this.plugins = function(t3) {
            const e3 = /* @__PURE__ */ new Map();
            for (const s2 of t3) {
              const [t4, r2] = Array.isArray(s2) ? s2 : [s2, {}];
              e3.has(t4) || e3.set(t4, r2 || {});
            }
            return e3;
          }(this.options.plugins), this.filename = t2.sourceFilename;
        }
        getScopeHandler() {
          return Fa;
        }
        parse() {
          this.enterInitialScopes();
          const t2 = this.startNode(), e2 = this.startNode();
          return this.nextToken(), t2.errors = null, this.parseTopLevel(t2, e2), t2.errors = this.state.errors, t2;
        }
      }
      function En(t2, e2) {
        let s2 = An;
        return null != t2 && t2.plugins && (!function(t3) {
          if (Ga(t3, "decorators")) {
            if (Ga(t3, "decorators-legacy"))
              throw new Error("Cannot use the decorators and decorators-legacy plugin together");
            const e3 = Ka(t3, "decorators", "decoratorsBeforeExport");
            if (null == e3)
              throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
            if ("boolean" != typeof e3)
              throw new Error("'decoratorsBeforeExport' must be a boolean.");
          }
          if (Ga(t3, "flow") && Ga(t3, "typescript"))
            throw new Error("Cannot combine flow and typescript plugins.");
          if (Ga(t3, "placeholders") && Ga(t3, "v8intrinsic"))
            throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
          if (Ga(t3, "pipelineOperator") && !Xa.includes(Ka(t3, "pipelineOperator", "proposal")))
            throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + Xa.map((t4) => "'".concat(t4, "'")).join(", "));
          if (Ga(t3, "moduleAttributes")) {
            if (Ga(t3, "importAssertions"))
              throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
            if ("may-2020" !== Ka(t3, "moduleAttributes", "version"))
              throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
          if (Ga(t3, "recordAndTuple") && !Ja.includes(Ka(t3, "recordAndTuple", "syntaxType")))
            throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + Ja.map((t4) => "'".concat(t4, "'")).join(", "));
          if (Ga(t3, "asyncDoExpressions") && !Ga(t3, "doExpressions")) {
            const t4 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
            throw t4.missingPlugins = "doExpressions", t4;
          }
        }(t2.plugins), s2 = function(t3) {
          const e3 = Ya.filter((e4) => Ga(t3, e4)), s3 = e3.join("/");
          let r2 = Cn[s3];
          if (!r2) {
            r2 = An;
            for (const t4 of e3)
              r2 = $a[t4](r2);
            Cn[s3] = r2;
          }
          return r2;
        }(t2.plugins)), new s2(t2, e2);
      }
      const Cn = {};
      var xn = function(t2, e2) {
        var s2;
        if ("unambiguous" !== (null == (s2 = e2) ? void 0 : s2.sourceType))
          return En(e2, t2).parse();
        e2 = Object.assign({}, e2);
        try {
          e2.sourceType = "module";
          const s3 = En(e2, t2), r2 = s3.parse();
          if (s3.sawUnambiguousESM)
            return r2;
          if (s3.ambiguousScriptDifferentAst)
            try {
              return e2.sourceType = "script", En(e2, t2).parse();
            } catch (t3) {
            }
          else
            r2.program.sourceType = "script";
          return r2;
        } catch (s3) {
          try {
            return e2.sourceType = "script", En(e2, t2).parse();
          } catch (t3) {
          }
          throw s3;
        }
      }, Fn = function(t2, e2) {
        const s2 = En(e2, t2);
        return s2.options.strictMode && (s2.state.strict = true), s2.getExpression();
      }, gn = Mi, bn = Object.defineProperty({
        parse: xn,
        parseExpression: Fn,
        tokTypes: gn
      }, "__esModule", {
        value: true
      });
      const {
        isNonEmptyArray: Pn
      } = pe;
      function Tn(t2 = {}) {
        const {
          allowComments: e2 = true
        } = t2;
        return function(t3) {
          let s2;
          try {
            s2 = bn.parseExpression(t3, {
              tokens: true,
              ranges: true
            });
          } catch (t4) {
            throw wi(t4);
          }
          if (!e2 && Pn(s2.comments))
            throw wn(s2.comments[0], "Comment");
          return Bn(s2), s2;
        };
      }
      function wn(t2, e2) {
        const [s2, r2] = [t2.loc.start, t2.loc.end].map(({
          line: t3,
          column: e3
        }) => ({
          line: t3,
          column: e3 + 1
        }));
        return le("".concat(e2, " is not allowed in JSON."), {
          start: s2,
          end: r2
        });
      }
      function Bn(t2) {
        switch (t2.type) {
          case "ArrayExpression":
            for (const e2 of t2.elements)
              null !== e2 && Bn(e2);
            return;
          case "ObjectExpression":
            for (const e2 of t2.properties)
              Bn(e2);
            return;
          case "ObjectProperty":
            if (t2.computed)
              throw wn(t2.key, "Computed key");
            if (t2.shorthand)
              throw wn(t2.key, "Shorthand property");
            return "Identifier" !== t2.key.type && Bn(t2.key), void Bn(t2.value);
          case "UnaryExpression": {
            const {
              operator: e2,
              argument: s2
            } = t2;
            if ("+" !== e2 && "-" !== e2)
              throw wn(t2, "Operator '".concat(t2.operator, "'"));
            if ("NumericLiteral" === s2.type || "Identifier" === s2.type && ("Infinity" === s2.name || "NaN" === s2.name))
              return;
            throw wn(s2, "Operator '".concat(e2, "' before '").concat(s2.type, "'"));
          }
          case "Identifier":
            if ("Infinity" !== t2.name && "NaN" !== t2.name && "undefined" !== t2.name)
              throw wn(t2, "Identifier '".concat(t2.name, "'"));
            return;
          case "TemplateLiteral":
            if (Pn(t2.expressions))
              throw wn(t2.expressions[0], "'TemplateLiteral' with expression");
            for (const e2 of t2.quasis)
              Bn(e2);
            return;
          case "NullLiteral":
          case "BooleanLiteral":
          case "NumericLiteral":
          case "StringLiteral":
          case "TemplateElement":
            return;
          default:
            throw wn(t2, "'".concat(t2.type, "'"));
        }
      }
      const Sn = Tn();
      var Nn = {
        json: Ti({
          parse: Sn,
          hasPragma: () => true
        }),
        json5: Ti(Sn),
        "json-stringify": Ti({
          parse: Tn({
            allowComments: false
          }),
          astFormat: "estree-json"
        })
      };
      const {
        getNextNonSpaceNonCommentCharacterIndexWithStartIndex: In,
        getShebang: vn
      } = pe, kn = {
        sourceType: "module",
        allowAwaitOutsideFunction: true,
        allowImportExportEverywhere: true,
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        allowUndeclaredExports: true,
        errorRecovery: true,
        createParenthesizedExpressions: true,
        plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "v8intrinsic", "partialApplication", ["decorators", {
          decoratorsBeforeExport: false
        }], "privateIn", "importAssertions", ["recordAndTuple", {
          syntaxType: "hash"
        }], "decimal", "classStaticBlock", "moduleBlocks", "asyncDoExpressions"],
        tokens: true,
        ranges: true
      }, Ln = [["pipelineOperator", {
        proposal: "smart"
      }], ["pipelineOperator", {
        proposal: "minimal"
      }], ["pipelineOperator", {
        proposal: "fsharp"
      }]], On = (t2) => Object.assign({}, kn, {
        plugins: [...kn.plugins, ...t2]
      }), Mn = /@(?:no)?flow\b/;
      function Rn(t2, ...e2) {
        return (s2, r2, i2 = {}) => {
          if ("babel" === i2.parser && function(t3, e3) {
            if (e3.filepath && e3.filepath.endsWith(".js.flow"))
              return true;
            const s3 = vn(t3);
            s3 && (t3 = t3.slice(s3.length));
            const r3 = In(t3, 0);
            return false !== r3 && (t3 = t3.slice(0, r3)), Mn.test(t3);
          }(s2, i2))
            return i2.parser = "babel-flow", _n(s2, r2, i2);
          let a2 = e2;
          "script" === i2.__babelSourceType && (a2 = a2.map((t3) => Object.assign({}, t3, {
            sourceType: "script"
          }))), s2.includes("|>") && (a2 = T(Ln.map((t3) => a2.map((e3) => Object.assign({}, e3, {
            plugins: [...e3.plugins, t3]
          })))));
          const {
            result: n2,
            error: o2
          } = w(...a2.map((e3) => () => function(t3, e4, s3) {
            const r3 = (0, bn[t3])(e4, s3), i3 = r3.errors.find((t4) => !Vn.has(t4.reasonCode));
            if (i3)
              throw i3;
            return r3;
          }(t2, s2, e3)));
          if (!n2)
            throw wi(o2);
          return Br(n2, Object.assign({}, i2, {
            originalText: s2
          }));
        };
      }
      const jn = Rn("parse", On(["jsx", "flow"])), _n = Rn("parse", On(["jsx", ["flow", {
        all: true,
        enums: true
      }]])), Un = Rn("parse", On(["jsx", "typescript"]), On(["typescript"])), qn = Rn("parseExpression", On(["jsx"])), Vn = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), Hn = Ti(jn), zn = Ti(qn);
      return {
        parsers: Object.assign({
          babel: Hn,
          "babel-flow": Ti(_n),
          "babel-ts": Ti(Un)
        }, Nn, {
          __js_expression: zn,
          __vue_expression: zn,
          __vue_event_binding: Hn
        })
      };
    });
  }
});

// dep:prettier_parser-babel
init_define_ngDevMode();
var prettier_parser_babel_default = require_parser_babel();
export {
  prettier_parser_babel_default as default
};
//# sourceMappingURL=prettier_parser-babel.js.map
