import {
  require_array_slice
} from "./chunk-OLZ5WG4Z.js";
import {
  require_classof_raw,
  require_document_create_element,
  require_engine_user_agent,
  require_fails,
  require_function_apply,
  require_function_bind_context,
  require_global,
  require_has_own_property,
  require_html,
  require_is_callable
} from "./chunk-IPK6NK5O.js";
import {
  __commonJS,
  init_define_ngDevMode
} from "./chunk-XN7ES5DP.js";

// node_modules/core-js/internals/engine-is-node.js
var require_engine_is_node = __commonJS({
  "node_modules/core-js/internals/engine-is-node.js"(exports, module) {
    init_define_ngDevMode();
    var classof = require_classof_raw();
    var global = require_global();
    module.exports = classof(global.process) == "process";
  }
});

// node_modules/core-js/internals/validate-arguments-length.js
var require_validate_arguments_length = __commonJS({
  "node_modules/core-js/internals/validate-arguments-length.js"(exports, module) {
    init_define_ngDevMode();
    var $TypeError = TypeError;
    module.exports = function(passed, required) {
      if (passed < required)
        throw $TypeError("Not enough arguments");
      return passed;
    };
  }
});

// node_modules/core-js/internals/engine-is-ios.js
var require_engine_is_ios = __commonJS({
  "node_modules/core-js/internals/engine-is-ios.js"(exports, module) {
    init_define_ngDevMode();
    var userAgent = require_engine_user_agent();
    module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
  }
});

// node_modules/core-js/internals/task.js
var require_task = __commonJS({
  "node_modules/core-js/internals/task.js"(exports, module) {
    init_define_ngDevMode();
    var global = require_global();
    var apply = require_function_apply();
    var bind = require_function_bind_context();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var fails = require_fails();
    var html = require_html();
    var arraySlice = require_array_slice();
    var createElement = require_document_create_element();
    var validateArgumentsLength = require_validate_arguments_length();
    var IS_IOS = require_engine_is_ios();
    var IS_NODE = require_engine_is_node();
    var set = global.setImmediate;
    var clear = global.clearImmediate;
    var process = global.process;
    var Dispatch = global.Dispatch;
    var Function = global.Function;
    var MessageChannel = global.MessageChannel;
    var String = global.String;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = "onreadystatechange";
    var location;
    var defer;
    var channel;
    var port;
    try {
      location = global.location;
    } catch (error) {
    }
    var run = function(id) {
      if (hasOwn(queue, id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var runner = function(id) {
      return function() {
        run(id);
      };
    };
    var listener = function(event) {
      run(event.data);
    };
    var post = function(id) {
      global.postMessage(String(id), location.protocol + "//" + location.host);
    };
    if (!set || !clear) {
      set = function setImmediate(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable(handler) ? handler : Function(handler);
        var args = arraySlice(arguments, 1);
        queue[++counter] = function() {
          apply(fn, void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id) {
        delete queue[id];
      };
      if (IS_NODE) {
        defer = function(id) {
          process.nextTick(runner(id));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
          Dispatch.now(runner(id));
        };
      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listener;
        defer = bind(port.postMessage, port);
      } else if (global.addEventListener && isCallable(global.postMessage) && !global.importScripts && location && location.protocol !== "file:" && !fails(post)) {
        defer = post;
        global.addEventListener("message", listener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id) {
          html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(runner(id), 0);
        };
      }
    }
    module.exports = {
      set,
      clear
    };
  }
});

export {
  require_engine_is_node,
  require_validate_arguments_length,
  require_engine_is_ios,
  require_task
};
//# sourceMappingURL=chunk-CFMFTW6U.js.map
