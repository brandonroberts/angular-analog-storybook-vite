import {
  require_is_regexp
} from "./chunk-OPAZLAKG.js";
import {
  require_species_constructor
} from "./chunk-ZBKRFRJR.js";
import {
  require_advance_string_index,
  require_array_slice_simple,
  require_fix_regexp_well_known_symbol_logic,
  require_regexp_exec,
  require_regexp_exec_abstract,
  require_regexp_sticky_helpers,
  require_to_string
} from "./chunk-WDY4P2NX.js";
import {
  require_an_object,
  require_fails,
  require_function_apply,
  require_function_call,
  require_function_uncurry_this,
  require_get_method,
  require_require_object_coercible,
  require_to_length
} from "./chunk-IPK6NK5O.js";
import {
  __esm,
  init_define_ngDevMode
} from "./chunk-XN7ES5DP.js";

// node_modules/core-js/modules/es.string.split.js
var apply, call, uncurryThis, fixRegExpWellKnownSymbolLogic, isRegExp, anObject, requireObjectCoercible, speciesConstructor, advanceStringIndex, toLength, toString, getMethod, arraySlice, callRegExpExec, regexpExec, stickyHelpers, fails, UNSUPPORTED_Y, MAX_UINT32, min, $push, exec, push, stringSlice, SPLIT_WORKS_WITH_OVERWRITTEN_EXEC;
var init_es_string_split = __esm({
  "node_modules/core-js/modules/es.string.split.js"() {
    "use strict";
    init_define_ngDevMode();
    apply = require_function_apply();
    call = require_function_call();
    uncurryThis = require_function_uncurry_this();
    fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    isRegExp = require_is_regexp();
    anObject = require_an_object();
    requireObjectCoercible = require_require_object_coercible();
    speciesConstructor = require_species_constructor();
    advanceStringIndex = require_advance_string_index();
    toLength = require_to_length();
    toString = require_to_string();
    getMethod = require_get_method();
    arraySlice = require_array_slice_simple();
    callRegExpExec = require_regexp_exec_abstract();
    regexpExec = require_regexp_exec();
    stickyHelpers = require_regexp_sticky_helpers();
    fails = require_fails();
    UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    MAX_UINT32 = 4294967295;
    min = Math.min;
    $push = [].push;
    exec = uncurryThis(/./.exec);
    push = uncurryThis($push);
    stringSlice = uncurryThis("".slice);
    SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit;
      if ("abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
        internalSplit = function(separator, limit) {
          var string = toString(requireObjectCoercible(this));
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (separator === void 0)
            return [string];
          if (!isRegExp(separator)) {
            return call(nativeSplit, string, separator, lim);
          }
          var output = [];
          var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
          var lastLastIndex = 0;
          var separatorCopy = new RegExp(separator.source, flags + "g");
          var match, lastIndex, lastLength;
          while (match = call(regexpExec, separatorCopy, string)) {
            lastIndex = separatorCopy.lastIndex;
            if (lastIndex > lastLastIndex) {
              push(output, stringSlice(string, lastLastIndex, match.index));
              if (match.length > 1 && match.index < string.length)
                apply($push, output, arraySlice(match, 1));
              lastLength = match[0].length;
              lastLastIndex = lastIndex;
              if (output.length >= lim)
                break;
            }
            if (separatorCopy.lastIndex === match.index)
              separatorCopy.lastIndex++;
          }
          if (lastLastIndex === string.length) {
            if (lastLength || !exec(separatorCopy, ""))
              push(output, "");
          } else
            push(output, stringSlice(string, lastLastIndex));
          return output.length > lim ? arraySlice(output, 0, lim) : output;
        };
      } else if ("0".split(void 0, 0).length) {
        internalSplit = function(separator, limit) {
          return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
        };
      } else
        internalSplit = nativeSplit;
      return [
        function split(separator, limit) {
          var O = requireObjectCoercible(this);
          var splitter = separator == void 0 ? void 0 : getMethod(separator, SPLIT);
          return splitter ? call(splitter, separator, O, limit) : call(internalSplit, toString(O), separator, limit);
        },
        function(string, limit) {
          var rx = anObject(this);
          var S = toString(string);
          var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
          if (res.done)
            return res.value;
          var C = speciesConstructor(rx, RegExp);
          var unicodeMatching = rx.unicode;
          var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
          var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (S.length === 0)
            return callRegExpExec(splitter, S) === null ? [S] : [];
          var p = 0;
          var q = 0;
          var A = [];
          while (q < S.length) {
            splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
            var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
            var e;
            if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
              q = advanceStringIndex(S, q, unicodeMatching);
            } else {
              push(A, stringSlice(S, p, q));
              if (A.length === lim)
                return A;
              for (var i = 1; i <= z.length - 1; i++) {
                push(A, z[i]);
                if (A.length === lim)
                  return A;
              }
              q = p = e;
            }
          }
          push(A, stringSlice(S, p));
          return A;
        }
      ];
    }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
  }
});

export {
  init_es_string_split
};
//# sourceMappingURL=chunk-PRKSDZJ7.js.map
